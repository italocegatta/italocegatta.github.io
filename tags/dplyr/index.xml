<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Dplyr on Ítalo Cegatta</title>
    <link>/tags/dplyr/</link>
    <description>Recent content in Dplyr on Ítalo Cegatta</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>pt-br</language>
    <lastBuildDate>Sun, 30 Apr 2017 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="/tags/dplyr/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Interpolação pelo inverso do quadrado da distância</title>
      <link>/interpolacao-pelo-inverso-do-quadrado-da-distancia/</link>
      <pubDate>Sun, 30 Apr 2017 00:00:00 +0000</pubDate>
      
      <guid>/interpolacao-pelo-inverso-do-quadrado-da-distancia/</guid>
      <description>É comum quando temos um determinado valor distribuído espacialmente e queremos estimá-lo para um ponto específico. Existem inúmeras formas de se chegar nesta estimativa, mas quero mostrar apenas uma neste post. O objetivo é estimar o quanto choveu em Itapetininga-SP, a partir de dados de chuva de outras 6 cidades próximas. Utilizaremos para isso os dados das estações automáticas do INMET.
Primeiro, vamos importar e visualizar os dados que temos disponível.</description>
    </item>
    
    <item>
      <title>Interpolação pelo inverso do quadrado da distância</title>
      <link>/interpolacao-pelo-inverso-do-quadrado-da-distancia/</link>
      <pubDate>Sun, 30 Apr 2017 00:00:00 +0000</pubDate>
      
      <guid>/interpolacao-pelo-inverso-do-quadrado-da-distancia/</guid>
      <description>&lt;script src=&#34;/rmarkdown-libs/htmlwidgets/htmlwidgets.js&#34;&gt;&lt;/script&gt;
&lt;script src=&#34;/rmarkdown-libs/jquery/jquery.min.js&#34;&gt;&lt;/script&gt;
&lt;link href=&#34;/rmarkdown-libs/leaflet/leaflet.css&#34; rel=&#34;stylesheet&#34; /&gt;
&lt;script src=&#34;/rmarkdown-libs/leaflet/leaflet.js&#34;&gt;&lt;/script&gt;
&lt;link href=&#34;/rmarkdown-libs/leafletfix/leafletfix.css&#34; rel=&#34;stylesheet&#34; /&gt;
&lt;link href=&#34;/rmarkdown-libs/leaflet-label/leaflet.label.css&#34; rel=&#34;stylesheet&#34; /&gt;
&lt;script src=&#34;/rmarkdown-libs/leaflet-label/leaflet.label.js&#34;&gt;&lt;/script&gt;
&lt;script src=&#34;/rmarkdown-libs/Proj4Leaflet/proj4-compressed.js&#34;&gt;&lt;/script&gt;
&lt;script src=&#34;/rmarkdown-libs/Proj4Leaflet/proj4leaflet.js&#34;&gt;&lt;/script&gt;
&lt;script src=&#34;/rmarkdown-libs/leaflet-binding/leaflet.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;É comum quando temos um determinado valor distribuido espacialmente e queremos estimá-lo para um ponto específico. Existem inúmeras formas para se chegar nesta estimativa, mas quero mostrar apenas uma neste post. O objetivo é estimar o quanto choveu em Itapetininga-SP, a partir de dados de chuva de outras 6 cidades próximas. Utilizaremos para isso os dados das estações automáticas do &lt;a href=&#34;http://www.inmet.gov.br/portal/index.php?r=estacoes/estacoesAutomaticas&#34;&gt;INMET&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Primeiro, vamos importar e visualizar os dados que temos disponível.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;if (!require(&amp;quot;pacman&amp;quot;)) install.packages(&amp;quot;pacman&amp;quot;)
pacman::p_load(readr, dplyr, leaflet)&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# importa o arquivo os dados de chuva
dados &amp;lt;- read_csv2(
  &amp;quot;https://raw.githubusercontent.com/italocegatta/italocegatta.github.io_source/master/content/dados/chuva_inmet.csv&amp;quot;
)

dados&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 6 × 4
##               cidade       lon       lat     p
##                &amp;lt;chr&amp;gt;     &amp;lt;dbl&amp;gt;     &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt;
## 1           Sorocaba -47.58555 -23.42603  27.0
## 2            Itapeva -48.88582 -23.98192  33.4
## 3 Sao Miguel Arcanjo -48.16482 -23.85202  34.6
## 4              Avare -48.94100 -23.10175  18.2
## 5         Piracicaba -47.62332 -22.70313  30.8
## 6       Barra Bonita -48.55757 -22.47121  42.8&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;O mapa a seguir mostra o total de chuva resgistrado pela estação meteorológica de cada cidade no dia 26/04/2017. Nosso objetivo é estimar o quanto choveu em Itapetininga utilizando a interpolação pelo inverso do quadrado da distância ou IDW (Inverse Distance Weighting).&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;leaflet(dados) %&amp;gt;% 
  addTiles() %&amp;gt;% 
  addMarkers(-48.0530600, -23.5916700) %&amp;gt;% 
  addCircleMarkers(
    ~lon, ~lat, 
    radius = ~p * 0.8, 
    label = ~as.character(p),
    popup = ~cidade,
    fillOpacity = 0.6,
    labelOptions = labelOptions(
      style = list(&amp;quot;color&amp;quot; = &amp;quot;white&amp;quot;),
      offset = c(5, -10),
      noHide = TRUE,
      textOnly = TRUE,
      direction = &amp;quot;bottom&amp;quot;
    )
  )&lt;/code&gt;&lt;/pre&gt;
&lt;div id=&#34;htmlwidget-7f6ba7ce4f5f142fcdf0&#34; style=&#34;width:100%;height:500px;&#34; class=&#34;leaflet html-widget&#34;&gt;&lt;/div&gt;
&lt;script type=&#34;application/json&#34; data-for=&#34;htmlwidget-7f6ba7ce4f5f142fcdf0&#34;&gt;{&#34;x&#34;:{&#34;options&#34;:{&#34;crs&#34;:{&#34;crsClass&#34;:&#34;L.CRS.EPSG3857&#34;,&#34;code&#34;:null,&#34;proj4def&#34;:null,&#34;projectedBounds&#34;:null,&#34;options&#34;:{}}},&#34;calls&#34;:[{&#34;method&#34;:&#34;addTiles&#34;,&#34;args&#34;:[&#34;//{s}.tile.openstreetmap.org/{z}/{x}/{y}.png&#34;,null,null,{&#34;minZoom&#34;:0,&#34;maxZoom&#34;:18,&#34;maxNativeZoom&#34;:null,&#34;tileSize&#34;:256,&#34;subdomains&#34;:&#34;abc&#34;,&#34;errorTileUrl&#34;:&#34;&#34;,&#34;tms&#34;:false,&#34;continuousWorld&#34;:false,&#34;noWrap&#34;:false,&#34;zoomOffset&#34;:0,&#34;zoomReverse&#34;:false,&#34;opacity&#34;:1,&#34;zIndex&#34;:null,&#34;unloadInvisibleTiles&#34;:null,&#34;updateWhenIdle&#34;:null,&#34;detectRetina&#34;:false,&#34;reuseTiles&#34;:false,&#34;attribution&#34;:&#34;&amp;copy; &lt;a href=\&#34;http://openstreetmap.org\&#34;&gt;OpenStreetMap&lt;\/a&gt; contributors, &lt;a href=\&#34;http://creativecommons.org/licenses/by-sa/2.0/\&#34;&gt;CC-BY-SA&lt;\/a&gt;&#34;}]},{&#34;method&#34;:&#34;addMarkers&#34;,&#34;args&#34;:[-23.59167,-48.05306,null,null,null,{&#34;clickable&#34;:true,&#34;draggable&#34;:false,&#34;keyboard&#34;:true,&#34;title&#34;:&#34;&#34;,&#34;alt&#34;:&#34;&#34;,&#34;zIndexOffset&#34;:0,&#34;opacity&#34;:1,&#34;riseOnHover&#34;:false,&#34;riseOffset&#34;:250},null,null,null,null,null,null,null]},{&#34;method&#34;:&#34;addCircleMarkers&#34;,&#34;args&#34;:[[-23.426035,-23.981918,-23.852022,-23.101749,-22.703132,-22.471205],[-47.585552,-48.885818,-48.164817,-48.940997,-47.623317,-48.557573],[21.6,26.72,27.68,14.56,24.64,34.24],null,null,{&#34;lineCap&#34;:null,&#34;lineJoin&#34;:null,&#34;clickable&#34;:true,&#34;pointerEvents&#34;:null,&#34;className&#34;:&#34;&#34;,&#34;stroke&#34;:true,&#34;color&#34;:&#34;#03F&#34;,&#34;weight&#34;:5,&#34;opacity&#34;:0.5,&#34;fill&#34;:true,&#34;fillColor&#34;:&#34;#03F&#34;,&#34;fillOpacity&#34;:0.6,&#34;dashArray&#34;:null},null,null,[&#34;Sorocaba&#34;,&#34;Itapeva&#34;,&#34;Sao Miguel Arcanjo&#34;,&#34;Avare&#34;,&#34;Piracicaba&#34;,&#34;Barra Bonita&#34;],null,[&#34;27&#34;,&#34;33.4&#34;,&#34;34.6&#34;,&#34;18.2&#34;,&#34;30.8&#34;,&#34;42.8&#34;],{&#34;clickable&#34;:false,&#34;noHide&#34;:true,&#34;direction&#34;:&#34;bottom&#34;,&#34;opacity&#34;:1,&#34;offset&#34;:[5,-10],&#34;textsize&#34;:&#34;10px&#34;,&#34;textOnly&#34;:true,&#34;style&#34;:{&#34;color&#34;:&#34;white&#34;},&#34;zoomAnimation&#34;:true,&#34;className&#34;:&#34;&#34;},null]}],&#34;limits&#34;:{&#34;lat&#34;:[-23.981918,-22.471205],&#34;lng&#34;:[-48.940997,-47.585552]}},&#34;evals&#34;:[],&#34;jsHooks&#34;:[]}&lt;/script&gt;
&lt;p&gt;A expressão que define o método é dada abaixo. Basicamente considera-se o valor de cada vizinho ponderado pelo inverso da distância entre ele e o ponto de interesse. Assim, vizinhos distantes contribuem com menos peso para o valor final que vizinhos mais próximos.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://bit.ly/2oN3IlI&#34; align=&#34;center&#34; border=&#34;0&#34; alt=&#34;x_{p} =\frac{\sum_{i=1}^n(\frac{1}{d_{i}^{2}}\times x_{i})}{\sum_{i=1}^n(\frac{1}{d_{i}^{2}})}&#34; width=&#34;153&#34; height=&#34;71&#34; /&gt;&lt;/p&gt;
&lt;p&gt;onde: xp = valor interpolado; xi = valor da i-ésimo ponto vizinho; di = distância entre o i-ésimo ponto de vizinho e o ponto de interesse.&lt;/p&gt;
&lt;p&gt;Agora que já definimos o método, vamos começar os cálculos. O primeiro valor calculado será a distância entre os pontos. Utilizaremos a formula de Haversine que retorna a distâncias entre dois pontos de uma esfera a partir de suas latitudes e longitudes.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;haversine &amp;lt;- function(lon1, lat1, lon2, lat2) {
  # converte graus pra radiano
  rad &amp;lt;- pi/180
  # raio medio da terra no equador em km
  R &amp;lt;- 6378.1

  dlon &amp;lt;- (lon2 - lon1) * rad
  dlat &amp;lt;- (lat2 - lat1) * rad

  a &amp;lt;- (sin(dlat/2))^2 +
       cos(lat1 * rad) *
       cos(lat2 * rad) *
       (sin(dlon/2))^2

  c &amp;lt;- 2 * atan2(sqrt(a), sqrt(1 - a))

  d &amp;lt;- R * c 

  # distancia em km
  return(d)
}&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;dist &amp;lt;- dados %&amp;gt;%
  mutate(d_itape = haversine(lon, lat, -48.0530600, -23.5916700))

dist&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 6 × 5
##               cidade       lon       lat     p   d_itape
##                &amp;lt;chr&amp;gt;     &amp;lt;dbl&amp;gt;     &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt;     &amp;lt;dbl&amp;gt;
## 1           Sorocaba -47.58555 -23.42603  27.0  51.16089
## 2            Itapeva -48.88582 -23.98192  33.4  95.30342
## 3 Sao Miguel Arcanjo -48.16482 -23.85202  34.6  31.13972
## 4              Avare -48.94100 -23.10175  18.2 105.87726
## 5         Piracicaba -47.62332 -22.70313  30.8 108.25070
## 6       Barra Bonita -48.55757 -22.47121  42.8 135.01301&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;O cálculo do IDW é relativamente simples, basta reproduzir a expressão do método.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;idw &amp;lt;- function(x, dist, na.rm = TRUE) {
  s1 &amp;lt;-  sum(x / dist, na.rm = na.rm)
  s2 &amp;lt;-  sum(dist^-1, na.rm = na.rm)

  return(s1 / s2)
}&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;dados_itape &amp;lt;- dist %&amp;gt;% 
  add_row(
    .,
    cidade = &amp;quot;Itapetininga&amp;quot;,
    lon = -48.0530600,
    lat = -23.5916700,
    p = round(idw(.$p, .$d_itape), 1)
  )

dados_itape&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 7 × 5
##               cidade       lon       lat     p   d_itape
##                &amp;lt;chr&amp;gt;     &amp;lt;dbl&amp;gt;     &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt;     &amp;lt;dbl&amp;gt;
## 1           Sorocaba -47.58555 -23.42603  27.0  51.16089
## 2            Itapeva -48.88582 -23.98192  33.4  95.30342
## 3 Sao Miguel Arcanjo -48.16482 -23.85202  34.6  31.13972
## 4              Avare -48.94100 -23.10175  18.2 105.87726
## 5         Piracicaba -47.62332 -22.70313  30.8 108.25070
## 6       Barra Bonita -48.55757 -22.47121  42.8 135.01301
## 7       Itapetininga -48.05306 -23.59167  31.3        NA&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Muito bom, agora vamos retornar ao mapa e adicionar o quanto choveu em Itapetiniga, de acordo com a interpolação por IDW. &lt;br&gt; &lt;br&gt; &lt;div id=&#34;htmlwidget-6f8e8c0cc5cb9b322cd8&#34; style=&#34;width:100%;height:500px;&#34; class=&#34;leaflet html-widget&#34;&gt;&lt;/div&gt;
&lt;script type=&#34;application/json&#34; data-for=&#34;htmlwidget-6f8e8c0cc5cb9b322cd8&#34;&gt;{&#34;x&#34;:{&#34;options&#34;:{&#34;crs&#34;:{&#34;crsClass&#34;:&#34;L.CRS.EPSG3857&#34;,&#34;code&#34;:null,&#34;proj4def&#34;:null,&#34;projectedBounds&#34;:null,&#34;options&#34;:{}}},&#34;calls&#34;:[{&#34;method&#34;:&#34;addTiles&#34;,&#34;args&#34;:[&#34;//{s}.tile.openstreetmap.org/{z}/{x}/{y}.png&#34;,null,null,{&#34;minZoom&#34;:0,&#34;maxZoom&#34;:18,&#34;maxNativeZoom&#34;:null,&#34;tileSize&#34;:256,&#34;subdomains&#34;:&#34;abc&#34;,&#34;errorTileUrl&#34;:&#34;&#34;,&#34;tms&#34;:false,&#34;continuousWorld&#34;:false,&#34;noWrap&#34;:false,&#34;zoomOffset&#34;:0,&#34;zoomReverse&#34;:false,&#34;opacity&#34;:1,&#34;zIndex&#34;:null,&#34;unloadInvisibleTiles&#34;:null,&#34;updateWhenIdle&#34;:null,&#34;detectRetina&#34;:false,&#34;reuseTiles&#34;:false,&#34;attribution&#34;:&#34;&amp;copy; &lt;a href=\&#34;http://openstreetmap.org\&#34;&gt;OpenStreetMap&lt;\/a&gt; contributors, &lt;a href=\&#34;http://creativecommons.org/licenses/by-sa/2.0/\&#34;&gt;CC-BY-SA&lt;\/a&gt;&#34;}]},{&#34;method&#34;:&#34;addCircleMarkers&#34;,&#34;args&#34;:[[-23.426035,-23.981918,-23.852022,-23.101749,-22.703132,-22.471205,-23.59167],[-47.585552,-48.885818,-48.164817,-48.940997,-47.623317,-48.557573,-48.05306],[27,33.4,34.6,18.2,30.8,42.8,31.3],null,null,{&#34;lineCap&#34;:null,&#34;lineJoin&#34;:null,&#34;clickable&#34;:true,&#34;pointerEvents&#34;:null,&#34;className&#34;:&#34;&#34;,&#34;stroke&#34;:true,&#34;color&#34;:&#34;#03F&#34;,&#34;weight&#34;:5,&#34;opacity&#34;:0.5,&#34;fill&#34;:true,&#34;fillColor&#34;:&#34;#03F&#34;,&#34;fillOpacity&#34;:0.6,&#34;dashArray&#34;:null},null,null,[&#34;Sorocaba&#34;,&#34;Itapeva&#34;,&#34;Sao Miguel Arcanjo&#34;,&#34;Avare&#34;,&#34;Piracicaba&#34;,&#34;Barra Bonita&#34;,&#34;Itapetininga&#34;],null,[&#34;27&#34;,&#34;33.4&#34;,&#34;34.6&#34;,&#34;18.2&#34;,&#34;30.8&#34;,&#34;42.8&#34;,&#34;31.3&#34;],{&#34;clickable&#34;:false,&#34;noHide&#34;:true,&#34;direction&#34;:&#34;bottom&#34;,&#34;opacity&#34;:1,&#34;offset&#34;:[5,-10],&#34;textsize&#34;:&#34;10px&#34;,&#34;textOnly&#34;:true,&#34;style&#34;:{&#34;color&#34;:&#34;white&#34;},&#34;zoomAnimation&#34;:true,&#34;className&#34;:&#34;&#34;},null]}],&#34;limits&#34;:{&#34;lat&#34;:[-23.981918,-22.471205],&#34;lng&#34;:[-48.940997,-47.585552]}},&#34;evals&#34;:[],&#34;jsHooks&#34;:[]}&lt;/script&gt;&lt;/p&gt;
&lt;p&gt;Caso tenha alguma dúvida ou sugestão sobre o post, fique à vontade para fazer um comentário ou me contactar por Email.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;devtools::session_info()&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  setting  value                       
##  version  R version 3.3.3 (2017-03-06)
##  system   x86_64, mingw32             
##  ui       RTerm                       
##  language (EN)                        
##  collate  Portuguese_Brazil.1252      
##  tz       America/Sao_Paulo           
##  date     2017-04-30                  
## 
##  package     * version date       source                           
##  assertthat    0.2.0   2017-04-11 CRAN (R 3.3.3)                   
##  backports     1.0.5   2017-01-18 CRAN (R 3.3.2)                   
##  blogdown      0.0.25  2017-03-23 Github (rstudio/blogdown@1c10d16)
##  bookdown      0.3.14  2017-03-23 Github (rstudio/bookdown@f427fdf)
##  crosstalk     1.0.0   2016-12-21 CRAN (R 3.3.3)                   
##  curl          2.6     2017-04-27 CRAN (R 3.3.3)                   
##  DBI           0.6-1   2017-04-01 CRAN (R 3.3.3)                   
##  devtools      1.12.0  2016-06-24 CRAN (R 3.3.3)                   
##  digest        0.6.12  2017-01-27 CRAN (R 3.3.2)                   
##  dplyr       * 0.5.0   2016-06-24 CRAN (R 3.3.2)                   
##  evaluate      0.10    2016-10-11 CRAN (R 3.3.3)                   
##  hms           0.3     2016-11-22 CRAN (R 3.3.2)                   
##  htmltools     0.3.6   2017-04-28 CRAN (R 3.3.3)                   
##  htmlwidgets   0.8     2016-11-09 CRAN (R 3.3.3)                   
##  httpuv        1.3.3   2015-08-04 CRAN (R 3.3.3)                   
##  jsonlite      1.4     2017-04-08 CRAN (R 3.3.3)                   
##  knitr         1.15.1  2016-11-22 CRAN (R 3.3.3)                   
##  lazyeval      0.2.0   2016-06-12 CRAN (R 3.3.2)                   
##  leaflet     * 1.1.0   2017-02-21 CRAN (R 3.3.3)                   
##  magrittr      1.5     2014-11-22 CRAN (R 3.3.2)                   
##  memoise       1.1.0   2017-04-21 CRAN (R 3.3.3)                   
##  mime          0.5     2016-07-07 CRAN (R 3.3.2)                   
##  pacman      * 0.4.1   2016-03-30 CRAN (R 3.3.3)                   
##  R6            2.2.0   2016-10-05 CRAN (R 3.3.2)                   
##  Rcpp          0.12.10 2017-03-19 CRAN (R 3.3.3)                   
##  readr       * 1.1.0   2017-03-22 CRAN (R 3.3.3)                   
##  rmarkdown     1.5     2017-04-26 CRAN (R 3.3.3)                   
##  rprojroot     1.2     2017-01-16 CRAN (R 3.3.3)                   
##  shiny         1.0.3   2017-04-26 CRAN (R 3.3.3)                   
##  stringi       1.1.5   2017-04-07 CRAN (R 3.3.3)                   
##  stringr       1.2.0   2017-02-18 CRAN (R 3.3.2)                   
##  tibble        1.3.0   2017-04-01 CRAN (R 3.3.3)                   
##  withr         1.0.2   2016-06-20 CRAN (R 3.3.3)                   
##  xtable        1.8-2   2016-02-05 CRAN (R 3.3.3)                   
##  yaml          2.1.14  2016-11-12 CRAN (R 3.3.3)&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Download automático de imagens MODIS</title>
      <link>/download-automatico-de-imagens-modis/</link>
      <pubDate>Sun, 15 Jan 2017 00:00:00 +0000</pubDate>
      
      <guid>/download-automatico-de-imagens-modis/</guid>
<<<<<<< HEAD
      <description>&lt;!-- BLOGDOWN-HEAD --&gt;
&lt;!-- /BLOGDOWN-HEAD --&gt;

&lt;!-- BLOGDOWN-BODY-BEFORE --&gt;
&lt;!-- /BLOGDOWN-BODY-BEFORE --&gt;
&lt;p&gt;O MODIS (MODerate resolution Imaging Spectroradiometer) faz parte de um programa da NASA para monitoramento da superfície terrestre. Os satélites Terra e Aqua fornecem informações muito interessantes para o setor agroflorestal e nos permite entender de maneira bastante eficaz a dinâmica do uso do solo e de crescimento das nossas culturas.&lt;/p&gt;
&lt;p&gt;O MODOIS tem diversos &lt;a href=&#34;https://modis.gsfc.nasa.gov/data/&#34;&gt;produtos&lt;/a&gt;, mas neste post vamos tratar especificamente do produto &lt;a href=&#34;https://lpdaac.usgs.gov/dataset_discovery/modis/modis_products_table/mod13q1_v006&#34;&gt;MOD13Q1&lt;/a&gt;, que disponibiliza a cada 16 dias um raster de EVI e NDVI com resolução de 250 m. Bom, se você está acostumado com imagens de satélite/drone/vant com resolução submétrica, pode ser que no primeiro momento esta escala te assuste. Mas vale lembrar que é um serviço gratuito e e de ótima qualidade.&lt;/p&gt;
&lt;p&gt;As cenas do MODIS ficam disponíveis em um &lt;a href=&#34;https://e4ftl01.cr.usgs.gov/&#34;&gt;ftp&lt;/a&gt; e navegando por lá podemos chegar na pasta do produto que nos &lt;a href=&#34;http://e4ftl01.cr.usgs.gov/MOLT/MOD13Q1.006&#34;&gt;interessa&lt;/a&gt;. Temos então imagens de satélite processadas, com correção atmosférica, sem deslocamento espacial e com regularidade. O satélite varre a terra a cada dois dias e as melhores visadas são utilizadas para compor o produto que é disponibilizado a cada 16 dias. Há casos (de baixa frequência) em que a nebulosidade é tanta que não é possível compor a informação do pixel dentro desta janela&lt;/p&gt;
&lt;p&gt;Nosso objetivo para este poste é fazer o download das cenas de forma automática, um web scraping. No R há diversos pacotes que nos auxiliam neste processo. A primeira etapa é acessar o ftp que contém as cenas e extrair as datas das cenas disponíveis.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;if (!require(&amp;quot;pacman&amp;quot;)) install.packages(&amp;quot;pacman&amp;quot;)
pacman::p_load(dplyr, xml2, rvest, httr, stringr, methods)&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# url do ftp que contém as cenas
path_root &amp;lt;- &amp;quot;http://e4ftl01.cr.usgs.gov/MOLT/MOD13Q1.006&amp;quot;

# carrega a raiz do ftp
page_root &amp;lt;- read_html(path_root)

# extrai os dias das cenas
scene_days &amp;lt;- page_root %&amp;gt;% 
 html_nodes(&amp;quot;a&amp;quot;) %&amp;gt;% 
  html_text(trim = T) %&amp;gt;%
  &amp;#39;[&amp;#39;(-c(1:7)) %&amp;gt;%
  str_replace_all(&amp;quot;\\/&amp;quot;, &amp;quot;&amp;quot;)

glimpse(scene_days)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  chr [1:395] &amp;quot;2000.02.18&amp;quot; &amp;quot;2000.03.05&amp;quot; &amp;quot;2000.03.21&amp;quot; ...&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Muito bem, temos até a data da ultima atualização deste post 395 cenas disponíveis. O script abaixo cria a pasta com a data da cena e coloca lá os &lt;a href=&#34;https://modis-land.gsfc.nasa.gov/MODLAND_grid.html&#34;&gt;tiles&lt;/a&gt; de seu interesse. Como exemplo vamos pegar os tiles que cobrem os estados de São Paulo e Bahia. Note que é preciso ter um cadastro para autorizar o download dos arquivos. É simples e rápido de fazer acessando este &lt;a href=&#34;https://urs.earthdata.nasa.gov/users/new/&#34;&gt;link&lt;/a&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# inicio do 1º loop - dias
for (i in seq_along(scene_days)) {
  # cria a pasta para receber os tiles
  if(!dir.exists(scene_days[i])) dir.create(scene_days[i])

  # ideintificador de iteração
  day &amp;lt;- scene_days[i]
  
  # carrega a pagina do dia da cena
  page_tiles &amp;lt;- read_html(paste(path_root, day, sep = &amp;quot;/&amp;quot;))
  
  # extrai os tiles de interesse
  path_tiles &amp;lt;- page_tiles %&amp;gt;% 
    html_nodes(&amp;quot;a&amp;quot;) %&amp;gt;% 
    html_text(trim = T) %&amp;gt;%
    &amp;#39;[&amp;#39;(str_detect(., &amp;quot;[hdf]$&amp;quot;)) %&amp;gt;% 
    &amp;#39;[&amp;#39;(str_detect(., &amp;quot;h13v11|h14v10&amp;quot;))
  
  # inicio do 2º loop - tiles
  for (j in seq_along(path_tiles)) {
    # url do tile
    path_tile &amp;lt;- paste(path_root, day, path_tiles[j], sep = &amp;quot;/&amp;quot;)

    # id do tile
    tile &amp;lt;- paste(day, path_tiles[j], sep = &amp;quot;/&amp;quot;)
    
    # download do arquivo
    if (!file.exists(tile)) {
      temp &amp;lt;- GET(path_tile, authenticate(&amp;quot;LOGIN&amp;quot;, &amp;quot;SENHA&amp;quot;))
      writeBin(content(temp, &amp;quot;raw&amp;quot;), tile)
      rm(temp)
    }
  }
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Como tudo que está neste blog, este script foi escrito para resolver um problema específico e com certeza tem muito espaço para melhoria. Os próximos passos da análise, extração dos rasters e processamento da imagem serão abordados em posts separados. No futuro, caso exista uma demanda, pode ser que as funções sejam reunidas em um pacote específico sobre isso.&lt;/p&gt;
&lt;p&gt;Caso tenha alguma dúvida ou sugestão sobre o post, fique à vontade para fazer um comentário ou me contactar por Email.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;devtools::session_info()&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  setting  value                       
##  version  R version 3.3.3 (2017-03-06)
##  system   x86_64, mingw32             
##  ui       RTerm                       
##  language (EN)                        
##  collate  Portuguese_Brazil.1252      
##  tz       America/Sao_Paulo           
##  date     2017-04-30                  
## 
##  package    * version  date       source                           
##  assertthat   0.2.0    2017-04-11 CRAN (R 3.3.3)                   
##  backports    1.0.5    2017-01-18 CRAN (R 3.3.2)                   
##  blogdown     0.0.25   2017-03-23 Github (rstudio/blogdown@1c10d16)
##  bookdown     0.3.14   2017-03-23 Github (rstudio/bookdown@f427fdf)
##  curl         2.6      2017-04-27 CRAN (R 3.3.3)                   
##  DBI          0.6-1    2017-04-01 CRAN (R 3.3.3)                   
##  devtools     1.12.0   2016-06-24 CRAN (R 3.3.3)                   
##  digest       0.6.12   2017-01-27 CRAN (R 3.3.2)                   
##  dplyr      * 0.5.0    2016-06-24 CRAN (R 3.3.2)                   
##  evaluate     0.10     2016-10-11 CRAN (R 3.3.3)                   
##  htmltools    0.3.6    2017-04-28 CRAN (R 3.3.3)                   
##  httr       * 1.2.1    2016-07-03 CRAN (R 3.3.2)                   
##  knitr        1.15.1   2016-11-22 CRAN (R 3.3.3)                   
##  magrittr     1.5      2014-11-22 CRAN (R 3.3.2)                   
##  memoise      1.1.0    2017-04-21 CRAN (R 3.3.3)                   
##  pacman     * 0.4.1    2016-03-30 CRAN (R 3.3.3)                   
##  R6           2.2.0    2016-10-05 CRAN (R 3.3.2)                   
##  Rcpp         0.12.10  2017-03-19 CRAN (R 3.3.3)                   
##  rmarkdown    1.5      2017-04-26 CRAN (R 3.3.3)                   
##  rprojroot    1.2      2017-01-16 CRAN (R 3.3.3)                   
##  rvest      * 0.3.2    2016-06-17 CRAN (R 3.3.2)                   
##  selectr      0.3-1    2016-12-19 CRAN (R 3.3.2)                   
##  stringi      1.1.5    2017-04-07 CRAN (R 3.3.3)                   
##  stringr    * 1.2.0    2017-02-18 CRAN (R 3.3.2)                   
##  tibble       1.3.0    2017-04-01 CRAN (R 3.3.3)                   
##  withr        1.0.2    2016-06-20 CRAN (R 3.3.3)                   
##  XML          3.98-1.6 2017-03-30 CRAN (R 3.3.3)                   
##  xml2       * 1.1.1    2017-01-24 CRAN (R 3.3.2)                   
##  yaml         2.1.14   2016-11-12 CRAN (R 3.3.3)&lt;/code&gt;&lt;/pre&gt;
</description>
=======
      <description>O MODIS (MODerate resolution Imaging Spectroradiometer) faz parte de um programa da NASA para monitoramento da superfície terrestre. Os satélites Terra e Aqua fornecem informações muito interessantes para o setor agroflorestal e nos permite entender de maneira bastante eficaz a dinâmica do uso do solo e de crescimento das nossas culturas.
O MODOIS tem diversos produtos, mas neste post vamos tratar especificamente do produto MOD13Q1, que disponibiliza a cada 16 dias um raster de EVI e NDVI com resolução de 250 m.</description>
>>>>>>> master
    </item>
    
    <item>
      <title>Índice de uniformidade (PV50)</title>
      <link>/indice-de-uniformidade-pv50/</link>
      <pubDate>Sun, 09 Oct 2016 00:00:00 +0000</pubDate>
      
      <guid>/indice-de-uniformidade-pv50/</guid>
<<<<<<< HEAD
      <description>&lt;p&gt;O PV50 é hoje o índice mais utilizado quando queremos expressar a uniformidade de um plantio florestal. &lt;span class=&#34;citation&#34;&gt;Hakamada (&lt;a href=&#34;#ref-Hakamada2012&#34;&gt;2012&lt;/a&gt;)&lt;/span&gt; apresentou um estudo detalhado sobre diversos índices e concluiu que o PV50 é o índice mais indicado para explicar a relação entre uniformidade, qualidade silvicultural e produtividade em plantios homogêneos de &lt;em&gt;Eucalyptus&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;O objetivo deste post é mostrar, passo a passo, como calcular este índice no R e fazer uma breve análise de seus resultados.&lt;/p&gt;
&lt;p&gt;O PV50 é a porcentagem de volume acumulado das 50% menores árvores do seu conjunto de dados, considerando as falhas de plantio e árvores mortas &lt;span class=&#34;citation&#34;&gt;(Hakamada et al. &lt;a href=&#34;#ref-Hakamada2015&#34;&gt;2015&lt;/a&gt;)&lt;/span&gt;. A expressão do índice é dada da seguinte forma:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.sciweavers.org/tex2img.php?eq=PV50%20%3D%20%5Cfrac%7B%5Csum_%7Bk%3D1%7D%5E%7B%5Cfrac%7Bn%7D%7B2%7D%7DV_%7Bij%7D%7D%7B%5Csum_%7Bk%3D1%7D%5E%7Bn%7DV_%7Bij%7D%7D&amp;bc=White&amp;fc=Black&amp;im=jpg&amp;fs=12&amp;ff=arev&amp;edit=0&#34; align=&#34;center&#34; border=&#34;0&#34; alt=&#34;PV50 = \frac{\sum_{k=1}^{\frac{n}{2}}V_{ij}}{\sum_{k=1}^{n}V_{ij}}&#34; width=&#34;139&#34; height=&#34;62&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Onde: PV50 = porcentagem acumulada do volume das 50% menores árvores plantadas; V = volume da árvore i; n = número de árvores plantadas ordenadas (da menor para a maior).&lt;/p&gt;
&lt;p&gt;Primeiro vamos entender os cálculos do índice, considerando apenas 10 árvores hipotéticas com 0,1 metros cúbicos de volume.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# carrega os pacotes necessários
if (!require(&amp;quot;pacman&amp;quot;)) install.packages(&amp;quot;pacman&amp;quot;)
pacman::p_load(readr, dplyr, ggplot2, forcats)&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# exemplo com número par
arv10 &amp;lt;- rep(0.1, 10)
str(arv10)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  num [1:10] 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Este é o referencial teórico de uniformidade, todas as árvores do mesmo tamanho. Sem precisar fazer conta, sabemos que o volume das 50% menores árvores é igual a 50% do volume total, o que equivale a um PV50 = 50.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# identifica a metade do numero de árvores
metade &amp;lt;- length(arv10)/2
metade&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 5&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# soma todas as árvores
soma_todas &amp;lt;- sum(arv10, na.rm = TRUE)
soma_todas&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 1&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# soma o valor de metade das árvores em ordem crescente
soma_metade &amp;lt;- sum(sort(arv10)[1:metade], na.rm = TRUE)
soma_metade&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 0.5&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# calcula o PV50
PV50 &amp;lt;- soma_metade / soma_todas * 100
PV50&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 50&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Agora vamos simular 11 árvores com o mesmo volume, veja o que acontece.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# exemplo com número impar
arv11 &amp;lt;- rep(0.1, 11)
str(arv11)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  num [1:11] 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 ...&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# metade do numero de árvores
metade &amp;lt;- length(arv11)/2
metade&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 5.5&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# soma todas as árvores
soma_todas &amp;lt;- sum(arv11, na.rm = TRUE)
soma_todas&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 1.1&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# soma o valor de metade das árvores em ordem crescente
soma_metade &amp;lt;- sum(sort(arv11)[1:metade], na.rm = TRUE)
soma_metade&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 0.5&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# calcula o PV50
PV50 &amp;lt;- soma_metade / soma_todas * 100
PV50&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 45.45455&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;O resultado deveria ser 50, mas como o número de árvores é impar, o R arredonda a posição 5,5 para 5 e pega até a quinta árvore no momento em que queremos somar as 50% menores. Para contornar isso, vamos calcular a soma das 50% menores árvores de uma forma diferente. Primeiro calculamos a soma acumulada e depois extraímos a média (semelhante ao modo de se calcular uma mediana).&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# vetor de soma acumulada
soma_acumulada &amp;lt;- cumsum(sort(arv11))
soma_acumulada&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  [1] 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0 1.1&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# soma a metade do vetor de soma acumulada
soma_metade &amp;lt;- mean(soma_acumulada[metade + 0L:1L], na.rm = TRUE)
soma_metade&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 0.55&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# calcula o PV50
PV50 &amp;lt;- soma_metade / soma_todas * 100
PV50&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 50&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Agora que a questão do número de árvores foi superada, podemos incluir árvores mortas, o que equivale a elementos do tipo &lt;code&gt;NA&lt;/code&gt; no R. Veja que o resultado não está consistente pois a &lt;code&gt;soma_acumulada&lt;/code&gt; ignorou as árvores mortas.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# exemplo com valores perdidos
arv11_na &amp;lt;- rep(0.1, 11)
arv11_na[c(3,4)] &amp;lt;- NA
str(arv11_na)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  num [1:11] 0.1 0.1 NA NA 0.1 0.1 0.1 0.1 0.1 0.1 ...&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# metade do numero de árvores
metade &amp;lt;- length(arv11_na)/2
metade&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 5.5&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# soma todas as árvores
soma_todas &amp;lt;- sum(arv11_na, na.rm = TRUE)
soma_todas&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 0.9&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# vetor de soma acumulada
soma_acumulada &amp;lt;- cumsum(sort(arv11_na))
soma_acumulada&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# soma a metade do vetor de soma acumulada
soma_metade &amp;lt;- mean(soma_acumulada[metade + 0L:1L], na.rm = TRUE)
soma_metade&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 0.55&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# calcula o PV50
PV50 &amp;lt;- soma_metade / soma_todas * 100
PV50&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 61.11111&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Para corrigir este o erro, temos de incluir manualmente as árvores mortas na sequência. Veja que agora o resultado está de acordo com o esperado.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# vetor de valores perdidos
mortas &amp;lt;- arv11_na[is.na(arv11_na)]
mortas&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] NA NA&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# metade do numero de árvores
metade &amp;lt;- length(arv11_na)/2
metade&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 5.5&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# soma todas as árvores
soma_todas &amp;lt;- sum(arv11_na, na.rm = TRUE)
soma_todas&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 0.9&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# vetor de soma acumulada com valores perdidos
soma_acumulada &amp;lt;- c(mortas, cumsum(sort(arv11_na)))
soma_acumulada&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  [1]  NA  NA 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# soma a metade do vetor de soma acumulada
soma_metade &amp;lt;- mean(soma_acumulada[metade + 0L:1L], na.rm = TRUE)
soma_metade&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 0.35&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# calcula o PV50
PV50 &amp;lt;- soma_metade / soma_todas * 100
PV50&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 38.88889&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Agora eu vou dar aquele passo mágico dos livros de matemática e física, em que o autor diz “é fácil notar que o resultado leva a …” e apresentar uma função que lida com as questões que mostramos acima e retorna o PV50 do nosso conjunto de dados de forma correta.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;pv50 &amp;lt;- function(x) {
  
  mortas &amp;lt;- x[is.na(x)]
  
  metade &amp;lt;- length(x)/2
  
  soma_todas &amp;lt;- sum(x, na.rm = TRUE)
  
  soma_acumulada &amp;lt;- c(mortas, cumsum(sort(x)))
  
  if (metade%%2L == 1L)
    soma_metade &amp;lt;- mean(soma_acumulada[metade], na.rm = TRUE)
  else
    soma_metade &amp;lt;- mean(soma_acumulada[metade + 0L:1L], na.rm = TRUE)
  
  z &amp;lt;- soma_metade / soma_todas * 100
  
  return(z)
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Podemos rapidamente verificar se os resultados estão consistentes fazendo alguns testes.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;a &amp;lt;- rep(10, 10)
str(a)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  num [1:10] 10 10 10 10 10 10 10 10 10 10&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;pv50(a) # Ok!&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 50&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;a1 &amp;lt;- rep(10 ,11)
str(a1)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  num [1:11] 10 10 10 10 10 10 10 10 10 10 ...&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;pv50(a1) # Ok!&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 50&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;b &amp;lt;- a
b[c(3, 7)] &amp;lt;- NA
str(b)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  num [1:10] 10 10 NA 10 10 10 NA 10 10 10&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;pv50(b) # Ok!&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 37.5&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;b1 &amp;lt;- a1
b1[c(3, 7)] &amp;lt;- NA
str(b1)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  num [1:11] 10 10 NA 10 10 10 NA 10 10 10 ...&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;pv50(b1) # Ok!&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 38.88889&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Boa, já temos uma função para calcular o PV50 e podemos aplicá-la em um conjunto de dados para podermos interpretar. Utilizaremos mais uma vez os dados do &lt;a href=&#34;www.projetotume.com&#34;&gt;Projeto TUME&lt;/a&gt;, referente ao &lt;a href=&#34;http://www.projetotume.com/tume134&#34;&gt;TUME 134&lt;/a&gt; plantado em Piracicaba-SP. O volume individual foi calculado arbitrariamente utilizando o fator de forma 0,5.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# importa o arquivo tume_55.csv
dados &amp;lt;- read_csv2(
  &amp;quot;https://github.com/italocegatta/italocegatta.github.io_source/raw/master/content/dados/tume_55.csv&amp;quot;
)

glimpse(dados)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Observations: 1,222
## Variables: 7
## $ Esp     &amp;lt;chr&amp;gt; &amp;quot;E_camaldulensis&amp;quot;, &amp;quot;E_camaldulensis&amp;quot;, &amp;quot;E_camaldulensis...
## $ I_meses &amp;lt;int&amp;gt; 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34...
## $ Parc_m2 &amp;lt;int&amp;gt; 288, 288, 288, 288, 288, 288, 288, 288, 288, 288, 288,...
## $ N_arv   &amp;lt;int&amp;gt; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16,...
## $ DAP_cm  &amp;lt;dbl&amp;gt; 5.411268, 12.254931, 3.978874, 6.429860, 9.676621, 5.6...
## $ H_m     &amp;lt;dbl&amp;gt; 7.651490, 11.424046, 5.909205, 8.572873, 10.498957, 7....
## $ Vol     &amp;lt;dbl&amp;gt; 0.008798406, 0.067375427, 0.003673747, 0.013918399, 0....&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Iremos calcular o PV50 e o volume por hectare para cada fator &lt;code&gt;Esp&lt;/code&gt; e &lt;code&gt;I_meses&lt;/code&gt; e em seguida ordenar as espécies pelo PV50.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# agrupa os dados em função de espécie e idade para 
# calcular o pv50 e o volume
dados_pv50 &amp;lt;- dados %&amp;gt;% 
  group_by(Esp, I_meses) %&amp;gt;% 
  summarise(
    Parc_m2 = mean( Parc_m2),
    PV50 = pv50(Vol),
    Vol_ha = sum(Vol, na.rm = TRUE) * (10000/Parc_m2)
  ) %&amp;gt;%
  ungroup() %&amp;gt;% 
  # ordena o fator de espécies de forma decrescente em função do pv50
  mutate(Esp = fct_reorder(Esp, -PV50))

dados_pv50&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 20 × 5
##                    Esp I_meses Parc_m2     PV50    Vol_ha
##                 &amp;lt;fctr&amp;gt;   &amp;lt;int&amp;gt;   &amp;lt;dbl&amp;gt;    &amp;lt;dbl&amp;gt;     &amp;lt;dbl&amp;gt;
## 1      E_camaldulensis      34     288 21.36325  47.50044
## 2      E_camaldulensis      46     288 14.26669  79.09417
## 3      E_camaldulensis      60     600 13.18344 110.06612
## 4      E_camaldulensis      85     288 12.70684 203.98374
## 5         E_citriodora      34     288 17.84086  46.56646
## 6         E_citriodora      46     288 16.43760  84.96252
## 7         E_citriodora      60     600 12.53474  97.00958
## 8         E_citriodora      85     288 12.73166 205.04360
## 9             E_dunnii      34     288 28.58694 103.36725
## 10            E_dunnii      46     288 29.21288 160.54057
## 11            E_dunnii      60     600 27.46026 198.47239
## 12            E_dunnii      85     288 26.39616 349.63571
## 13        E_paniculata      34     288 27.36895  46.43145
## 14        E_paniculata      46     288 24.13274  84.42312
## 15        E_paniculata      60     600 19.63065 114.81369
## 16        E_paniculata      85     288 18.21965 194.87958
## 17 E_urophylla_grandis      34     288 26.25100  85.67855
## 18 E_urophylla_grandis      46     288 24.20636 157.30295
## 19 E_urophylla_grandis      60     600 20.33734 217.30209
## 20 E_urophylla_grandis      85     288 17.89856 277.37748&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Para entendermos os dados, vamos primeiro ver o crescimento em volume de cada espécies em função do tempo (Figura &lt;a href=&#34;#fig:12-vol-idade&#34;&gt;1&lt;/a&gt;). Note que &lt;em&gt;E. dunnii&lt;/em&gt; e &lt;em&gt;E. urophylla&lt;/em&gt; x &lt;em&gt;E. grandis&lt;/em&gt; tinham crescimento muito parecido até os 60 meses de idade.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggplot(dados_pv50, aes(I_meses, Vol_ha, color = Esp)) +
  geom_point() +
  geom_line() +
  labs(
    color = &amp;quot;Espécies&amp;quot;,
    x = &amp;quot;Idade (meses)&amp;quot;,
    y = Volume~m^3~ha^-1
  ) +
  scale_color_brewer(palette = &amp;quot;Set1&amp;quot;) +
  theme_bw(base_size = 16) +
  theme(legend.justification = &amp;quot;top&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;figure&#34;&gt;&lt;span id=&#34;fig:12-vol-idade&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;/post/2016-10-09-indice-de-uniformidade-pv50_files/figure-html/12-vol-idade-1.png&#34; alt=&#34;Crescimento em volume por hectare em função da idade.&#34; width=&#34;4000&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figura  1: Crescimento em volume por hectare em função da idade.
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Agora podemos construir um gráfico que relaciona o PV50 e a idade (Figura &lt;a href=&#34;#fig:12-pv50-idade&#34;&gt;2&lt;/a&gt;). A interpretação do índice é simples, o PV50 representa a porcentagem em volume que as 50% menores árvores contribuem para o volume total. Em nossos dados, &lt;em&gt;E. dunnii&lt;/em&gt;, ao 85 meses de idade, tem um PV50 de aproximadamente 26. Isso quer dizer que aos 7 anos, as 50% menores árvores da parcela de &lt;em&gt;E. dunnii&lt;/em&gt; representam apenas 26% do volume total. Ou seja, 50% das árvores contribuem muito pouco para o volume total da parcela e isso tem um impacto direto na produtividade.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggplot(dados_pv50, aes(I_meses, PV50, color = Esp)) +
  geom_point() +
  geom_line() +
  labs(color = &amp;quot;Espécies&amp;quot;, x = &amp;quot;Idade (meses)&amp;quot;, y = &amp;quot;PV50&amp;quot;) +
  scale_color_brewer(palette = &amp;quot;Set1&amp;quot;) +
  scale_y_continuous(breaks = seq(10, 30, 2)) +
  theme_bw(base_size = 16) +
  theme(legend.justification = &amp;quot;top&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;figure&#34;&gt;&lt;span id=&#34;fig:12-pv50-idade&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;/post/2016-10-09-indice-de-uniformidade-pv50_files/figure-html/12-pv50-idade-1.png&#34; alt=&#34;Variação do PV50 por espécies em função da idade.&#34; width=&#34;4000&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figura  2: Variação do PV50 por espécies em função da idade.
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;A Figura &lt;a href=&#34;#fig:12-pv50-vol&#34;&gt;3&lt;/a&gt; mostra claramente a relação direta que há entre produção de madeira e a uniformidade ao longo do crescimento da floresta. Note também que na medida em que a idade avança, a uniformidade diminui, pois a dominância das árvores maiores sobre as menores fica cada vez mais forte.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggplot(dados_pv50, aes(Vol_ha, PV50)) +
  geom_point(aes(color = factor(I_meses))) +
  geom_smooth(method = &amp;quot;lm&amp;quot;, formula = y ~x, se = FALSE) +
  facet_wrap(~Esp, dir = &amp;quot;v&amp;quot;) +
  labs(color = &amp;quot;Idade (meses)&amp;quot;, x = Volume~m^3~ha^-1, y = &amp;quot;PV50&amp;quot;) +
  scale_color_brewer(palette = &amp;quot;Dark2&amp;quot;) +
  theme_bw(base_size = 16) +
  theme(legend.justification = &amp;quot;top&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;figure&#34;&gt;&lt;span id=&#34;fig:12-pv50-vol&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;/post/2016-10-09-indice-de-uniformidade-pv50_files/figure-html/12-pv50-vol-1.png&#34; alt=&#34;Relação entre o PV50 e volume por hectare em função da idade.&#34; width=&#34;4000&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figura  3: Relação entre o PV50 e volume por hectare em função da idade.
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Por fim, para colocar tudo em um só gráfico, podemos adicionar ao gráfico de crescimento em volume a informação do PV50 para evidenciar que as espécies mais produtivas tem PV50 elevado e que este índice consegue explicar muito bem essa relação (Figura &lt;a href=&#34;#fig:12-vol-pv50-idade&#34;&gt;4&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;Um comentário interessante é que dentre as espécies que estamos estudando, todas são de origem seminal, com exceção do &lt;em&gt;E. dunnii&lt;/em&gt;, que é um clone. Este fator explica sua produtividade e alta homogeneidade, principalmente frente ao hibrido de &lt;em&gt;E. urophylla&lt;/em&gt; x &lt;em&gt;E. grandis&lt;/em&gt;, que é seu concorrente direto. Quando estivermos analisando dados de plantios clonais, o PV50 vai expressar a qualidade silvicultural do plantio, uma vez que a base genética é a mesma em todas as plantas.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggplot(dados_pv50, aes(I_meses, Vol_ha, color = Esp)) +
  geom_point(aes(size = PV50), alpha = 0.4) +
  geom_line() +
  labs(
    color = &amp;quot;Espécies&amp;quot;,
    x = &amp;quot;Idade (meses)&amp;quot;,
    y = Volume~m^3~ha^-1
  ) +
  scale_color_brewer(palette = &amp;quot;Set1&amp;quot;) +
  theme_bw(base_size = 16) +
  theme(legend.justification = &amp;quot;top&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;figure&#34;&gt;&lt;span id=&#34;fig:12-vol-pv50-idade&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;/post/2016-10-09-indice-de-uniformidade-pv50_files/figure-html/12-vol-pv50-idade-1.png&#34; alt=&#34;Crescimento do volume em função da idade, com informação do PV50 no tamanho do ponto.&#34; width=&#34;4000&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figura  4: Crescimento do volume em função da idade, com informação do PV50 no tamanho do ponto.
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Caso tenha alguma dúvida ou sugestão sobre o post, fique à vontade para fazer um comentário ou me contactar por Email.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;devtools::session_info()&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  setting  value                       
##  version  R version 3.3.3 (2017-03-06)
##  system   x86_64, mingw32             
##  ui       RTerm                       
##  language (EN)                        
##  collate  Portuguese_Brazil.1252      
##  tz       America/Sao_Paulo           
##  date     2017-04-30                  
## 
##  package      * version date       source                           
##  assertthat     0.2.0   2017-04-11 CRAN (R 3.3.3)                   
##  backports      1.0.5   2017-01-18 CRAN (R 3.3.2)                   
##  blogdown       0.0.25  2017-03-23 Github (rstudio/blogdown@1c10d16)
##  bookdown       0.3.14  2017-03-23 Github (rstudio/bookdown@f427fdf)
##  colorspace     1.3-2   2016-12-14 CRAN (R 3.3.2)                   
##  curl           2.6     2017-04-27 CRAN (R 3.3.3)                   
##  DBI            0.6-1   2017-04-01 CRAN (R 3.3.3)                   
##  devtools       1.12.0  2016-06-24 CRAN (R 3.3.3)                   
##  digest         0.6.12  2017-01-27 CRAN (R 3.3.2)                   
##  dplyr        * 0.5.0   2016-06-24 CRAN (R 3.3.2)                   
##  evaluate       0.10    2016-10-11 CRAN (R 3.3.3)                   
##  forcats      * 0.2.0   2017-01-23 CRAN (R 3.3.2)                   
##  ggplot2      * 2.2.1   2016-12-30 CRAN (R 3.3.2)                   
##  gtable         0.2.0   2016-02-26 CRAN (R 3.3.2)                   
##  highr          0.6     2016-05-09 CRAN (R 3.3.3)                   
##  hms            0.3     2016-11-22 CRAN (R 3.3.2)                   
##  htmltools      0.3.6   2017-04-28 CRAN (R 3.3.3)                   
##  knitr          1.15.1  2016-11-22 CRAN (R 3.3.3)                   
##  labeling       0.3     2014-08-23 CRAN (R 3.3.2)                   
##  lazyeval       0.2.0   2016-06-12 CRAN (R 3.3.2)                   
##  magrittr       1.5     2014-11-22 CRAN (R 3.3.2)                   
##  memoise        1.1.0   2017-04-21 CRAN (R 3.3.3)                   
##  munsell        0.4.3   2016-02-13 CRAN (R 3.3.2)                   
##  pacman       * 0.4.1   2016-03-30 CRAN (R 3.3.3)                   
##  plyr           1.8.4   2016-06-08 CRAN (R 3.3.2)                   
##  R6             2.2.0   2016-10-05 CRAN (R 3.3.2)                   
##  RColorBrewer   1.1-2   2014-12-07 CRAN (R 3.3.2)                   
##  Rcpp           0.12.10 2017-03-19 CRAN (R 3.3.3)                   
##  readr        * 1.1.0   2017-03-22 CRAN (R 3.3.3)                   
##  rmarkdown      1.5     2017-04-26 CRAN (R 3.3.3)                   
##  rprojroot      1.2     2017-01-16 CRAN (R 3.3.3)                   
##  scales         0.4.1   2016-11-09 CRAN (R 3.3.2)                   
##  stringi        1.1.5   2017-04-07 CRAN (R 3.3.3)                   
##  stringr        1.2.0   2017-02-18 CRAN (R 3.3.2)                   
##  tibble         1.3.0   2017-04-01 CRAN (R 3.3.3)                   
##  withr          1.0.2   2016-06-20 CRAN (R 3.3.3)                   
##  yaml           2.1.14  2016-11-12 CRAN (R 3.3.3)&lt;/code&gt;&lt;/pre&gt;
&lt;div id=&#34;referencias&#34; class=&#34;section level1 unnumbered&#34;&gt;
&lt;h1&gt;Referências&lt;/h1&gt;
&lt;div id=&#34;refs&#34; class=&#34;references&#34;&gt;
&lt;div id=&#34;ref-Hakamada2012&#34;&gt;
&lt;p&gt;Hakamada, Rodrigo Eiji. 2012. “Uso do inventário florestal como ferramenta de monitoramento da qualidade silvicultura em povoamentos clonais de Eucalyptus.” PhD thesis, Piracicaba: Universidade de São Paulo; Biblioteca Digital de Teses e Dissertações da Universidade de São Paulo. doi:&lt;a href=&#34;https://doi.org/10.11606/D.11.2012.tde-05072012-100431&#34;&gt;10.11606/D.11.2012.tde-05072012-100431&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;ref-Hakamada2015&#34;&gt;
&lt;p&gt;Hakamada, Rodrigo Eiji, José Luiz Stape, Cristiane Camargo Zani de Lemos, Adriano Emanuel Amaral Almeida, and Luis Fernando Silva. 2015. “Uniformidade entre árvores durante uma rotação e sua relação com a produtividade em Eucalyptus clonais.” &lt;em&gt;CERNE&lt;/em&gt; 21 (3). Universidade Federal de Lavras: 465–72. doi:&lt;a href=&#34;https://doi.org/10.1590/01047760201521031716&#34;&gt;10.1590/01047760201521031716&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
=======
      <description>O PV50 é hoje o índice mais utilizado quando queremos expressar a uniformidade de um plantio florestal. Hakamada (2012) apresentou um estudo detalhado sobre diversos índices e concluiu que o PV50 é o índice mais indicado para explicar a relação entre uniformidade, qualidade silvicultural e produtividade em plantios homogêneos de Eucalyptus.
O objetivo deste post é mostrar, passo a passo, como calcular este índice no R e fazer uma breve análise de seus resultados.</description>
>>>>>>> master
    </item>
    
    <item>
      <title>ANOVA e teste de Tukey</title>
      <link>/anova-e-teste-de-tukey/</link>
      <pubDate>Thu, 08 Sep 2016 00:00:00 +0000</pubDate>
      
      <guid>/anova-e-teste-de-tukey/</guid>
      <description>Análise de variância (ANOVA) e testes de médias são métodos comuns em artigos científicos. Você com certeza já viu aquelas letrinhas indicando a diferença entre tratamentos em algum estudo publicado. Por mais que este método esteja entrando em desuso - há uma tendência em abandonar esse tipo de abordagem estatística - penso que ainda o veremos por muitos anos no meio científico.
Como contexto, temos um teste de 5 progênies de eucalipto e queremos avaliar se volume por hectare (nossa variável resposta), difere entre os tratamentos.</description>
    </item>
    
    <item>
      <title>Ajuste de um modelo linear para vários fatores</title>
      <link>/ajuste-de-um-modelo-linear-para-varios-fatores/</link>
      <pubDate>Sat, 27 Aug 2016 00:00:00 +0000</pubDate>
      
      <guid>/ajuste-de-um-modelo-linear-para-varios-fatores/</guid>
      <description>Ajustar um modelo linear ou não linear é algo relativamente simples no R. Mas em muitos casos precisamos ajustá-lo para vários fatores e dependendo da quantidade isso se torna uma tarefa chata. Se você, assim como eu, já precisou fazer isso no Excel, sabe o que é perder mais que uma tarde copiando e colando informações entres abas e planilhas.
Mas felizmente existe uma máxima muito interessante entre programadores que é:</description>
    </item>
    
    <item>
      <title>Análise de componentes principais</title>
      <link>/analise-de-componentes-principais/</link>
      <pubDate>Mon, 01 Aug 2016 00:00:00 +0000</pubDate>
      
      <guid>/analise-de-componentes-principais/</guid>
      <description>Quando temos dados multivariados, a análise de componentes principais (PCA) é um recurso muito interessante e relativamente simples, em termos de conceito teórico e interpretação prática. Para exemplificar, vamos trabalhar com os dados climáticos de algumas cidades brasileiras. Os dados climáticos foram compilados a partir de estações automáticas do INMET.
No R, temos a facilidade de poder fazer o cálculo dos componentes principais e logo em seguida poder apresentá-los em gráficos elegantes e de fácil entendimento.</description>
    </item>
    
    <item>
      <title>Os gráficos que explicam nossos dados (histograma)</title>
      <link>/os-graficos-que-explicam-nossos-dados-histograma/</link>
      <pubDate>Fri, 15 Jul 2016 00:00:00 +0000</pubDate>
      
      <guid>/os-graficos-que-explicam-nossos-dados-histograma/</guid>
      <description>Histogramas são usados para mostrar a frequência com que uma variável ocorre. Isto é muito interessante para mostrar qual a distribuição dos seus dados e podemos apresentar em forma de frequência absoluta, relativa, percentual e acumulada. Para exemplificar este tipo gráfico, vamos utilizar os dados de inventário de uma propriedade fictícia na Amazônia. Estes dados são meramente ilustrativos e não tem valor real. O objetivo aqui é apresentar algumas particularidades da construção de gráficos de barras no R e facilitar a vida de quem quer abandonar os gráficos do Excel.</description>
    </item>
    
    <item>
      <title>Os gráficos que explicam nossos dados (heatmap)</title>
      <link>/os-graficos-que-explicam-nossos-dados-heatmap/</link>
      <pubDate>Sat, 09 Jul 2016 00:00:00 +0000</pubDate>
      
      <guid>/os-graficos-que-explicam-nossos-dados-heatmap/</guid>
      <description>O heatmap é um gráfico muito útil para identificar padrões, principalmente quando temos muitas variáveis no gráfico. Essencialmente o heatmap necessita de 3 variáveis: uma variável resposta e duas outras variáveis para compor os eixos x e y. Não há restrição quanto ao tipo de variável, qualquer uma delas podem ser quantitativa ou qualitativa. Talvez esse seja o trunfo do heatmap, essa flexbilidade quanto a natureza das variáveis nos permite utilizá-lo em diversos momentos e substituir gráficos mais tradicionais quando eles não dão conta do recado.</description>
    </item>
    
    <item>
      <title>Os gráficos que explicam nossos dados (barras)</title>
      <link>/os-graficos-que-explicam-nossos-dados-barras/</link>
      <pubDate>Sat, 14 May 2016 00:00:00 +0000</pubDate>
      
      <guid>/os-graficos-que-explicam-nossos-dados-barras/</guid>
      <description>Este é o segundo post de uma série que estou fazendo sobre tipos de gráficos. Falamos um pouco sobre o boxplot e agora vamos ao gráfico de barras.
Gráficos de barras são muito úteis para podermos comparar fatores. Quando estão um ao lado do outro a comparação é feita rapidamente, já que as barras dão a noção de escala. Normalmente as barras informam um resumo (i. e. média, soma ou contagem), mas podemos ainda adicionar uma barra de erro ou desvio e deixar o gráfico mais detalhado.</description>
    </item>
    
    <item>
      <title>Os gráficos que explicam nossos dados (boxplot)</title>
      <link>/os-graficos-que-explicam-nossos-dados-boxplot/</link>
      <pubDate>Fri, 06 May 2016 00:00:00 +0000</pubDate>
      
      <guid>/os-graficos-que-explicam-nossos-dados-boxplot/</guid>
<<<<<<< HEAD
      <description>&lt;p&gt;Nossos dados merecem ser apresentados de forma clara, atraente e inspiradora. Não há nada mais frustrante que dar duro no campo para coletar os dados e depois apresentá-los numa simples tabela de resumos. Podemos e devemos fazer mais, certo?&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;Vou começar agora uma série de posts sobre tipos de gráficos. Como disse no primeiro post desse &lt;a href=&#34;https://italocegatta.github.io/sobre-esse-blog.html&#34;&gt;blog&lt;/a&gt;, minha intenção é documentar os scripts que escrevi durante a graduação, portanto os gráficos que vou apresentar se resumem aos que tive de fazer por conta de alguma demanda específica.&lt;/p&gt;
&lt;p&gt;Para iniciar, escolhi o gráfico boxplot. É um gráfico muito útil para entender a variabilidade das nossas observações. No boxplot temos 5 informações básicas: valor mínimo, primeiro quartil, mediana, terceiro quartil e valor máximo. Há ainda a notificação de &lt;em&gt;outliers&lt;/em&gt;, quando a observação é maior ou menor que 1,5 vezes a distância interquartílica.&lt;/p&gt;
&lt;p&gt;Vamos trabalhar com os dados que apresentei no post anterior sobre &lt;a href=&#34;https://italocegatta.github.io/o-conceito-tidy-data.html&#34;&gt;tidy data&lt;/a&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(pacman)
p_load(readr, dplyr, tidyr, ggplot2, ggthemes)&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;dados &amp;lt;- read_csv2(
  &amp;quot;https://raw.githubusercontent.com/italocegatta/italocegatta.github.io_source/master/content/dados/base_vespa.csv&amp;quot;
)

dados&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 2,100 × 5
##    Tratamento Individuo Coleta   Local Galhas
##         &amp;lt;chr&amp;gt;     &amp;lt;int&amp;gt;  &amp;lt;int&amp;gt;   &amp;lt;chr&amp;gt;  &amp;lt;int&amp;gt;
## 1   Actara d1         1      1 Peciolo      1
## 2   Actara d1         2      1 Peciolo     NA
## 3   Actara d1         3      1 Peciolo     NA
## 4   Actara d1         4      1 Peciolo     NA
## 5   Actara d1         5      1 Peciolo     NA
## 6   Actara d1         6      1 Peciolo     NA
## 7   Actara d1         7      1 Peciolo     NA
## 8   Actara d1         8      1 Peciolo     NA
## 9   Actara d1         9      1 Peciolo     NA
## 10  Actara d1        10      1 Peciolo     NA
## # ... with 2,090 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Primeiro vamos processar os dados da última medição (Coleta 5) para verificar o nº total de galhas de cada tratamento, desconsiderando o local da galha. Nesse caso estou considerando apenas as mudas que foram atacadas e tiveram o desenvolvimento de galhas.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# seleciona apenas as Coletas de numero 5, em seguida monta um fator de 
# agrupamento em função de Tratamento e Individuo. Aplica a soma de todas as
# observações (Galhas) de acordo com o fator de agrupamento. Troca os valores
# 0 (quando não há galhas) por NA.

total &amp;lt;- dados %&amp;gt;%
  filter(Coleta == 5) %&amp;gt;%
  group_by(Tratamento, Individuo) %&amp;gt;%
  summarise(Galhas = sum(Galhas, na.rm=T)) %&amp;gt;%
  mutate(Galhas = replace(Galhas, Galhas == 0, NA))

total&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Source: local data frame [140 x 3]
## Groups: Tratamento [7]
## 
##    Tratamento Individuo Galhas
##         &amp;lt;chr&amp;gt;     &amp;lt;int&amp;gt;  &amp;lt;int&amp;gt;
## 1   Actara d1         1     11
## 2   Actara d1         2     NA
## 3   Actara d1         3      4
## 4   Actara d1         4     NA
## 5   Actara d1         5     NA
## 6   Actara d1         6     NA
## 7   Actara d1         7     30
## 8   Actara d1         8     NA
## 9   Actara d1         9     NA
## 10  Actara d1        10     NA
## # ... with 130 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;O boxplot é um gráfico unidimensional, ou seja, precisamos de apenas uma variável para construí-lo. Entretanto, podemos usar variáveis categóricas para servir de agrupamento e replicar o gráfico para todos os níveis da variável. Por exemplo, no nosso banco de dados temos &lt;code&gt;Galhas&lt;/code&gt; como variável quantitativa e &lt;code&gt;Tratamento&lt;/code&gt;, &lt;code&gt;Coleta&lt;/code&gt; e &lt;code&gt;Local&lt;/code&gt; como variável qualitativa.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggplot(total, aes(&amp;quot;Total&amp;quot;, Galhas)) +
  geom_boxplot() +
  theme_few()&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;figure&#34;&gt;&lt;span id=&#34;fig:4-boxplot-total&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;/post/2016-05-06-os-graficos-que-explicam-nossos-dados-boxplot_files/figure-html/4-boxplot-total-1.png&#34; alt=&#34;Boxplot que mostra o nº de galhas de todos os tratamentos.&#34; width=&#34;4000&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figura  1: Boxplot que mostra o nº de galhas de todos os tratamentos.
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;A Figura &lt;a href=&#34;#fig:4-boxplot-total&#34;&gt;1&lt;/a&gt; dá uma visão geral de todas as observações em um único boxplot, mas não nos explica muita coisa. No caso da Figura &lt;a href=&#34;#fig:4-boxplot-trat&#34;&gt;2&lt;/a&gt;, &lt;code&gt;Tratamento&lt;/code&gt; tratamento é uma variável categórica e nos permite subdividir os boxplots para todos os níveis e assim podemos compará-los.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggplot(total, aes(Tratamento, Galhas)) +
  geom_boxplot() +
  theme_few()&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;figure&#34;&gt;&lt;span id=&#34;fig:4-boxplot-trat&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;/post/2016-05-06-os-graficos-que-explicam-nossos-dados-boxplot_files/figure-html/4-boxplot-trat-1.png&#34; alt=&#34;Boxplot que mostra o nº de galhas em função de cada tratamento.&#34; width=&#34;4000&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figura  2: Boxplot que mostra o nº de galhas em função de cada tratamento.
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Note que no tratamento &lt;em&gt;Actara d1&lt;/em&gt;, há um indivíduo discrepante (&lt;em&gt;outlier&lt;/em&gt;) que se destaca com 30 galhas. Note também a grande variabilidade entre os tratamentos, muito comum em experimentos envolvendo insetos. Normalmente o coeficiente de variação é extremamente alto e dificilmente há homogeneidade de variância. Um comentário interessante sobre o boxplot é que a caixa, valores entre o 1º e 3º quartil, corresponde a 50% das observações.&lt;/p&gt;
&lt;p&gt;Podemos também avaliar a variabilidade do nº de galhas por local. Para isso vamos incluir a variável &lt;code&gt;Local&lt;/code&gt; no agrupamento (Figura &lt;a href=&#34;#fig:4-boxplot-local&#34;&gt;3&lt;/a&gt;).&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# Adiciona mais um fator de agrupamento para o resumo. Nesse caso cada
# indivíduo terá o nº de galhas explicito em cada local.

local &amp;lt;- dados %&amp;gt;%
  filter(Coleta == 5) %&amp;gt;%
  group_by(Tratamento, Individuo, Local) %&amp;gt;%
  summarise(Galhas = sum(Galhas, na.rm=T)) %&amp;gt;%
  mutate(Galhas = replace(Galhas, Galhas == 0, NA))

local&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Source: local data frame [420 x 4]
## Groups: Tratamento, Individuo [140]
## 
##    Tratamento Individuo   Local Galhas
##         &amp;lt;chr&amp;gt;     &amp;lt;int&amp;gt;   &amp;lt;chr&amp;gt;  &amp;lt;int&amp;gt;
## 1   Actara d1         1   Caule      2
## 2   Actara d1         1 Nervura      3
## 3   Actara d1         1 Peciolo      6
## 4   Actara d1         2   Caule     NA
## 5   Actara d1         2 Nervura     NA
## 6   Actara d1         2 Peciolo     NA
## 7   Actara d1         3   Caule      1
## 8   Actara d1         3 Nervura      1
## 9   Actara d1         3 Peciolo      2
## 10  Actara d1         4   Caule     NA
## # ... with 410 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggplot(local, aes(Tratamento, Galhas, fill = Local)) +
  geom_boxplot() +
  theme_few() +
  scale_fill_brewer(palette = &amp;quot;Spectral&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;figure&#34;&gt;&lt;span id=&#34;fig:4-boxplot-local&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;/post/2016-05-06-os-graficos-que-explicam-nossos-dados-boxplot_files/figure-html/4-boxplot-local-1.png&#34; alt=&#34;Boxplot que mostra o nº de galhas por local e tratamento.&#34; width=&#34;4000&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figura  3: Boxplot que mostra o nº de galhas por local e tratamento.
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Uma outra perspectiva é avaliar a evolução do total de galhas por coleta. Para isto basta incluir a variável &lt;code&gt;Coleta&lt;/code&gt; no agrupamento (Figura &lt;a href=&#34;#fig:4-boxplot-coleta&#34;&gt;4&lt;/a&gt;). Para facilitar a visualização, vou excluir a primeira coleta. Podemos ainda adicionar os pontos que representam as observações para poder identificar quantas observações tem cada tratamento.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;total_coleta &amp;lt;- dados %&amp;gt;%
  filter(Coleta != 1 ) %&amp;gt;%
  group_by(Tratamento, Coleta, Individuo) %&amp;gt;%
  summarise(Galhas = sum(Galhas, na.rm=T)) %&amp;gt;%
  mutate(Galhas = replace(Galhas, Galhas == 0, NA))

total_coleta&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Source: local data frame [560 x 4]
## Groups: Tratamento, Coleta [28]
## 
##    Tratamento Coleta Individuo Galhas
##         &amp;lt;chr&amp;gt;  &amp;lt;int&amp;gt;     &amp;lt;int&amp;gt;  &amp;lt;int&amp;gt;
## 1   Actara d1      2         1      3
## 2   Actara d1      2         2     NA
## 3   Actara d1      2         3     NA
## 4   Actara d1      2         4     NA
## 5   Actara d1      2         5     NA
## 6   Actara d1      2         6     NA
## 7   Actara d1      2         7      2
## 8   Actara d1      2         8     NA
## 9   Actara d1      2         9     NA
## 10  Actara d1      2        10     NA
## # ... with 550 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggplot(total_coleta, aes(Tratamento, Galhas)) +
  geom_boxplot() +
  geom_jitter(alpha = 0.4) +
  facet_wrap(~ Coleta, labeller = label_both) +
  theme_few() +
  theme(axis.text.x = element_text(angle = 30, hjust = 0.5, vjust = 0.5))&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;figure&#34;&gt;&lt;span id=&#34;fig:4-boxplot-coleta&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;/post/2016-05-06-os-graficos-que-explicam-nossos-dados-boxplot_files/figure-html/4-boxplot-coleta-1.png&#34; alt=&#34;Boxplot que mostra a dispersão do total de galhas por tratamento  e coletas.&#34; width=&#34;4000&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figura  4: Boxplot que mostra a dispersão do total de galhas por tratamento e coletas.
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;É importante destacar que o gráfico da Figura &lt;a href=&#34;#fig:4-boxplot-coleta&#34;&gt;4&lt;/a&gt; não é adequado para esse tipo de informação. Nesse caso seria mais interessante um gráfico de linhas em que cada linha representa um tratamento (veremos esse gráfico em um futuro post).&lt;/p&gt;
&lt;p&gt;Caso tenha alguma dúvida ou sugestão sobre o post, fique à vontade para fazer um comentário ou me contactar por Email.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;devtools::session_info()&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  setting  value                       
##  version  R version 3.3.3 (2017-03-06)
##  system   x86_64, mingw32             
##  ui       RTerm                       
##  language (EN)                        
##  collate  Portuguese_Brazil.1252      
##  tz       America/Sao_Paulo           
##  date     2017-04-30                  
## 
##  package      * version date       source                           
##  assertthat     0.2.0   2017-04-11 CRAN (R 3.3.3)                   
##  backports      1.0.5   2017-01-18 CRAN (R 3.3.2)                   
##  blogdown       0.0.25  2017-03-23 Github (rstudio/blogdown@1c10d16)
##  bookdown       0.3.14  2017-03-23 Github (rstudio/bookdown@f427fdf)
##  colorspace     1.3-2   2016-12-14 CRAN (R 3.3.2)                   
##  curl           2.6     2017-04-27 CRAN (R 3.3.3)                   
##  DBI            0.6-1   2017-04-01 CRAN (R 3.3.3)                   
##  devtools       1.12.0  2016-06-24 CRAN (R 3.3.3)                   
##  digest         0.6.12  2017-01-27 CRAN (R 3.3.2)                   
##  dplyr        * 0.5.0   2016-06-24 CRAN (R 3.3.2)                   
##  evaluate       0.10    2016-10-11 CRAN (R 3.3.3)                   
##  ggplot2      * 2.2.1   2016-12-30 CRAN (R 3.3.2)                   
##  ggthemes     * 3.4.0   2017-02-19 CRAN (R 3.3.3)                   
##  gtable         0.2.0   2016-02-26 CRAN (R 3.3.2)                   
##  highr          0.6     2016-05-09 CRAN (R 3.3.3)                   
##  hms            0.3     2016-11-22 CRAN (R 3.3.2)                   
##  htmltools      0.3.6   2017-04-28 CRAN (R 3.3.3)                   
##  knitr          1.15.1  2016-11-22 CRAN (R 3.3.3)                   
##  labeling       0.3     2014-08-23 CRAN (R 3.3.2)                   
##  lazyeval       0.2.0   2016-06-12 CRAN (R 3.3.2)                   
##  magrittr       1.5     2014-11-22 CRAN (R 3.3.2)                   
##  memoise        1.1.0   2017-04-21 CRAN (R 3.3.3)                   
##  munsell        0.4.3   2016-02-13 CRAN (R 3.3.2)                   
##  pacman       * 0.4.1   2016-03-30 CRAN (R 3.3.3)                   
##  plyr           1.8.4   2016-06-08 CRAN (R 3.3.2)                   
##  R6             2.2.0   2016-10-05 CRAN (R 3.3.2)                   
##  RColorBrewer   1.1-2   2014-12-07 CRAN (R 3.3.2)                   
##  Rcpp           0.12.10 2017-03-19 CRAN (R 3.3.3)                   
##  readr        * 1.1.0   2017-03-22 CRAN (R 3.3.3)                   
##  rmarkdown      1.5     2017-04-26 CRAN (R 3.3.3)                   
##  rprojroot      1.2     2017-01-16 CRAN (R 3.3.3)                   
##  scales         0.4.1   2016-11-09 CRAN (R 3.3.2)                   
##  stringi        1.1.5   2017-04-07 CRAN (R 3.3.3)                   
##  stringr        1.2.0   2017-02-18 CRAN (R 3.3.2)                   
##  tibble         1.3.0   2017-04-01 CRAN (R 3.3.3)                   
##  tidyr        * 0.6.1   2017-01-10 CRAN (R 3.3.2)                   
##  withr          1.0.2   2016-06-20 CRAN (R 3.3.3)                   
##  yaml           2.1.14  2016-11-12 CRAN (R 3.3.3)&lt;/code&gt;&lt;/pre&gt;
</description>
=======
      <description>Nossos dados merecem ser apresentados de forma clara, atraente e inspiradora. Não há nada mais frustrante que dar duro no campo para coletar os dados e depois apresentá-los numa simples tabela de resumos. Podemos e devemos fazer mais, certo?
Vou começar agora uma série de posts sobre tipos de gráficos. Como disse no primeiro post desse blog, minha intenção é documentar os scripts que escrevi durante a graduação, portanto os gráficos que vou apresentar se resumem aos que tive de fazer por conta de alguma demanda específica.</description>
>>>>>>> master
    </item>
    
    <item>
      <title>O conceito tidy data</title>
      <link>/o-conceito-tidy-data/</link>
      <pubDate>Sat, 30 Apr 2016 00:00:00 +0000</pubDate>
      
      <guid>/o-conceito-tidy-data/</guid>
      <description>A ideia central desse post é bem simples: dados bem organizados valem a pena e economizam seu tempo!
Em minha primeira iniciação científica (quando comecei a trabalhar com o R), propus um experimento para avaliar a eficiência de 2 inseticidas para o controle de uma praga que ataca mudas de eucalipto (Cegatta and Villegas 2013). Eu estava no primeiro ano da faculdade, sabia muito pouco de Excel e nada de R.</description>
    </item>
    
  </channel>
</rss>