<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Ggplot2 on Ítalo Cegatta</title>
    <link>/tags/ggplot2/index.xml</link>
    <description>Recent content in Ggplot2 on Ítalo Cegatta</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>pt-br</language>
    <atom:link href="/tags/ggplot2/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Gráficos com dimensão espacial e temporal</title>
      <link>/graficos-com-dimensao-espacial-e-temporal/</link>
      <pubDate>Fri, 16 Jun 2017 00:00:00 +0000</pubDate>
      
      <guid>/graficos-com-dimensao-espacial-e-temporal/</guid>
      <description>&lt;p&gt;O post de hoje é sobre visualização de dados com dimensão espacial e temporal. Basicamente são gráficos que tem uma informação geográfica associada com informações que variam no tempo. Esse tipo de análise é comum no meu dia a dia e por isso resolvi deixar 3 alternativas resgistradas aqui. O contexto que iremos abordar está relacionado ao banco de dados de focos de incêndios registrados pelo INPE no &lt;a href=&#34;http://www.inpe.br/queimadas/situacao-atual&#34;&gt;Programa Queimadas Monitoramento por Satélites&lt;/a&gt;. O site é bem interessante e apresenta algumas estatísticas úteis sobre as queimadas na América do Sul e Brasil. Iremos trabalhar com a tabela que resume os focos de incêndios por ano e Estado brasileiro.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;if (!require(&amp;quot;pacman&amp;quot;)) install.packages(&amp;quot;pacman&amp;quot;)
pacman::p_load(readr, dplyr, sf, ggplot2, ggthemes, geofacet, gganimate, viridis, scales)
pacman::p_load_gh(&amp;quot;italocegatta/brmap&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;O primeiro passo foi copiar os dados da página e organizá-los no formato &lt;a href=&#34;https://italocegatta.github.io/o-conceito-tidy-data/&#34;&gt;tidy&lt;/a&gt;. Poderíamos fazer uma análise exploratória dos dados, mas quero manter o foco em algo bem pontual: como mostrar os dados brutos de uma só vez? Ou seja, considerando a dimensão de tempo (ano), geografia (localização do estado) e variável resposta (focos) na mesma janela gráfica, de que forma poderíamos apresentar os dados? .&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;focos &amp;lt;- read_csv2(&amp;quot;https://raw.githubusercontent.com/italocegatta/italocegatta.github.io_source/master/content/dados/base_incendios.csv&amp;quot;)

focos&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 162 x 3
##    sigla   ano focos
##    &amp;lt;chr&amp;gt; &amp;lt;int&amp;gt; &amp;lt;int&amp;gt;
##  1    AC  2011    13
##  2    AL  2011   127
##  3    AM  2011   159
##  4    AP  2011     5
##  5    BA  2011   883
##  6    CE  2011    44
##  7    DF  2011     8
##  8    ES  2011    55
##  9    GO  2011   492
## 10    MA  2011   656
## # ... with 152 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Vamos agora adicionar a referência espacial aos dados utilizando os polígonos do pacote &lt;a href=&#34;https://github.com/italocegatta/brmap&#34;&gt;brmap&lt;/a&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;estados_focos &amp;lt;-  focos %&amp;gt;% 
  left_join(brmap_estado, by = &amp;quot;sigla&amp;quot;)

estados_focos&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 162 x 6
##    sigla   ano focos cod_estado           estado          geometry
##    &amp;lt;chr&amp;gt; &amp;lt;int&amp;gt; &amp;lt;int&amp;gt;      &amp;lt;dbl&amp;gt;            &amp;lt;chr&amp;gt;  &amp;lt;simple_feature&amp;gt;
##  1    AC  2011    13         12             Acre &amp;lt;MULTIPOLYGON...&amp;gt;
##  2    AL  2011   127         27          Alagoas &amp;lt;MULTIPOLYGON...&amp;gt;
##  3    AM  2011   159         13         Amazonas &amp;lt;MULTIPOLYGON...&amp;gt;
##  4    AP  2011     5         16            Amapá &amp;lt;MULTIPOLYGON...&amp;gt;
##  5    BA  2011   883         29            Bahia &amp;lt;MULTIPOLYGON...&amp;gt;
##  6    CE  2011    44         23            Ceará &amp;lt;MULTIPOLYGON...&amp;gt;
##  7    DF  2011     8         53 Distrito Federal &amp;lt;MULTIPOLYGON...&amp;gt;
##  8    ES  2011    55         32   Espírito Santo &amp;lt;MULTIPOLYGON...&amp;gt;
##  9    GO  2011   492         52            Goiás &amp;lt;MULTIPOLYGON...&amp;gt;
## 10    MA  2011   656         21         Maranhão &amp;lt;MULTIPOLYGON...&amp;gt;
## # ... with 152 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A primeira abordagem vai utilizar o pacote &lt;a href=&#34;https://github.com/hafen/geofacet&#34;&gt;geofacet&lt;/a&gt;. Ele permite criarmos um grid de referência para orientar a função &lt;code&gt;facet_wrap&lt;/code&gt; de &lt;code&gt;ggplot2&lt;/code&gt;. O pacote já vem carregado com um grid do Brasil, o &lt;code&gt;br_grid1&lt;/code&gt;, mas você pode construir e utilizar seu próprio grid. Eu, particularmente, gosto desta representação pois é extramamente flexível e conporta uma infinidade de gráficos (linhas, pontos, barras…) e dimenções (color, shape, size…). O gráfico &lt;a href=&#34;#fig:focos-geofacet&#34;&gt;1&lt;/a&gt; está bem simples mas cumpre seu papel em facilitar a parcepção da variação anual e dar uma noção da região espacial do estado no Brasil.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggplot(estados_focos, aes(ano, focos)) +
  geom_line() +
  facet_geo(~estado, grid = br_grid1) +
  labs(
    x = &amp;quot;Ano&amp;quot;,
    y = &amp;quot;Nº de focos de incêndios&amp;quot;
  ) +
  scale_x_continuous(breaks = 2011:2017, labels = 11:17) +
  scale_y_continuous(label = unit_format(unit = &amp;quot;k&amp;quot;, scale = 1e-3)) +
  theme_few()&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;figure&#34;&gt;&lt;span id=&#34;fig:focos-geofacet&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;/post/2017-07-08-graficos-com-dimensao-espacial-e-temporal_files/figure-html/focos-geofacet-1.png&#34; alt=&#34;Representação em painel orientado utilizando linhas.&#34; width=&#34;4000&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figura  1: Representação em painel orientado utilizando linhas.
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;A segunda abordagem é relativamente simples e intuitiva. Construiremos um mapa temático utilizando o Nº de focos como escala de cor, mas organizado em um painel que tem como base o ano de regsitro. O gráfico &lt;a href=&#34;#fig:focos-facet&#34;&gt;2&lt;/a&gt; apela para a dimensão de cor e instantaneamente nos informa o estado mais crítico. Especificamente para esta análise ele este tipo de gráfico é muito apropriado.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggplot(estados_focos) +
  geom_sf(aes(fill = focos), color = NA) +
  facet_wrap(~ano) +
  labs(fill = &amp;quot;Nº de focos de incêndios&amp;quot;) +
  scale_fill_viridis(label = unit_format(unit = &amp;quot;k&amp;quot;, scale = 1e-3)) +
  theme_bw() +
  theme(legend.position = &amp;quot;bottom&amp;quot;, legend.justification = &amp;quot;right&amp;quot;) +
  guides(fill = guide_colorbar(barwidth = 15, title.position = &amp;quot;top&amp;quot;))&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;figure&#34;&gt;&lt;span id=&#34;fig:focos-facet&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;/post/2017-07-08-graficos-com-dimensao-espacial-e-temporal_files/figure-html/focos-facet-1.png&#34; alt=&#34;Representação em painel utilizando cores.&#34; width=&#34;4000&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figura  2: Representação em painel utilizando cores.
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;E por fim, nossa terceira tentativa vai unificar os paineis do gráfico &lt;a href=&#34;#fig:focos-facet&#34;&gt;2&lt;/a&gt; em um gif animado. A limitação do gráfico é que muitas vezes nossos gráficos vão para documentos estáticos como PDF e Word, inviabilizando o gif.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;(ggplot(estados_focos) +
  geom_sf(aes(fill = focos, frame = ano), color = NA) +
  ggtitle(&amp;quot;Ano:&amp;quot;) +
  labs(fill = &amp;quot;Nº de focos de incêndios&amp;quot;) +
  scale_fill_viridis(label = unit_format(unit = &amp;quot;k&amp;quot;, scale = 1e-3)) +
  theme_bw() +
  theme(legend.position = &amp;quot;bottom&amp;quot;, legend.justification = &amp;quot;right&amp;quot;) +
  guides(fill = guide_colorbar(barwidth = 15, title.position = &amp;quot;top&amp;quot;))
  ) %&amp;gt;% 
  gganimate()&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;a href=&#34;http://imgur.com/Vfkq7hW&#34;&gt;&lt;img src=&#34;http://i.imgur.com/Vfkq7hW.gif&#34; style=&#34;width:100%&#34; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Caso tenha alguma dúvida ou sugestão sobre o post, fique à vontade para fazer um comentário ou me contactar por Email.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;devtools::session_info()&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  setting  value                       
##  version  R version 3.3.3 (2017-03-06)
##  system   x86_64, mingw32             
##  ui       RTerm                       
##  language (EN)                        
##  collate  Portuguese_Brazil.1252      
##  tz       America/Sao_Paulo           
##  date     2017-07-08                  
## 
##  package     * version    date       source                            
##  animation     2.5        2017-03-30 CRAN (R 3.3.3)                    
##  assertthat    0.2.0      2017-04-11 CRAN (R 3.3.3)                    
##  backports     1.1.0      2017-05-22 CRAN (R 3.3.3)                    
##  base        * 3.3.3      2017-03-06 local                             
##  base64enc     0.1-3      2015-07-28 CRAN (R 3.3.2)                    
##  bindr         0.1        2016-11-13 CRAN (R 3.3.3)                    
##  bindrcpp      0.2        2017-06-17 CRAN (R 3.3.3)                    
##  blogdown      0.0.25     2017-03-23 Github (rstudio/blogdown@1c10d16) 
##  bookdown      0.4        2017-05-20 CRAN (R 3.3.3)                    
##  brmap       * 0.0.2      2017-07-07 local                             
##  colorspace    1.3-2      2016-12-14 CRAN (R 3.3.2)                    
##  curl          2.7        2017-06-26 CRAN (R 3.3.3)                    
##  datasets    * 3.3.3      2017-03-06 local                             
##  DBI           0.7        2017-06-18 CRAN (R 3.3.3)                    
##  devtools      1.13.2     2017-06-02 CRAN (R 3.3.3)                    
##  digest        0.6.12     2017-01-27 CRAN (R 3.3.2)                    
##  dplyr       * 0.7.1      2017-06-22 CRAN (R 3.3.3)                    
##  evaluate      0.10       2016-10-11 CRAN (R 3.3.3)                    
##  geofacet    * 0.1.4      2017-06-20 CRAN (R 3.3.3)                    
##  gganimate   * 0.1.0.9000 2017-05-24 Github (dgrtwo/gganimate@bf82002) 
##  ggplot2     * 2.2.1.9000 2017-06-16 Github (tidyverse/ggplot2@398fc07)
##  ggthemes    * 3.4.0      2017-02-19 CRAN (R 3.3.3)                    
##  glue          1.1.1      2017-06-21 CRAN (R 3.3.3)                    
##  graphics    * 3.3.3      2017-03-06 local                             
##  grDevices   * 3.3.3      2017-03-06 local                             
##  grid          3.3.3      2017-03-06 local                             
##  gridExtra     2.2.1      2016-02-29 CRAN (R 3.3.3)                    
##  gtable        0.2.0      2016-02-26 CRAN (R 3.3.2)                    
##  highr         0.6        2016-05-09 CRAN (R 3.3.3)                    
##  hms           0.3        2016-11-22 CRAN (R 3.3.2)                    
##  htmltools     0.3.6      2017-04-28 CRAN (R 3.3.3)                    
##  knitr         1.16       2017-05-18 CRAN (R 3.3.3)                    
##  labeling      0.3        2014-08-23 CRAN (R 3.3.2)                    
##  lazyeval      0.2.0      2016-06-12 CRAN (R 3.3.2)                    
##  magrittr      1.5        2014-11-22 CRAN (R 3.3.2)                    
##  memoise       1.1.0      2017-04-21 CRAN (R 3.3.3)                    
##  methods       3.3.3      2017-03-06 local                             
##  munsell       0.4.3      2016-02-13 CRAN (R 3.3.2)                    
##  pacman      * 0.4.6      2017-05-14 CRAN (R 3.3.3)                    
##  pkgconfig     2.0.1      2017-03-21 CRAN (R 3.3.3)                    
##  plyr          1.8.4      2016-06-08 CRAN (R 3.3.2)                    
##  R6            2.2.2      2017-06-17 CRAN (R 3.3.3)                    
##  Rcpp          0.12.11    2017-05-22 CRAN (R 3.3.3)                    
##  readr       * 1.1.1      2017-05-16 CRAN (R 3.3.3)                    
##  rlang         0.1.1      2017-05-18 CRAN (R 3.3.3)                    
##  rmarkdown     1.6        2017-06-15 CRAN (R 3.3.3)                    
##  rprojroot     1.2        2017-01-16 CRAN (R 3.3.3)                    
##  scales      * 0.4.1      2016-11-09 CRAN (R 3.3.2)                    
##  sf          * 0.5-1      2017-06-23 CRAN (R 3.3.3)                    
##  stats       * 3.3.3      2017-03-06 local                             
##  stringi       1.1.5      2017-04-07 CRAN (R 3.3.3)                    
##  stringr       1.2.0      2017-02-18 CRAN (R 3.3.2)                    
##  tibble        1.3.3      2017-05-28 CRAN (R 3.3.3)                    
##  tools         3.3.3      2017-03-06 local                             
##  udunits2      0.13       2016-11-17 CRAN (R 3.3.2)                    
##  units         0.4-5      2017-06-15 CRAN (R 3.3.3)                    
##  utils       * 3.3.3      2017-03-06 local                             
##  viridis     * 0.4.0      2017-03-27 CRAN (R 3.3.3)                    
##  viridisLite * 0.2.0      2017-03-24 CRAN (R 3.3.3)                    
##  withr         1.0.2      2016-06-20 CRAN (R 3.3.3)                    
##  yaml          2.1.14     2016-11-12 CRAN (R 3.3.3)&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Web scraping: dados de páginas da internet na palma da sua mão</title>
      <link>/web-scraping-dados-de-paginas-da-internet-na-palma-da-sua-mao/</link>
      <pubDate>Fri, 16 Jun 2017 00:00:00 +0000</pubDate>
      
      <guid>/web-scraping-dados-de-paginas-da-internet-na-palma-da-sua-mao/</guid>
      <description>&lt;p&gt;Você já precisou copiar na mão uma informação de texto, valor ou tabela de uma pagina web? Pelo menos no meu trabalho isto é muito comum. Por mais que os dados estejam lá site, eles nunca estão disponíveis todos juntos e no formato que queremos, parece que sacanagem. Diante disto, o objetivo deste post é mostrar como podemos utilizar o R para coletar dados de uma página web e esquecer o famooooso &lt;em&gt;ctrl+c/ctrl+v&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Vamos exemplificar o post utilizando o site do IBGE para saber quantos metros cúbicos de lenha de eucalipto foram produzidos em 2015 em cada estado brasileiro. De cara, se os dados não estiverem numa tabela pronta, você já espera ter que entrar em 27 páginas diferentes para pegar esta informação.&lt;/p&gt;
&lt;p&gt;Nosso ponto de partida é a página &lt;a href=&#34;http://www.ibge.gov.br/estadosat/&#34;&gt;States@&lt;/a&gt; do IBGE, que reúne diversas informações na escala estadual. Acessando a página podemos ver o código html por trás (utilize a tecla F12) e assim entender como a página está estruturada. Como queremos entrar nos Estados, podemos ver na Figura &lt;a href=&#34;#fig:pg1&#34;&gt;1&lt;/a&gt; que essa informação está abaixo do &lt;code&gt;id=&amp;quot;menu&amp;quot;&lt;/code&gt;. Note que ao passarmos o mouse sobre a linha &lt;code&gt;&amp;lt;div id=&amp;quot;menu&amp;quot;&amp;gt;&lt;/code&gt; o navegador identifica na página a localização do elemento e ainda nos informa o id CSS de rastreio, no caso &lt;code&gt;div#menu&lt;/code&gt;.&lt;/p&gt;
&lt;div class=&#34;figure&#34;&gt;&lt;span id=&#34;fig:pg1&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;http://i.imgur.com/VjiEvCM.png&#34; alt=&#34;Página inicial do site.&#34;  /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figura  1: Página inicial do site.
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Então já podemos começar a programar e desenhar o acesso aos dados. No R, cada página web é um objeto que precisa ser salvo na memória. Então, cada página é importante para ter os dados ou por ser uma etapa para conseguir os dados. A página inicial (&lt;code&gt;pg_raiz&lt;/code&gt;) contém os links para as páginas dos Estados, por isso precisamos acessá-la.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;if (!require(&amp;quot;pacman&amp;quot;)) install.packages(&amp;quot;pacman&amp;quot;)
pacman::p_load(purrr, dplyr, tidyr, stringr, rvest, ggplot2, viridis, scales, sf)
pacman::p_load_gh(&amp;quot;italocegatta/brmap&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;url_raiz &amp;lt;- &amp;quot;http://www.ibge.gov.br/estadosat/&amp;quot;

pg_raiz &amp;lt;- read_html(url_raiz)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;No objeto &lt;code&gt;posfixo_estados&lt;/code&gt; temos a parte do link que leva até a página de cada estado. Para ter o link completo, é só juntar com o link da página raiz.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;posfixo_estados &amp;lt;- html_node(pg_raiz, &amp;quot;div#menu&amp;quot;) %&amp;gt;% 
  html_children() %&amp;gt;%
  html_node(&amp;quot;a&amp;quot;) %&amp;gt;% 
  html_attr(&amp;quot;href&amp;quot;)

posfixo_estados&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  [1] &amp;quot;perfil.php?sigla=ro&amp;quot; &amp;quot;perfil.php?sigla=ac&amp;quot; &amp;quot;perfil.php?sigla=am&amp;quot;
##  [4] &amp;quot;perfil.php?sigla=rr&amp;quot; &amp;quot;perfil.php?sigla=pa&amp;quot; &amp;quot;perfil.php?sigla=ap&amp;quot;
##  [7] &amp;quot;perfil.php?sigla=to&amp;quot; &amp;quot;perfil.php?sigla=ma&amp;quot; &amp;quot;perfil.php?sigla=pi&amp;quot;
## [10] &amp;quot;perfil.php?sigla=ce&amp;quot; &amp;quot;perfil.php?sigla=rn&amp;quot; &amp;quot;perfil.php?sigla=pb&amp;quot;
## [13] &amp;quot;perfil.php?sigla=pe&amp;quot; &amp;quot;perfil.php?sigla=al&amp;quot; &amp;quot;perfil.php?sigla=se&amp;quot;
## [16] &amp;quot;perfil.php?sigla=ba&amp;quot; &amp;quot;perfil.php?sigla=mg&amp;quot; &amp;quot;perfil.php?sigla=es&amp;quot;
## [19] &amp;quot;perfil.php?sigla=rj&amp;quot; &amp;quot;perfil.php?sigla=sp&amp;quot; &amp;quot;perfil.php?sigla=pr&amp;quot;
## [22] &amp;quot;perfil.php?sigla=sc&amp;quot; &amp;quot;perfil.php?sigla=rs&amp;quot; &amp;quot;perfil.php?sigla=ms&amp;quot;
## [25] &amp;quot;perfil.php?sigla=mt&amp;quot; &amp;quot;perfil.php?sigla=go&amp;quot; &amp;quot;perfil.php?sigla=df&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;url_estados &amp;lt;- paste0(url_raiz, posfixo_estados)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Vamos agora acessar às páginas de todos os Estados e armazenar no objeto &lt;code&gt;pg_estados&lt;/code&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;pg_estados &amp;lt;- map(url_estados, read_html)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Navegando pela página de um estado qualquer, identificamos que queremos a informação contida no link &lt;em&gt;Extração Vegetal e Silvicultura 2015&lt;/em&gt;. Nesse caso, precisamos mais uma vez dos links que leva a esta página (para cada estado). Também é possível, tanto pelo R quanto pelo navegador, ver que esse link está na posição 68 da lista/tablela nomeada como &lt;code&gt;table.temas&lt;/code&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;posfixo_lenha &amp;lt;- map(
  pg_estados,
  ~html_node(.x, &amp;quot;table.temas&amp;quot;) %&amp;gt;% 
    html_children() %&amp;gt;%
    &amp;#39;[&amp;#39;(68) %&amp;gt;%
    html_node(&amp;quot;a&amp;quot;) %&amp;gt;% 
    html_attr(&amp;quot;href&amp;quot;)
  ) %&amp;gt;% 
  flatten_chr()

posfixo_lenha&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  [1] &amp;quot;temas.php?sigla=ro&amp;amp;tema=extracaovegetal2015&amp;quot;
##  [2] &amp;quot;temas.php?sigla=ac&amp;amp;tema=extracaovegetal2015&amp;quot;
##  [3] &amp;quot;temas.php?sigla=am&amp;amp;tema=extracaovegetal2015&amp;quot;
##  [4] &amp;quot;temas.php?sigla=rr&amp;amp;tema=extracaovegetal2015&amp;quot;
##  [5] &amp;quot;temas.php?sigla=pa&amp;amp;tema=extracaovegetal2015&amp;quot;
##  [6] &amp;quot;temas.php?sigla=ap&amp;amp;tema=extracaovegetal2015&amp;quot;
##  [7] &amp;quot;temas.php?sigla=to&amp;amp;tema=extracaovegetal2015&amp;quot;
##  [8] &amp;quot;temas.php?sigla=ma&amp;amp;tema=extracaovegetal2015&amp;quot;
##  [9] &amp;quot;temas.php?sigla=pi&amp;amp;tema=extracaovegetal2015&amp;quot;
## [10] &amp;quot;temas.php?sigla=ce&amp;amp;tema=extracaovegetal2015&amp;quot;
## [11] &amp;quot;temas.php?sigla=rn&amp;amp;tema=extracaovegetal2015&amp;quot;
## [12] &amp;quot;temas.php?sigla=pb&amp;amp;tema=extracaovegetal2015&amp;quot;
## [13] &amp;quot;temas.php?sigla=pe&amp;amp;tema=extracaovegetal2015&amp;quot;
## [14] &amp;quot;temas.php?sigla=al&amp;amp;tema=extracaovegetal2015&amp;quot;
## [15] &amp;quot;temas.php?sigla=se&amp;amp;tema=extracaovegetal2015&amp;quot;
## [16] &amp;quot;temas.php?sigla=ba&amp;amp;tema=extracaovegetal2015&amp;quot;
## [17] &amp;quot;temas.php?sigla=mg&amp;amp;tema=extracaovegetal2015&amp;quot;
## [18] &amp;quot;temas.php?sigla=es&amp;amp;tema=extracaovegetal2015&amp;quot;
## [19] &amp;quot;temas.php?sigla=rj&amp;amp;tema=extracaovegetal2015&amp;quot;
## [20] &amp;quot;temas.php?sigla=sp&amp;amp;tema=extracaovegetal2015&amp;quot;
## [21] &amp;quot;temas.php?sigla=pr&amp;amp;tema=extracaovegetal2015&amp;quot;
## [22] &amp;quot;temas.php?sigla=sc&amp;amp;tema=extracaovegetal2015&amp;quot;
## [23] &amp;quot;temas.php?sigla=rs&amp;amp;tema=extracaovegetal2015&amp;quot;
## [24] &amp;quot;temas.php?sigla=ms&amp;amp;tema=extracaovegetal2015&amp;quot;
## [25] &amp;quot;temas.php?sigla=mt&amp;amp;tema=extracaovegetal2015&amp;quot;
## [26] &amp;quot;temas.php?sigla=go&amp;amp;tema=extracaovegetal2015&amp;quot;
## [27] &amp;quot;temas.php?sigla=df&amp;amp;tema=extracaovegetal2015&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Aqui, mais uma vez, será preciso juntar o &lt;em&gt;link&lt;/em&gt; específico de cada estado com a url da página raiz.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;url_lenha &amp;lt;- paste0(url_raiz, posfixo_lenha)

pg_lenha &amp;lt;- map(url_lenha, read_html)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Agora, vamos dar um passo para trás e listar o nome dos Estados na ordem que as páginas são acessadas para podemos utilizar mais à frente.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;lista_estados &amp;lt;- html_node(pg_raiz, &amp;quot;div#menu&amp;quot;) %&amp;gt;% 
  html_children() %&amp;gt;%
  html_node(&amp;quot;img&amp;quot;) %&amp;gt;%
  html_attr(&amp;quot;alt&amp;quot;)

lista_estados&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  [1] &amp;quot;Rondônia&amp;quot;            &amp;quot;Acre&amp;quot;                &amp;quot;Amazonas&amp;quot;           
##  [4] &amp;quot;Roraima&amp;quot;             &amp;quot;Pará&amp;quot;                &amp;quot;Amapá&amp;quot;              
##  [7] &amp;quot;Tocantins&amp;quot;           &amp;quot;Maranhão&amp;quot;            &amp;quot;Piauí&amp;quot;              
## [10] &amp;quot;Ceará&amp;quot;               &amp;quot;Rio Grande do Norte&amp;quot; &amp;quot;Paraíba&amp;quot;            
## [13] &amp;quot;Pernambuco&amp;quot;          &amp;quot;Alagoas&amp;quot;             &amp;quot;Sergipe&amp;quot;            
## [16] &amp;quot;Bahia&amp;quot;               &amp;quot;Minas Gerais&amp;quot;        &amp;quot;Espírito Santo&amp;quot;     
## [19] &amp;quot;Rio de Janeiro&amp;quot;      &amp;quot;São Paulo&amp;quot;           &amp;quot;Paraná&amp;quot;             
## [22] &amp;quot;Santa Catarina&amp;quot;      &amp;quot;Rio Grande do Sul&amp;quot;   &amp;quot;Mato Grosso do Sul&amp;quot; 
## [25] &amp;quot;Mato Grosso&amp;quot;         &amp;quot;Goiás&amp;quot;               &amp;quot;Distrito federal&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;O próximo passo é extrair a tabela de informação de cada estado e posteriormente filtrar a informação que é de nosso interesse. Note que é neste momento que a programação se diferencia das atividades manuais: caso seu interesse seja por lenha de pinus, por exemplo, basta alterar uma palavra no código abaixo e ser feliz com o resultado em poucos segundos. Claro que é um exemplo hipotético, dificilmente alguém vai precisar desse código específico, mas o ponto está na capacidade de escrever seu próprio código e não precisar fazer o trabalho manual.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;tabelas &amp;lt;- map(
  set_names(pg_lenha, lista_estados), 
  ~html_node(.x, &amp;quot;table#tabela_temas&amp;quot;) %&amp;gt;% 
  html_table() %&amp;gt;% 
  as_tibble() %&amp;gt;% 
  rename(produto = X1, valor = X2, unidade = X3)
  )

qnt &amp;lt;- map_df(
  tabelas, 
  ~filter(.x, str_detect(produto, c(&amp;quot;Lenha de eucalipto&amp;quot;, &amp;quot;quantidade&amp;quot;))) %&amp;gt;% 
  &amp;#39;[[&amp;#39;(&amp;quot;valor&amp;quot;) 
  ) %&amp;gt;%
  gather(estado, volume) %&amp;gt;% 
  mutate(volume = as.numeric(str_replace_all(volume, &amp;quot;\\.&amp;quot;, &amp;quot;&amp;quot;)))

qnt &lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 27 x 2
##       estado volume
##        &amp;lt;chr&amp;gt;  &amp;lt;dbl&amp;gt;
##  1  Rondônia    690
##  2      Acre     NA
##  3  Amazonas     NA
##  4   Roraima     NA
##  5      Pará     NA
##  6     Amapá     NA
##  7 Tocantins   2300
##  8  Maranhão 195428
##  9     Piauí 188724
## 10     Ceará     NA
## # ... with 17 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;De certa forma já resolvemos o problema, a quantidade de lenha de eucalipto produzida em cada estado no ano de 2015 já está em nossas mãos. Mas vamos dar um passo além e visualizar isso num mapa. O pacote &lt;a href=&#34;https://github.com/italocegatta/brmap&#34;&gt;brmap&lt;/a&gt; possui os polígonos dos Estados brasileiros no formato &lt;code&gt;sf&lt;/code&gt;, o novo pacote para manupulação de objetos espaciais no R.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;qnt_mapa &amp;lt;- left_join(brmap_estado, qnt)

ggplot(qnt_mapa) +
  geom_sf(aes(fill = volume)) +
  labs(
    title = &amp;quot;Lenha de eucalipto - quantidade produzida em 2015&amp;quot;,
    subtitle = &amp;quot;IBGE Estados - Extração Vegetal e Silvicultura 2015&amp;quot;
  ) +
  scale_fill_viridis(
    Lenha~de~eucalipto~(m^3), 
    na.value = &amp;quot;grey90&amp;quot;,
    labels = function(x) format(x, big.mark = &amp;quot;.&amp;quot;, decimal.mark = &amp;quot;,&amp;quot;, scientific = FALSE)
  ) +
  theme_bw() +
  theme(legend.position = &amp;quot;bottom&amp;quot;) +
  guides(fill = guide_colorbar(barwidth = 30, title.position = &amp;quot;top&amp;quot;))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2017-06-16-web-scraping-dados-de-paginas-da-internet-na-palma-da-sua-mao_files/figure-html/unnamed-chunk-9-1.png&#34; width=&#34;4000&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Caso tenha alguma dúvida ou sugestão sobre o post, fique à vontade para fazer um comentário ou me contactar por Email.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;devtools::session_info()&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  setting  value                       
##  version  R version 3.3.3 (2017-03-06)
##  system   x86_64, mingw32             
##  ui       RTerm                       
##  language (EN)                        
##  collate  Portuguese_Brazil.1252      
##  tz       America/Sao_Paulo           
##  date     2017-07-08                  
## 
##  package     * version    date       source                            
##  assertthat    0.2.0      2017-04-11 CRAN (R 3.3.3)                    
##  backports     1.1.0      2017-05-22 CRAN (R 3.3.3)                    
##  base        * 3.3.3      2017-03-06 local                             
##  bindr         0.1        2016-11-13 CRAN (R 3.3.3)                    
##  bindrcpp    * 0.2        2017-06-17 CRAN (R 3.3.3)                    
##  blogdown      0.0.25     2017-03-23 Github (rstudio/blogdown@1c10d16) 
##  bookdown      0.4        2017-05-20 CRAN (R 3.3.3)                    
##  brmap       * 0.0.2      2017-07-07 local                             
##  colorspace    1.3-2      2016-12-14 CRAN (R 3.3.2)                    
##  curl          2.7        2017-06-26 CRAN (R 3.3.3)                    
##  datasets    * 3.3.3      2017-03-06 local                             
##  DBI           0.7        2017-06-18 CRAN (R 3.3.3)                    
##  devtools      1.13.2     2017-06-02 CRAN (R 3.3.3)                    
##  digest        0.6.12     2017-01-27 CRAN (R 3.3.2)                    
##  dplyr       * 0.7.1      2017-06-22 CRAN (R 3.3.3)                    
##  evaluate      0.10       2016-10-11 CRAN (R 3.3.3)                    
##  ggplot2     * 2.2.1.9000 2017-06-16 Github (tidyverse/ggplot2@398fc07)
##  glue          1.1.1      2017-06-21 CRAN (R 3.3.3)                    
##  graphics    * 3.3.3      2017-03-06 local                             
##  grDevices   * 3.3.3      2017-03-06 local                             
##  grid          3.3.3      2017-03-06 local                             
##  gridExtra     2.2.1      2016-02-29 CRAN (R 3.3.3)                    
##  gtable        0.2.0      2016-02-26 CRAN (R 3.3.2)                    
##  highr         0.6        2016-05-09 CRAN (R 3.3.3)                    
##  htmltools     0.3.6      2017-04-28 CRAN (R 3.3.3)                    
##  httr          1.2.1      2016-07-03 CRAN (R 3.3.2)                    
##  knitr         1.16       2017-05-18 CRAN (R 3.3.3)                    
##  labeling      0.3        2014-08-23 CRAN (R 3.3.2)                    
##  lazyeval      0.2.0      2016-06-12 CRAN (R 3.3.2)                    
##  magrittr      1.5        2014-11-22 CRAN (R 3.3.2)                    
##  memoise       1.1.0      2017-04-21 CRAN (R 3.3.3)                    
##  methods       3.3.3      2017-03-06 local                             
##  munsell       0.4.3      2016-02-13 CRAN (R 3.3.2)                    
##  pacman      * 0.4.6      2017-05-14 CRAN (R 3.3.3)                    
##  pkgconfig     2.0.1      2017-03-21 CRAN (R 3.3.3)                    
##  plyr          1.8.4      2016-06-08 CRAN (R 3.3.2)                    
##  purrr       * 0.2.2.2    2017-05-11 CRAN (R 3.3.3)                    
##  R6            2.2.2      2017-06-17 CRAN (R 3.3.3)                    
##  Rcpp          0.12.11    2017-05-22 CRAN (R 3.3.3)                    
##  rlang         0.1.1      2017-05-18 CRAN (R 3.3.3)                    
##  rmarkdown     1.6        2017-06-15 CRAN (R 3.3.3)                    
##  rprojroot     1.2        2017-01-16 CRAN (R 3.3.3)                    
##  rvest       * 0.3.2      2016-06-17 CRAN (R 3.3.2)                    
##  scales      * 0.4.1      2016-11-09 CRAN (R 3.3.2)                    
##  selectr       0.3-1      2016-12-19 CRAN (R 3.3.2)                    
##  sf          * 0.5-1      2017-06-23 CRAN (R 3.3.3)                    
##  stats       * 3.3.3      2017-03-06 local                             
##  stringi       1.1.5      2017-04-07 CRAN (R 3.3.3)                    
##  stringr     * 1.2.0      2017-02-18 CRAN (R 3.3.2)                    
##  tibble        1.3.3      2017-05-28 CRAN (R 3.3.3)                    
##  tidyr       * 0.6.3      2017-05-15 CRAN (R 3.3.3)                    
##  tools         3.3.3      2017-03-06 local                             
##  udunits2      0.13       2016-11-17 CRAN (R 3.3.2)                    
##  units         0.4-5      2017-06-15 CRAN (R 3.3.3)                    
##  utils       * 3.3.3      2017-03-06 local                             
##  viridis     * 0.4.0      2017-03-27 CRAN (R 3.3.3)                    
##  viridisLite * 0.2.0      2017-03-24 CRAN (R 3.3.3)                    
##  withr         1.0.2      2016-06-20 CRAN (R 3.3.3)                    
##  XML           3.98-1.9   2017-06-19 CRAN (R 3.3.3)                    
##  xml2        * 1.1.1      2017-01-24 CRAN (R 3.3.2)                    
##  yaml          2.1.14     2016-11-12 CRAN (R 3.3.3)&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Índice de uniformidade (PV50)</title>
      <link>/indice-de-uniformidade-pv50/</link>
      <pubDate>Sun, 09 Oct 2016 00:00:00 +0000</pubDate>
      
      <guid>/indice-de-uniformidade-pv50/</guid>
      <description>&lt;p&gt;O PV50 é hoje o índice mais utilizado quando queremos expressar a uniformidade de um plantio florestal. &lt;span class=&#34;citation&#34;&gt;Hakamada (&lt;a href=&#34;#ref-Hakamada2012&#34;&gt;2012&lt;/a&gt;)&lt;/span&gt; apresentou um estudo detalhado sobre diversos índices e concluiu que o PV50 é o índice mais indicado para explicar a relação entre uniformidade, qualidade silvicultural e produtividade em plantios homogêneos de &lt;em&gt;Eucalyptus&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;O objetivo deste post é mostrar, passo a passo, como calcular este índice no R e fazer uma breve análise de seus resultados.&lt;/p&gt;
&lt;p&gt;O PV50 é a porcentagem de volume acumulado das 50% menores árvores do seu conjunto de dados, considerando as falhas de plantio e árvores mortas &lt;span class=&#34;citation&#34;&gt;(Hakamada et al. &lt;a href=&#34;#ref-Hakamada2015&#34;&gt;2015&lt;/a&gt;)&lt;/span&gt;. A expressão do índice é dada da seguinte forma:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.sciweavers.org/tex2img.php?eq=PV50%20%3D%20%5Cfrac%7B%5Csum_%7Bk%3D1%7D%5E%7B%5Cfrac%7Bn%7D%7B2%7D%7DV_%7Bij%7D%7D%7B%5Csum_%7Bk%3D1%7D%5E%7Bn%7DV_%7Bij%7D%7D&amp;bc=White&amp;fc=Black&amp;im=jpg&amp;fs=12&amp;ff=arev&amp;edit=0&#34; align=&#34;center&#34; border=&#34;0&#34; alt=&#34;PV50 = \frac{\sum_{k=1}^{\frac{n}{2}}V_{ij}}{\sum_{k=1}^{n}V_{ij}}&#34; width=&#34;139&#34; height=&#34;62&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Onde: PV50 = porcentagem acumulada do volume das 50% menores árvores plantadas; V = volume da árvore i; n = número de árvores plantadas ordenadas (da menor para a maior).&lt;/p&gt;
&lt;p&gt;Primeiro vamos entender os cálculos do índice, considerando apenas 10 árvores hipotéticas com 0,1 metros cúbicos de volume.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# carrega os pacotes necessários
if (!require(&amp;quot;pacman&amp;quot;)) install.packages(&amp;quot;pacman&amp;quot;)
pacman::p_load(readr, dplyr, ggplot2, forcats)&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# exemplo com número par
arv10 &amp;lt;- rep(0.1, 10)
str(arv10)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  num [1:10] 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Este é o referencial teórico de uniformidade, todas as árvores do mesmo tamanho. Sem precisar fazer conta, sabemos que o volume das 50% menores árvores é igual a 50% do volume total, o que equivale a um PV50 = 50.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# identifica a metade do numero de árvores
metade &amp;lt;- length(arv10)/2
metade&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 5&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# soma todas as árvores
soma_todas &amp;lt;- sum(arv10, na.rm = TRUE)
soma_todas&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 1&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# soma o valor de metade das árvores em ordem crescente
soma_metade &amp;lt;- sum(sort(arv10)[1:metade], na.rm = TRUE)
soma_metade&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 0.5&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# calcula o PV50
PV50 &amp;lt;- soma_metade / soma_todas * 100
PV50&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 50&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Agora vamos simular 11 árvores com o mesmo volume, veja o que acontece.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# exemplo com número impar
arv11 &amp;lt;- rep(0.1, 11)
str(arv11)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  num [1:11] 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 ...&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# metade do numero de árvores
metade &amp;lt;- length(arv11)/2
metade&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 5.5&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# soma todas as árvores
soma_todas &amp;lt;- sum(arv11, na.rm = TRUE)
soma_todas&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 1.1&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# soma o valor de metade das árvores em ordem crescente
soma_metade &amp;lt;- sum(sort(arv11)[1:metade], na.rm = TRUE)
soma_metade&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 0.5&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# calcula o PV50
PV50 &amp;lt;- soma_metade / soma_todas * 100
PV50&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 45.45455&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;O resultado deveria ser 50, mas como o número de árvores é impar, o R arredonda a posição 5,5 para 5 e pega até a quinta árvore no momento em que queremos somar as 50% menores. Para contornar isso, vamos calcular a soma das 50% menores árvores de uma forma diferente. Primeiro calculamos a soma acumulada e depois extraímos a média (semelhante ao modo de se calcular uma mediana).&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# vetor de soma acumulada
soma_acumulada &amp;lt;- cumsum(sort(arv11))
soma_acumulada&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  [1] 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0 1.1&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# soma a metade do vetor de soma acumulada
soma_metade &amp;lt;- mean(soma_acumulada[metade + 0L:1L], na.rm = TRUE)
soma_metade&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 0.55&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# calcula o PV50
PV50 &amp;lt;- soma_metade / soma_todas * 100
PV50&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 50&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Agora que a questão do número de árvores foi superada, podemos incluir árvores mortas, o que equivale a elementos do tipo &lt;code&gt;NA&lt;/code&gt; no R. Veja que o resultado não está consistente pois a &lt;code&gt;soma_acumulada&lt;/code&gt; ignorou as árvores mortas.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# exemplo com valores perdidos
arv11_na &amp;lt;- rep(0.1, 11)
arv11_na[c(3,4)] &amp;lt;- NA
str(arv11_na)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  num [1:11] 0.1 0.1 NA NA 0.1 0.1 0.1 0.1 0.1 0.1 ...&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# metade do numero de árvores
metade &amp;lt;- length(arv11_na)/2
metade&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 5.5&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# soma todas as árvores
soma_todas &amp;lt;- sum(arv11_na, na.rm = TRUE)
soma_todas&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 0.9&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# vetor de soma acumulada
soma_acumulada &amp;lt;- cumsum(sort(arv11_na))
soma_acumulada&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# soma a metade do vetor de soma acumulada
soma_metade &amp;lt;- mean(soma_acumulada[metade + 0L:1L], na.rm = TRUE)
soma_metade&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 0.55&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# calcula o PV50
PV50 &amp;lt;- soma_metade / soma_todas * 100
PV50&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 61.11111&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Para corrigir este o erro, temos de incluir manualmente as árvores mortas na sequência. Veja que agora o resultado está de acordo com o esperado.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# vetor de valores perdidos
mortas &amp;lt;- arv11_na[is.na(arv11_na)]
mortas&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] NA NA&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# metade do numero de árvores
metade &amp;lt;- length(arv11_na)/2
metade&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 5.5&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# soma todas as árvores
soma_todas &amp;lt;- sum(arv11_na, na.rm = TRUE)
soma_todas&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 0.9&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# vetor de soma acumulada com valores perdidos
soma_acumulada &amp;lt;- c(mortas, cumsum(sort(arv11_na)))
soma_acumulada&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  [1]  NA  NA 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# soma a metade do vetor de soma acumulada
soma_metade &amp;lt;- mean(soma_acumulada[metade + 0L:1L], na.rm = TRUE)
soma_metade&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 0.35&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# calcula o PV50
PV50 &amp;lt;- soma_metade / soma_todas * 100
PV50&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 38.88889&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Agora eu vou dar aquele passo mágico dos livros de matemática e física, em que o autor diz “é fácil notar que o resultado leva a …” e apresentar uma função que lida com as questões que mostramos acima e retorna o PV50 do nosso conjunto de dados de forma correta.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;pv50 &amp;lt;- function(x) {
  
  mortas &amp;lt;- x[is.na(x)]
  
  metade &amp;lt;- length(x)/2
  
  soma_todas &amp;lt;- sum(x, na.rm = TRUE)
  
  soma_acumulada &amp;lt;- c(mortas, cumsum(sort(x)))
  
  if (metade%%2L == 1L)
    soma_metade &amp;lt;- mean(soma_acumulada[metade], na.rm = TRUE)
  else
    soma_metade &amp;lt;- mean(soma_acumulada[metade + 0L:1L], na.rm = TRUE)
  
  z &amp;lt;- soma_metade / soma_todas * 100
  
  return(z)
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Podemos rapidamente verificar se os resultados estão consistentes fazendo alguns testes.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;a &amp;lt;- rep(10, 10)
str(a)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  num [1:10] 10 10 10 10 10 10 10 10 10 10&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;pv50(a) # Ok!&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 50&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;a1 &amp;lt;- rep(10 ,11)
str(a1)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  num [1:11] 10 10 10 10 10 10 10 10 10 10 ...&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;pv50(a1) # Ok!&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 50&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;b &amp;lt;- a
b[c(3, 7)] &amp;lt;- NA
str(b)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  num [1:10] 10 10 NA 10 10 10 NA 10 10 10&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;pv50(b) # Ok!&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 37.5&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;b1 &amp;lt;- a1
b1[c(3, 7)] &amp;lt;- NA
str(b1)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  num [1:11] 10 10 NA 10 10 10 NA 10 10 10 ...&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;pv50(b1) # Ok!&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 38.88889&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Boa, já temos uma função para calcular o PV50 e podemos aplicá-la em um conjunto de dados para podermos interpretar. Utilizaremos mais uma vez os dados do &lt;a href=&#34;www.projetotume.com&#34;&gt;Projeto TUME&lt;/a&gt;, referente ao &lt;a href=&#34;http://www.projetotume.com/tume134&#34;&gt;TUME 134&lt;/a&gt; plantado em Piracicaba-SP. O volume individual foi calculado arbitrariamente utilizando o fator de forma 0,5.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# importa o arquivo tume_55.csv
dados &amp;lt;- read_csv2(
  &amp;quot;https://github.com/italocegatta/italocegatta.github.io_source/raw/master/content/dados/tume_55.csv&amp;quot;
)

glimpse(dados)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Observations: 1,222
## Variables: 7
## $ Esp     &amp;lt;chr&amp;gt; &amp;quot;E_camaldulensis&amp;quot;, &amp;quot;E_camaldulensis&amp;quot;, &amp;quot;E_camaldulensis...
## $ I_meses &amp;lt;int&amp;gt; 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34...
## $ Parc_m2 &amp;lt;int&amp;gt; 288, 288, 288, 288, 288, 288, 288, 288, 288, 288, 288,...
## $ N_arv   &amp;lt;int&amp;gt; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16,...
## $ DAP_cm  &amp;lt;dbl&amp;gt; 5.411268, 12.254931, 3.978874, 6.429860, 9.676621, 5.6...
## $ H_m     &amp;lt;dbl&amp;gt; 7.651490, 11.424046, 5.909205, 8.572873, 10.498957, 7....
## $ Vol     &amp;lt;dbl&amp;gt; 0.008798406, 0.067375427, 0.003673747, 0.013918399, 0....&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Iremos calcular o PV50 e o volume por hectare para cada fator &lt;code&gt;Esp&lt;/code&gt; e &lt;code&gt;I_meses&lt;/code&gt; e em seguida ordenar as espécies pelo PV50.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# agrupa os dados em função de espécie e idade para 
# calcular o pv50 e o volume
dados_pv50 &amp;lt;- dados %&amp;gt;% 
  group_by(Esp, I_meses) %&amp;gt;% 
  summarise(
    Parc_m2 = mean( Parc_m2),
    PV50 = pv50(Vol),
    Vol_ha = sum(Vol, na.rm = TRUE) * (10000/Parc_m2)
  ) %&amp;gt;%
  ungroup() %&amp;gt;% 
  # ordena o fator de espécies de forma decrescente em função do pv50
  mutate(Esp = fct_reorder(Esp, -PV50))

dados_pv50&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 20 × 5
##                    Esp I_meses Parc_m2     PV50    Vol_ha
##                 &amp;lt;fctr&amp;gt;   &amp;lt;int&amp;gt;   &amp;lt;dbl&amp;gt;    &amp;lt;dbl&amp;gt;     &amp;lt;dbl&amp;gt;
## 1      E_camaldulensis      34     288 21.36325  47.50044
## 2      E_camaldulensis      46     288 14.26669  79.09417
## 3      E_camaldulensis      60     600 13.18344 110.06612
## 4      E_camaldulensis      85     288 12.70684 203.98374
## 5         E_citriodora      34     288 17.84086  46.56646
## 6         E_citriodora      46     288 16.43760  84.96252
## 7         E_citriodora      60     600 12.53474  97.00958
## 8         E_citriodora      85     288 12.73166 205.04360
## 9             E_dunnii      34     288 28.58694 103.36725
## 10            E_dunnii      46     288 29.21288 160.54057
## 11            E_dunnii      60     600 27.46026 198.47239
## 12            E_dunnii      85     288 26.39616 349.63571
## 13        E_paniculata      34     288 27.36895  46.43145
## 14        E_paniculata      46     288 24.13274  84.42312
## 15        E_paniculata      60     600 19.63065 114.81369
## 16        E_paniculata      85     288 18.21965 194.87958
## 17 E_urophylla_grandis      34     288 26.25100  85.67855
## 18 E_urophylla_grandis      46     288 24.20636 157.30295
## 19 E_urophylla_grandis      60     600 20.33734 217.30209
## 20 E_urophylla_grandis      85     288 17.89856 277.37748&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Para entendermos os dados, vamos primeiro ver o crescimento em volume de cada espécies em função do tempo (Figura &lt;a href=&#34;#fig:12-vol-idade&#34;&gt;1&lt;/a&gt;). Note que &lt;em&gt;E. dunnii&lt;/em&gt; e &lt;em&gt;E. urophylla&lt;/em&gt; x &lt;em&gt;E. grandis&lt;/em&gt; tinham crescimento muito parecido até os 60 meses de idade.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggplot(dados_pv50, aes(I_meses, Vol_ha, color = Esp)) +
  geom_point() +
  geom_line() +
  labs(
    color = &amp;quot;Espécies&amp;quot;,
    x = &amp;quot;Idade (meses)&amp;quot;,
    y = Volume~m^3~ha^-1
  ) +
  scale_color_brewer(palette = &amp;quot;Set1&amp;quot;) +
  theme_bw(base_size = 16) +
  theme(legend.justification = &amp;quot;top&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;figure&#34;&gt;&lt;span id=&#34;fig:12-vol-idade&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;/post/2016-10-09-indice-de-uniformidade-pv50_files/figure-html/12-vol-idade-1.png&#34; alt=&#34;Crescimento em volume por hectare em função da idade.&#34; width=&#34;4000&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figura  1: Crescimento em volume por hectare em função da idade.
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Agora podemos construir um gráfico que relaciona o PV50 e a idade (Figura &lt;a href=&#34;#fig:12-pv50-idade&#34;&gt;2&lt;/a&gt;). A interpretação do índice é simples, o PV50 representa a porcentagem em volume que as 50% menores árvores contribuem para o volume total. Em nossos dados, &lt;em&gt;E. dunnii&lt;/em&gt;, ao 85 meses de idade, tem um PV50 de aproximadamente 26. Isso quer dizer que aos 7 anos, as 50% menores árvores da parcela de &lt;em&gt;E. dunnii&lt;/em&gt; representam apenas 26% do volume total. Ou seja, 50% das árvores contribuem muito pouco para o volume total da parcela e isso tem um impacto direto na produtividade.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggplot(dados_pv50, aes(I_meses, PV50, color = Esp)) +
  geom_point() +
  geom_line() +
  labs(color = &amp;quot;Espécies&amp;quot;, x = &amp;quot;Idade (meses)&amp;quot;, y = &amp;quot;PV50&amp;quot;) +
  scale_color_brewer(palette = &amp;quot;Set1&amp;quot;) +
  scale_y_continuous(breaks = seq(10, 30, 2)) +
  theme_bw(base_size = 16) +
  theme(legend.justification = &amp;quot;top&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;figure&#34;&gt;&lt;span id=&#34;fig:12-pv50-idade&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;/post/2016-10-09-indice-de-uniformidade-pv50_files/figure-html/12-pv50-idade-1.png&#34; alt=&#34;Variação do PV50 por espécies em função da idade.&#34; width=&#34;4000&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figura  2: Variação do PV50 por espécies em função da idade.
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;A Figura &lt;a href=&#34;#fig:12-pv50-vol&#34;&gt;3&lt;/a&gt; mostra claramente a relação direta que há entre produção de madeira e a uniformidade ao longo do crescimento da floresta. Note também que na medida em que a idade avança, a uniformidade diminui, pois a dominância das árvores maiores sobre as menores fica cada vez mais forte.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggplot(dados_pv50, aes(Vol_ha, PV50)) +
  geom_point(aes(color = factor(I_meses))) +
  geom_smooth(method = &amp;quot;lm&amp;quot;, formula = y ~x, se = FALSE) +
  facet_wrap(~Esp, dir = &amp;quot;v&amp;quot;) +
  labs(color = &amp;quot;Idade (meses)&amp;quot;, x = Volume~m^3~ha^-1, y = &amp;quot;PV50&amp;quot;) +
  scale_color_brewer(palette = &amp;quot;Dark2&amp;quot;) +
  theme_bw(base_size = 16) +
  theme(legend.justification = &amp;quot;top&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;figure&#34;&gt;&lt;span id=&#34;fig:12-pv50-vol&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;/post/2016-10-09-indice-de-uniformidade-pv50_files/figure-html/12-pv50-vol-1.png&#34; alt=&#34;Relação entre o PV50 e volume por hectare em função da idade.&#34; width=&#34;4000&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figura  3: Relação entre o PV50 e volume por hectare em função da idade.
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Por fim, para colocar tudo em um só gráfico, podemos adicionar ao gráfico de crescimento em volume a informação do PV50 para evidenciar que as espécies mais produtivas tem PV50 elevado e que este índice consegue explicar muito bem essa relação (Figura &lt;a href=&#34;#fig:12-vol-pv50-idade&#34;&gt;4&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;Um comentário interessante é que dentre as espécies que estamos estudando, todas são de origem seminal, com exceção do &lt;em&gt;E. dunnii&lt;/em&gt;, que é um clone. Este fator explica sua produtividade e alta homogeneidade, principalmente frente ao hibrido de &lt;em&gt;E. urophylla&lt;/em&gt; x &lt;em&gt;E. grandis&lt;/em&gt;, que é seu concorrente direto. Quando estivermos analisando dados de plantios clonais, o PV50 vai expressar a qualidade silvicultural do plantio, uma vez que a base genética é a mesma em todas as plantas.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggplot(dados_pv50, aes(I_meses, Vol_ha, color = Esp)) +
  geom_point(aes(size = PV50), alpha = 0.4) +
  geom_line() +
  labs(
    color = &amp;quot;Espécies&amp;quot;,
    x = &amp;quot;Idade (meses)&amp;quot;,
    y = Volume~m^3~ha^-1
  ) +
  scale_color_brewer(palette = &amp;quot;Set1&amp;quot;) +
  theme_bw(base_size = 16) +
  theme(legend.justification = &amp;quot;top&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;figure&#34;&gt;&lt;span id=&#34;fig:12-vol-pv50-idade&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;/post/2016-10-09-indice-de-uniformidade-pv50_files/figure-html/12-vol-pv50-idade-1.png&#34; alt=&#34;Crescimento do volume em função da idade, com informação do PV50 no tamanho do ponto.&#34; width=&#34;4000&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figura  4: Crescimento do volume em função da idade, com informação do PV50 no tamanho do ponto.
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Caso tenha alguma dúvida ou sugestão sobre o post, fique à vontade para fazer um comentário ou me contactar por Email.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;devtools::session_info()&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  setting  value                       
##  version  R version 3.3.3 (2017-03-06)
##  system   x86_64, mingw32             
##  ui       RTerm                       
##  language (EN)                        
##  collate  Portuguese_Brazil.1252      
##  tz       America/Sao_Paulo           
##  date     2017-04-30                  
## 
##  package      * version date       source                           
##  assertthat     0.2.0   2017-04-11 CRAN (R 3.3.3)                   
##  backports      1.0.5   2017-01-18 CRAN (R 3.3.2)                   
##  blogdown       0.0.25  2017-03-23 Github (rstudio/blogdown@1c10d16)
##  bookdown       0.3.14  2017-03-23 Github (rstudio/bookdown@f427fdf)
##  colorspace     1.3-2   2016-12-14 CRAN (R 3.3.2)                   
##  curl           2.6     2017-04-27 CRAN (R 3.3.3)                   
##  DBI            0.6-1   2017-04-01 CRAN (R 3.3.3)                   
##  devtools       1.12.0  2016-06-24 CRAN (R 3.3.3)                   
##  digest         0.6.12  2017-01-27 CRAN (R 3.3.2)                   
##  dplyr        * 0.5.0   2016-06-24 CRAN (R 3.3.2)                   
##  evaluate       0.10    2016-10-11 CRAN (R 3.3.3)                   
##  forcats      * 0.2.0   2017-01-23 CRAN (R 3.3.2)                   
##  ggplot2      * 2.2.1   2016-12-30 CRAN (R 3.3.2)                   
##  gtable         0.2.0   2016-02-26 CRAN (R 3.3.2)                   
##  highr          0.6     2016-05-09 CRAN (R 3.3.3)                   
##  hms            0.3     2016-11-22 CRAN (R 3.3.2)                   
##  htmltools      0.3.6   2017-04-28 CRAN (R 3.3.3)                   
##  knitr          1.15.1  2016-11-22 CRAN (R 3.3.3)                   
##  labeling       0.3     2014-08-23 CRAN (R 3.3.2)                   
##  lazyeval       0.2.0   2016-06-12 CRAN (R 3.3.2)                   
##  magrittr       1.5     2014-11-22 CRAN (R 3.3.2)                   
##  memoise        1.1.0   2017-04-21 CRAN (R 3.3.3)                   
##  munsell        0.4.3   2016-02-13 CRAN (R 3.3.2)                   
##  pacman       * 0.4.1   2016-03-30 CRAN (R 3.3.3)                   
##  plyr           1.8.4   2016-06-08 CRAN (R 3.3.2)                   
##  R6             2.2.0   2016-10-05 CRAN (R 3.3.2)                   
##  RColorBrewer   1.1-2   2014-12-07 CRAN (R 3.3.2)                   
##  Rcpp           0.12.10 2017-03-19 CRAN (R 3.3.3)                   
##  readr        * 1.1.0   2017-03-22 CRAN (R 3.3.3)                   
##  rmarkdown      1.5     2017-04-26 CRAN (R 3.3.3)                   
##  rprojroot      1.2     2017-01-16 CRAN (R 3.3.3)                   
##  scales         0.4.1   2016-11-09 CRAN (R 3.3.2)                   
##  stringi        1.1.5   2017-04-07 CRAN (R 3.3.3)                   
##  stringr        1.2.0   2017-02-18 CRAN (R 3.3.2)                   
##  tibble         1.3.0   2017-04-01 CRAN (R 3.3.3)                   
##  withr          1.0.2   2016-06-20 CRAN (R 3.3.3)                   
##  yaml           2.1.14  2016-11-12 CRAN (R 3.3.3)&lt;/code&gt;&lt;/pre&gt;
&lt;div id=&#34;referencias&#34; class=&#34;section level1 unnumbered&#34;&gt;
&lt;h1&gt;Referências&lt;/h1&gt;
&lt;div id=&#34;refs&#34; class=&#34;references&#34;&gt;
&lt;div id=&#34;ref-Hakamada2012&#34;&gt;
&lt;p&gt;Hakamada, Rodrigo Eiji. 2012. “Uso do inventário florestal como ferramenta de monitoramento da qualidade silvicultura em povoamentos clonais de Eucalyptus.” PhD thesis, Piracicaba: Universidade de São Paulo; Biblioteca Digital de Teses e Dissertações da Universidade de São Paulo. doi:&lt;a href=&#34;https://doi.org/10.11606/D.11.2012.tde-05072012-100431&#34;&gt;10.11606/D.11.2012.tde-05072012-100431&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;ref-Hakamada2015&#34;&gt;
&lt;p&gt;Hakamada, Rodrigo Eiji, José Luiz Stape, Cristiane Camargo Zani de Lemos, Adriano Emanuel Amaral Almeida, and Luis Fernando Silva. 2015. “Uniformidade entre árvores durante uma rotação e sua relação com a produtividade em Eucalyptus clonais.” &lt;em&gt;CERNE&lt;/em&gt; 21 (3). Universidade Federal de Lavras: 465–72. doi:&lt;a href=&#34;https://doi.org/10.1590/01047760201521031716&#34;&gt;10.1590/01047760201521031716&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>ANOVA e teste de Tukey</title>
      <link>/anova-e-teste-de-tukey/</link>
      <pubDate>Thu, 08 Sep 2016 00:00:00 +0000</pubDate>
      
      <guid>/anova-e-teste-de-tukey/</guid>
      <description>&lt;p&gt;Análise de variância (ANOVA) e testes de médias são métodos comuns em artigos científicos. Você com certeza já viu aquelas letrinhas indicando a diferença entre tratamentos em algum estudo publicado. Por mais que este método esteja entrando em desuso - há uma tendência em abandonar esse tipo de abordagem estatística - penso que ainda o veremos por muitos anos no meio científico.&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;Como contexto, temos um teste de 5 progênies de eucalipto e queremos avaliar se volume por hectare (nossa variável resposta), difere entre os tratamentos.&lt;/p&gt;
&lt;p&gt;Pois bem, para percebermos a dimensão dos dados e qual a variabilidade de cada tratamento, vamos criar um boxplot (Figura &lt;a href=&#34;#fig:10-boxplot&#34;&gt;1&lt;/a&gt;). Caso você queira saber um pouco mais sobre este tipo de gráfico, veja o &lt;a href=&#34;https://italocegatta.github.io/os-graficos-que-explicam-nossos-dados-boxplot&#34;&gt;post sobre ele&lt;/a&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;if (!require(&amp;quot;pacman&amp;quot;)) install.packages(&amp;quot;pacman&amp;quot;)
pacman::p_load(readr, dplyr, ggplot2, ggthemes, car, agricolae)&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;dados &amp;lt;- read_csv2(
  &amp;quot;https://github.com/italocegatta/italocegatta.github.io_source/raw/master/content/dados/base_progenie.csv&amp;quot;
)

dados&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 30 × 3
##    repeticao progenie volume
##        &amp;lt;int&amp;gt;    &amp;lt;chr&amp;gt;  &amp;lt;int&amp;gt;
## 1          1        A    212
## 2          2        A    206
## 3          3        A    224
## 4          4        A    289
## 5          5        A    324
## 6          6        A    219
## 7          1        B    108
## 8          2        B    194
## 9          3        B    163
## 10         4        B    111
## # ... with 20 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggplot(dados, aes(progenie, volume)) +
  geom_boxplot() +
  theme_bw() +
  theme_few()&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;figure&#34;&gt;&lt;span id=&#34;fig:10-boxplot&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;/post/2016-09-08-anova-e-teste-de-tukey_files/figure-html/10-boxplot-1.png&#34; alt=&#34;Variabilidade do volume por hectare de cada tratamento.&#34; width=&#34;4000&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figura  1: Variabilidade do volume por hectare de cada tratamento.
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;A ANOVA é um método bastante consolidado no meio acadêmico. Basicamente, este método informa se existe um tratamento discrepante dentre os demais. Entretanto, ele exige que algumas premissas sejam atendidas, como: distribuição normal dos resíduos e homogeneidade de variância.&lt;/p&gt;
&lt;p&gt;Primeiro, vamos utilizar o teste de Levene para verificar se há homogeneidade de variância, ou homocedasticidade. Como o p-valor é maior que 5% não temos evidência significativa para rejeitar a hipótese nula de homogeneidade, ou seja, nossos dados tem homogeneidade de variância.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;leveneTest(volume ~ factor(progenie), data=dados)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Levene&amp;#39;s Test for Homogeneity of Variance (center = median)
##       Df F value  Pr(&amp;gt;F)  
## group  4  2.4677 0.07086 .
##       25                  
## ---
## Signif. codes:  0 &amp;#39;***&amp;#39; 0.001 &amp;#39;**&amp;#39; 0.01 &amp;#39;*&amp;#39; 0.05 &amp;#39;.&amp;#39; 0.1 &amp;#39; &amp;#39; 1&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;O segundo pressuposto é a normalidade dos resíduos. Utilizaremos o teste de Shapiro-Wilk cuja hipótese nula é a de que os dados seguem uma distribuição normal. Como o p-valor é superior ao limite de 5%, podemos aceitar a hipótese nula e considerar nossos dados normais.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;anova &amp;lt;-  aov(volume ~ progenie, data=dados)

shapiro.test(resid(anova))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 
##  Shapiro-Wilk normality test
## 
## data:  resid(anova)
## W = 0.96097, p-value = 0.3279&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Uma vez que os pressupostos foram atendidos, seguiremos para a ANOVA. Note que, caso os testes de Levene e Shapiro-Wilk resultassem em um p-valor significante, ou seja, menor que 5%, teríamos que utilizar outro método estatístico para analisar nossos dados. Nesse caso, uma alternativa é utilizar testes não-paramétricos, uma vez que eles não exigem os pressupostos que acabamos de testar.&lt;/p&gt;
&lt;p&gt;Nossa ANOVA resultou em um p-valor menor que 5%, portanto, temos evidências de que ao menos um tratamento se diferencia dos demais. Isso já é uma resposta, mas pouco acrescenta à nossa pesquisa pois queremos saber quem é este tratamento discrepante. Ou melhor, queremos poder comparar os tratamentos entre si e verificar quais são estatisticamente iguais ou diferentes.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;summary(anova)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##             Df Sum Sq Mean Sq F value   Pr(&amp;gt;F)    
## progenie     4  86726   21681    8.89 0.000131 ***
## Residuals   25  60974    2439                     
## ---
## Signif. codes:  0 &amp;#39;***&amp;#39; 0.001 &amp;#39;**&amp;#39; 0.01 &amp;#39;*&amp;#39; 0.05 &amp;#39;.&amp;#39; 0.1 &amp;#39; &amp;#39; 1&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Para esta abordagem existem alguns testes de médias e cada um tem uma particularidade, mas de longe o mais utilizado é o de Tukey.&lt;/p&gt;
&lt;p&gt;A interpretação do teste de Tukey é simples. Após determinarmos a diferença mínima significativa (ou Honest Significant Difference - HSD), podemos julgar se as médias são iguais ou não. Em termos práticos, esse valor nos dá uma margem de igualdade, pois se a diferença entre dois tratamentos for maior do que isso, os médias são diferentes.&lt;/p&gt;
&lt;p&gt;A análise começa sempre pela maior média, no nosso caso a progênie A (245, 66). Com uma continha rápida, a média do tratamento A menos a diferença mínima significativa &lt;code&gt;245,66 - 83,73 = 161,93&lt;/code&gt;, aceitaremos que um tratamento é igual ao A se a média dele for maior que 161,93. O tratamento subsequente (o segundo do ranking) é a progênie D e como sua média é maior que 161,93 podemos dizer que ela é estatisticamente igual a progênie A.&lt;/p&gt;
&lt;p&gt;As próximas comparações seguem a mesma lógica. Quando registramos que duas médias são iguais, nós as rotulamos com a mesma letra para facilitar a identificação. Veja no fim do output as letras evidenciando a igualdade entre os tratamentos.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;tukey &amp;lt;- HSD.test(anova, &amp;quot;progenie&amp;quot;)

tukey&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## $statistics
##       Mean       CV  MSerror      HSD
##   165.7667 29.79233 2438.953 83.73866
## 
## $parameters
##   Df ntr StudentizedRange alpha  test   name.t
##   25   5         4.153363  0.05 Tukey progenie
## 
## $means
##     volume      std r Min Max
## A 245.6667 48.78798 6 206 324
## B 159.6667 49.47996 6 108 236
## C  80.5000 15.60449 6  63 100
## D 190.1667 75.37484 6 100 267
## E 152.8333 37.96534 6 106 210
## 
## $comparison
## NULL
## 
## $groups
##   trt    means  M
## 1   A 245.6667  a
## 2   D 190.1667 ab
## 3   B 159.6667 bc
## 4   E 152.8333 bc
## 5   C  80.5000  c&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Para deixar mais visual ainda, podemos construir um gráfico de barras com a média de cada tratamento e adicionar a sua letra correspondente ao teste de Tukey (Figura &lt;a href=&#34;#fig:10-barras-tukey&#34;&gt;2&lt;/a&gt;).&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;tukey$groups %&amp;gt;% 
  ggplot(aes(reorder(trt, means, function(x) -mean(x)), means)) +
    geom_bar(stat = &amp;quot;identity&amp;quot;) +
    geom_text(aes(label = M), vjust = 1.8, size = 9, color = &amp;quot;white&amp;quot;) +
    labs(x = &amp;quot;Progênies&amp;quot;, y = &amp;quot;Médias&amp;quot;) +
    theme_few()&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;figure&#34;&gt;&lt;span id=&#34;fig:10-barras-tukey&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;/post/2016-09-08-anova-e-teste-de-tukey_files/figure-html/10-barras-tukey-1.png&#34; alt=&#34;Médias dos tratamentos. As letras indicam médias estatisticamente iguais pelo teste de Tukey a 5% de significância.&#34; width=&#34;4000&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figura  2: Médias dos tratamentos. As letras indicam médias estatisticamente iguais pelo teste de Tukey a 5% de significância.
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Caso tenha alguma dúvida ou sugestão sobre o post, fique à vontade para fazer um comentário ou me contactar por Email.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;devtools::session_info()&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  setting  value                       
##  version  R version 3.3.3 (2017-03-06)
##  system   x86_64, mingw32             
##  ui       RTerm                       
##  language (EN)                        
##  collate  Portuguese_Brazil.1252      
##  tz       America/Sao_Paulo           
##  date     2017-04-08                  
## 
##  package      * version date       source                           
##  agricolae    * 1.2-4   2016-06-12 CRAN (R 3.3.3)                   
##  AlgDesign      1.1-7.3 2014-10-15 CRAN (R 3.3.2)                   
##  assertthat     0.1     2013-12-06 CRAN (R 3.3.2)                   
##  backports      1.0.5   2017-01-18 CRAN (R 3.3.2)                   
##  blogdown       0.0.25  2017-03-23 Github (rstudio/blogdown@1c10d16)
##  bookdown       0.3.14  2017-03-23 Github (rstudio/bookdown@f427fdf)
##  boot           1.3-18  2016-02-23 CRAN (R 3.3.3)                   
##  car          * 2.1-4   2016-12-02 CRAN (R 3.3.3)                   
##  cluster        2.0.5   2016-10-08 CRAN (R 3.3.3)                   
##  coda           0.19-1  2016-12-08 CRAN (R 3.3.3)                   
##  colorspace     1.3-2   2016-12-14 CRAN (R 3.3.2)                   
##  combinat       0.0-8   2012-10-29 CRAN (R 3.3.2)                   
##  curl           2.3     2016-11-24 CRAN (R 3.3.2)                   
##  DBI            0.5-1   2016-09-10 CRAN (R 3.3.2)                   
##  deldir         0.1-12  2016-03-06 CRAN (R 3.3.2)                   
##  devtools       1.12.0  2016-06-24 CRAN (R 3.3.3)                   
##  digest         0.6.12  2017-01-27 CRAN (R 3.3.2)                   
##  dplyr        * 0.5.0   2016-06-24 CRAN (R 3.3.2)                   
##  evaluate       0.10    2016-10-11 CRAN (R 3.3.3)                   
##  expm           0.999-1 2017-02-02 CRAN (R 3.3.3)                   
##  gdata          2.17.0  2015-07-04 CRAN (R 3.3.2)                   
##  ggplot2      * 2.2.1   2016-12-30 CRAN (R 3.3.2)                   
##  ggthemes     * 3.4.0   2017-02-19 CRAN (R 3.3.3)                   
##  gmodels        2.16.2  2015-07-22 CRAN (R 3.3.3)                   
##  gtable         0.2.0   2016-02-26 CRAN (R 3.3.2)                   
##  gtools         3.5.0   2015-05-29 CRAN (R 3.3.2)                   
##  highr          0.6     2016-05-09 CRAN (R 3.3.3)                   
##  htmltools      0.3.5   2016-03-21 CRAN (R 3.3.3)                   
##  klaR           0.6-12  2014-08-06 CRAN (R 3.3.3)                   
##  knitr          1.15.1  2016-11-22 CRAN (R 3.3.3)                   
##  labeling       0.3     2014-08-23 CRAN (R 3.3.2)                   
##  lattice        0.20-34 2016-09-06 CRAN (R 3.3.3)                   
##  lazyeval       0.2.0   2016-06-12 CRAN (R 3.3.2)                   
##  LearnBayes     2.15    2014-05-29 CRAN (R 3.3.2)                   
##  lme4           1.1-12  2016-04-16 CRAN (R 3.3.3)                   
##  magrittr       1.5     2014-11-22 CRAN (R 3.3.2)                   
##  MASS           7.3-45  2016-04-21 CRAN (R 3.3.3)                   
##  Matrix         1.2-8   2017-01-20 CRAN (R 3.3.3)                   
##  MatrixModels   0.4-1   2015-08-22 CRAN (R 3.3.3)                   
##  memoise        1.0.0   2016-01-29 CRAN (R 3.3.3)                   
##  mgcv           1.8-17  2017-02-08 CRAN (R 3.3.3)                   
##  minqa          1.2.4   2014-10-09 CRAN (R 3.3.3)                   
##  munsell        0.4.3   2016-02-13 CRAN (R 3.3.2)                   
##  nlme           3.1-131 2017-02-06 CRAN (R 3.3.3)                   
##  nloptr         1.0.4   2014-08-04 CRAN (R 3.3.3)                   
##  nnet           7.3-12  2016-02-02 CRAN (R 3.3.3)                   
##  pacman       * 0.4.1   2016-03-30 CRAN (R 3.3.3)                   
##  pbkrtest       0.4-7   2017-03-15 CRAN (R 3.3.3)                   
##  plyr           1.8.4   2016-06-08 CRAN (R 3.3.2)                   
##  quantreg       5.29    2016-09-04 CRAN (R 3.3.3)                   
##  R6             2.2.0   2016-10-05 CRAN (R 3.3.2)                   
##  Rcpp           0.12.9  2017-01-14 CRAN (R 3.3.2)                   
##  readr        * 1.0.0   2016-08-03 CRAN (R 3.3.2)                   
##  rmarkdown      1.3     2016-12-21 CRAN (R 3.3.3)                   
##  rprojroot      1.2     2017-01-16 CRAN (R 3.3.3)                   
##  scales         0.4.1   2016-11-09 CRAN (R 3.3.2)                   
##  sp             1.2-4   2016-12-22 CRAN (R 3.3.3)                   
##  SparseM        1.76    2017-03-09 CRAN (R 3.3.3)                   
##  spdep          0.6-11  2017-02-23 CRAN (R 3.3.3)                   
##  stringi        1.1.2   2016-10-01 CRAN (R 3.3.2)                   
##  stringr        1.2.0   2017-02-18 CRAN (R 3.3.2)                   
##  tibble         1.2     2016-08-26 CRAN (R 3.3.2)                   
##  withr          1.0.2   2016-06-20 CRAN (R 3.3.3)                   
##  yaml           2.1.14  2016-11-12 CRAN (R 3.3.3)&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Ajuste de um modelo linear para vários fatores</title>
      <link>/ajuste-de-um-modelo-linear-para-varios-fatores/</link>
      <pubDate>Sat, 27 Aug 2016 00:00:00 +0000</pubDate>
      
      <guid>/ajuste-de-um-modelo-linear-para-varios-fatores/</guid>
      <description>&lt;p&gt;Ajustar um modelo linear ou não linear é algo relativamente simples no R. Mas em muitos casos precisamos ajustá-lo para vários fatores e dependendo da quantidade isso se torna uma tarefa chata. Se você, assim como eu, já precisou fazer isso no Excel, sabe o que é perder mais que uma tarde copiando e colando informações entres abas e planilhas.&lt;br /&gt;
&lt;!-- more --&gt;&lt;/p&gt;
&lt;p&gt;Mas felizmente existe uma máxima muito interessante entre programadores que é:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Don’t Repeat Yourself (DRY)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Depois que eu percebi o quanto a repetição humana gera erros, abracei totalmente o conceito DRY. Acreditem, vocês serão muito mais felizes e eficientes deixando o computador fazer as tarefas repetitivas e chatas.&lt;/p&gt;
&lt;p&gt;Para exemplificar, vamos fazer algo muito comum nas ciências florestais, que é predizer as alturas das árvores. Medir a altura da árvore é uma atividade laboriosa, e há muito tempo se sabe que a altura total das árvores possui alta correlação com o seu diâmetro.&lt;/p&gt;
&lt;p&gt;Utilizaremos mais uma vez os dados do &lt;a href=&#34;www.projetotume.com&#34;&gt;Projeto TUME&lt;/a&gt;, referente a medição de 24 meses do TUME 55 plantado no Mato Grosso do Sul.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;if (!require(&amp;quot;pacman&amp;quot;)) install.packages(&amp;quot;pacman&amp;quot;)
pacman::p_load(readr, dplyr, tidyr, broom, purrr, ggplot2)&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;dados &amp;lt;- read_csv2(
  &amp;quot;https://github.com/italocegatta/italocegatta.github.io_source/raw/master/content/dados/tume_55_24.csv&amp;quot;
)

dados&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 1,881 × 9
##    N_tume I_meses          Esp Parc_m2 N_arv DAP_cm   H_m   Cod  Cod2
##     &amp;lt;int&amp;gt;   &amp;lt;int&amp;gt;        &amp;lt;chr&amp;gt;   &amp;lt;dbl&amp;gt; &amp;lt;int&amp;gt;  &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;int&amp;gt; &amp;lt;int&amp;gt;
## 1      55      24 E_botryoides     600     1    4.1   6.5    NA    NA
## 2      55      24 E_botryoides     600     2    9.7   8.0    NA    NA
## 3      55      24 E_botryoides     600     3     NA    NA     5    NA
## 4      55      24 E_botryoides     600     4    7.6   7.5     2    NA
## 5      55      24 E_botryoides     600     5    3.8   5.0    NA    NA
## 6      55      24 E_botryoides     600     6     NA    NA     1    NA
## 7      55      24 E_botryoides     600     7   12.6   9.0     6    NA
## 8      55      24 E_botryoides     600     8     NA    NA     1    NA
## 9      55      24 E_botryoides     600     9    7.0   8.0    NA    NA
## 10     55      24 E_botryoides     600    10    7.5   7.5    NA    NA
## # ... with 1,871 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Nosso objetivo é simples: ajustar um modelo hipsométrico para cada espécie e em seguida predizer as alturas das árvores. A Figura &lt;a href=&#34;#fig:9-dap-h&#34;&gt;1&lt;/a&gt; mostra a relação que teríamos se fosse ajustado apenas um modelo para todas as espécies.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggplot(dados, aes(DAP_cm, H_m)) +
  geom_point(alpha=0.4) +
  geom_smooth(method=&amp;quot;lm&amp;quot;) +
  theme_bw()&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;figure&#34;&gt;&lt;span id=&#34;fig:9-dap-h&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;/post/2016-08-27-ajuste-de-um-modelo-linear-para-varios-fatores_files/figure-html/9-dap-h-1.png&#34; alt=&#34;Relação entre o diâmetro e a altura sem destinção de espécie.&#34; width=&#34;4000&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figura  1: Relação entre o diâmetro e a altura sem destinção de espécie.
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Mas na prática, a relação diâmetro-altura é diferente entre espécie, como pode ser notado na Figura &lt;a href=&#34;#fig:9-dap-h-spp&#34;&gt;2&lt;/a&gt;. Talvez fique mais evidente a diferença observando os coeficientes dos modelos que serão ajustados a seguir.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggplot(dados, aes(DAP_cm, H_m)) +
  geom_point(alpha=0.4) +
  geom_smooth(method=&amp;quot;lm&amp;quot;) +
  facet_wrap(~Esp) +
  theme_bw()&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;figure&#34;&gt;&lt;span id=&#34;fig:9-dap-h-spp&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;/post/2016-08-27-ajuste-de-um-modelo-linear-para-varios-fatores_files/figure-html/9-dap-h-spp-1.png&#34; alt=&#34;Relação entre o diâmetro e a altura por espécie.&#34; width=&#34;4000&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figura  2: Relação entre o diâmetro e a altura por espécie.
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;A primeira etapa é entender que um data.frame pode conter vários tipos de elementos, como números, caracteres, listas e também outros data.frames. Para isso utilizaremos a função &lt;code&gt;nest()&lt;/code&gt; do pacote &lt;code&gt;tidyr&lt;/code&gt; e aninharemos os dados em função das espécies.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;dados %&amp;gt;%
  group_by(Esp) %&amp;gt;% 
  nest()&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 24 × 2
##                        Esp              data
##                      &amp;lt;chr&amp;gt;            &amp;lt;list&amp;gt;
## 1             E_botryoides &amp;lt;tibble [80 × 8]&amp;gt;
## 2              E_brassiana &amp;lt;tibble [80 × 8]&amp;gt;
## 3          E_camaldulensis &amp;lt;tibble [80 × 8]&amp;gt;
## 4             E_citriodora &amp;lt;tibble [80 × 8]&amp;gt;
## 5              E_cloeziana &amp;lt;tibble [51 × 8]&amp;gt;
## 6       E_dunnii_urophylla &amp;lt;tibble [80 × 8]&amp;gt;
## 7                E_exserta &amp;lt;tibble [80 × 8]&amp;gt;
## 8             E_grandis_AT &amp;lt;tibble [80 × 8]&amp;gt;
## 9  E_grandis_camaldulensis &amp;lt;tibble [80 × 8]&amp;gt;
## 10            E_grandis_CH &amp;lt;tibble [80 × 8]&amp;gt;
## # ... with 14 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Agora podemos ajustar um modelo de regressão para cada espécie utilizando a função &lt;code&gt;map&lt;/code&gt;,do pacote &lt;code&gt;purrr&lt;/code&gt;. Podemos ainda extrair as informações desses modelos com as funções &lt;code&gt;glance&lt;/code&gt;, &lt;code&gt;tidy&lt;/code&gt; e &lt;code&gt;augment&lt;/code&gt;, do pacote &lt;code&gt;broom&lt;/code&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;dados_modl &amp;lt;- dados %&amp;gt;%
  group_by(Esp) %&amp;gt;% 
  nest() %&amp;gt;% 
  mutate(
    ajuste = data %&amp;gt;% map(~ lm(log(H_m) ~ I(1/DAP_cm), data = .)),
    resumo = map(ajuste, glance),
    coef = map(ajuste, tidy),
    resid = map(ajuste, augment)
  )

dados_modl&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 24 × 6
##                        Esp              data   ajuste
##                      &amp;lt;chr&amp;gt;            &amp;lt;list&amp;gt;   &amp;lt;list&amp;gt;
## 1             E_botryoides &amp;lt;tibble [80 × 8]&amp;gt; &amp;lt;S3: lm&amp;gt;
## 2              E_brassiana &amp;lt;tibble [80 × 8]&amp;gt; &amp;lt;S3: lm&amp;gt;
## 3          E_camaldulensis &amp;lt;tibble [80 × 8]&amp;gt; &amp;lt;S3: lm&amp;gt;
## 4             E_citriodora &amp;lt;tibble [80 × 8]&amp;gt; &amp;lt;S3: lm&amp;gt;
## 5              E_cloeziana &amp;lt;tibble [51 × 8]&amp;gt; &amp;lt;S3: lm&amp;gt;
## 6       E_dunnii_urophylla &amp;lt;tibble [80 × 8]&amp;gt; &amp;lt;S3: lm&amp;gt;
## 7                E_exserta &amp;lt;tibble [80 × 8]&amp;gt; &amp;lt;S3: lm&amp;gt;
## 8             E_grandis_AT &amp;lt;tibble [80 × 8]&amp;gt; &amp;lt;S3: lm&amp;gt;
## 9  E_grandis_camaldulensis &amp;lt;tibble [80 × 8]&amp;gt; &amp;lt;S3: lm&amp;gt;
## 10            E_grandis_CH &amp;lt;tibble [80 × 8]&amp;gt; &amp;lt;S3: lm&amp;gt;
## # ... with 14 more rows, and 3 more variables: resumo &amp;lt;list&amp;gt;, coef &amp;lt;list&amp;gt;,
## #   resid &amp;lt;list&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Da mesma forma que aninhamos os dados por espécie, podemos retorná-los para o formato original, mas agora mostrando apenas as informações que realmente interessam.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;dados_modl %&amp;gt;%
  select(Esp, resumo) %&amp;gt;% 
  unnest(resumo)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 24 × 12
##                        Esp r.squared adj.r.squared      sigma statistic
##                      &amp;lt;chr&amp;gt;     &amp;lt;dbl&amp;gt;         &amp;lt;dbl&amp;gt;      &amp;lt;dbl&amp;gt;     &amp;lt;dbl&amp;gt;
## 1             E_botryoides 0.7865503     0.7832152 0.13638082 235.83647
## 2              E_brassiana 0.7034805     0.6984547 0.16015749 139.97510
## 3          E_camaldulensis 0.7193692     0.7156767 0.12781229 194.81849
## 4             E_citriodora 0.6017939     0.5958506 0.10226763 101.25459
## 5              E_cloeziana 0.2595328     0.2339995 0.16724765  10.16446
## 6       E_dunnii_urophylla 0.7199293     0.7159283 0.16115569 179.93693
## 7                E_exserta 0.5897407     0.5837949 0.19572456  99.18630
## 8             E_grandis_AT 0.7472094     0.7438832 0.07718312 224.64407
## 9  E_grandis_camaldulensis 0.8290924     0.8265415 0.16085772 325.02460
## 10            E_grandis_CH 0.7764890     0.7731530 0.10465726 232.76148
## # ... with 14 more rows, and 7 more variables: p.value &amp;lt;dbl&amp;gt;, df &amp;lt;int&amp;gt;,
## #   logLik &amp;lt;dbl&amp;gt;, AIC &amp;lt;dbl&amp;gt;, BIC &amp;lt;dbl&amp;gt;, deviance &amp;lt;dbl&amp;gt;, df.residual &amp;lt;int&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;dados_modl %&amp;gt;%
  select(Esp, coef ) %&amp;gt;% 
  unnest(coef)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 48 × 6
##                Esp        term  estimate  std.error  statistic
##              &amp;lt;chr&amp;gt;       &amp;lt;chr&amp;gt;     &amp;lt;dbl&amp;gt;      &amp;lt;dbl&amp;gt;      &amp;lt;dbl&amp;gt;
## 1     E_botryoides (Intercept)  2.633365 0.04223569  62.349272
## 2     E_botryoides I(1/DAP_cm) -4.129688 0.26891300 -15.356968
## 3      E_brassiana (Intercept)  2.014323 0.05110864  39.412563
## 4      E_brassiana I(1/DAP_cm) -2.373711 0.20063302 -11.831107
## 5  E_camaldulensis (Intercept)  2.727702 0.04605191  59.231027
## 6  E_camaldulensis I(1/DAP_cm) -4.792441 0.34335365 -13.957740
## 7     E_citriodora (Intercept)  2.553408 0.05513037  46.315809
## 8     E_citriodora I(1/DAP_cm) -3.802655 0.37790230 -10.062534
## 9      E_cloeziana (Intercept)  2.323552 0.11578912  20.067098
## 10     E_cloeziana I(1/DAP_cm) -2.842311 0.89151651  -3.188176
## # ... with 38 more rows, and 1 more variables: p.value &amp;lt;dbl&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;dados_modl %&amp;gt;%
  select(Esp, resid) %&amp;gt;% 
  unnest(resid)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 1,633 × 11
##             Esp .rownames log.H_m. I.1.DAP_cm.  .fitted    .se.fit
##           &amp;lt;chr&amp;gt;     &amp;lt;chr&amp;gt;    &amp;lt;dbl&amp;gt;       &amp;lt;dbl&amp;gt;    &amp;lt;dbl&amp;gt;      &amp;lt;dbl&amp;gt;
## 1  E_botryoides         1 1.871802  0.24390244 1.626124 0.03165108
## 2  E_botryoides         2 2.079442  0.10309278 2.207624 0.02008843
## 3  E_botryoides         4 2.014903  0.13157895 2.089985 0.01712280
## 4  E_botryoides         5 1.609438  0.26315789 1.546605 0.03614528
## 5  E_botryoides         7 2.197225  0.07936508 2.305612 0.02418794
## 6  E_botryoides         9 2.079442  0.14285714 2.043409 0.01679076
## 7  E_botryoides        10 2.014903  0.13333333 2.082740 0.01703615
## 8  E_botryoides        13 1.609438  0.16666667 1.945083 0.01784853
## 9  E_botryoides        14 2.302585  0.09803922 2.228493 0.02086574
## 10 E_botryoides        15 2.140066  0.12048193 2.135812 0.01795064
## # ... with 1,623 more rows, and 5 more variables: .resid &amp;lt;dbl&amp;gt;,
## #   .hat &amp;lt;dbl&amp;gt;, .sigma &amp;lt;dbl&amp;gt;, .cooksd &amp;lt;dbl&amp;gt;, .std.resid &amp;lt;dbl&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Após o ajuste do modelo, temos de predizer as alturas. O único adendo para esse comando é que precisamos fazer em duas etapas, uma utilizando a função &lt;code&gt;predict&lt;/code&gt; e outra para trazer o valor predito para a escala natural, pois o modelo foi ajustado na escala logarítmica.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;dados_pred &amp;lt;- dados_modl %&amp;gt;% 
  mutate(
    hpred = map2(ajuste, data, predict),
    hpred = map(hpred, exp)
  ) %&amp;gt;%
  select(Esp, data, hpred)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Por fim, temos de volta um data.frame com as alturas preditas. Por mais que o ajuste tenha ficado razoável, na prática a construção de modelos de relação hipsométrica envolvem outras etapas e um maior rigor em termos estatísticos.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;dados_compl &amp;lt;- dados_pred %&amp;gt;%
  unnest(hpred, data)

dados_compl&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 1,881 × 10
##             Esp     hpred N_tume I_meses Parc_m2 N_arv DAP_cm   H_m   Cod
##           &amp;lt;chr&amp;gt;     &amp;lt;dbl&amp;gt;  &amp;lt;int&amp;gt;   &amp;lt;int&amp;gt;   &amp;lt;dbl&amp;gt; &amp;lt;int&amp;gt;  &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;int&amp;gt;
## 1  E_botryoides  5.084129     55      24     600     1    4.1   6.5    NA
## 2  E_botryoides  9.094080     55      24     600     2    9.7   8.0    NA
## 3  E_botryoides        NA     55      24     600     3     NA    NA     5
## 4  E_botryoides  8.084791     55      24     600     4    7.6   7.5     2
## 5  E_botryoides  4.695500     55      24     600     5    3.8   5.0    NA
## 6  E_botryoides        NA     55      24     600     6     NA    NA     1
## 7  E_botryoides 10.030312     55      24     600     7   12.6   9.0     6
## 8  E_botryoides        NA     55      24     600     8     NA    NA     1
## 9  E_botryoides  7.716873     55      24     600     9    7.0   8.0    NA
## 10 E_botryoides  8.026428     55      24     600    10    7.5   7.5    NA
## # ... with 1,871 more rows, and 1 more variables: Cod2 &amp;lt;int&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Caso tenha alguma dúvida ou sugestão sobre o post, fique à vontade para fazer um comentário ou me contactar por Email.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;devtools::session_info()&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  setting  value                       
##  version  R version 3.3.3 (2017-03-06)
##  system   x86_64, mingw32             
##  ui       RTerm                       
##  language (EN)                        
##  collate  Portuguese_Brazil.1252      
##  tz       America/Sao_Paulo           
##  date     2017-04-08                  
## 
##  package    * version date       source                           
##  assertthat   0.1     2013-12-06 CRAN (R 3.3.2)                   
##  backports    1.0.5   2017-01-18 CRAN (R 3.3.2)                   
##  blogdown     0.0.25  2017-03-23 Github (rstudio/blogdown@1c10d16)
##  bookdown     0.3.14  2017-03-23 Github (rstudio/bookdown@f427fdf)
##  broom      * 0.4.2   2017-02-13 CRAN (R 3.3.2)                   
##  colorspace   1.3-2   2016-12-14 CRAN (R 3.3.2)                   
##  curl         2.3     2016-11-24 CRAN (R 3.3.2)                   
##  DBI          0.5-1   2016-09-10 CRAN (R 3.3.2)                   
##  devtools     1.12.0  2016-06-24 CRAN (R 3.3.3)                   
##  digest       0.6.12  2017-01-27 CRAN (R 3.3.2)                   
##  dplyr      * 0.5.0   2016-06-24 CRAN (R 3.3.2)                   
##  evaluate     0.10    2016-10-11 CRAN (R 3.3.3)                   
##  foreign      0.8-67  2016-09-13 CRAN (R 3.3.3)                   
##  ggplot2    * 2.2.1   2016-12-30 CRAN (R 3.3.2)                   
##  gtable       0.2.0   2016-02-26 CRAN (R 3.3.2)                   
##  highr        0.6     2016-05-09 CRAN (R 3.3.3)                   
##  htmltools    0.3.5   2016-03-21 CRAN (R 3.3.3)                   
##  knitr        1.15.1  2016-11-22 CRAN (R 3.3.3)                   
##  labeling     0.3     2014-08-23 CRAN (R 3.3.2)                   
##  lattice      0.20-34 2016-09-06 CRAN (R 3.3.3)                   
##  lazyeval     0.2.0   2016-06-12 CRAN (R 3.3.2)                   
##  magrittr     1.5     2014-11-22 CRAN (R 3.3.2)                   
##  memoise      1.0.0   2016-01-29 CRAN (R 3.3.3)                   
##  mnormt       1.5-5   2016-10-15 CRAN (R 3.3.2)                   
##  munsell      0.4.3   2016-02-13 CRAN (R 3.3.2)                   
##  nlme         3.1-131 2017-02-06 CRAN (R 3.3.3)                   
##  pacman     * 0.4.1   2016-03-30 CRAN (R 3.3.3)                   
##  plyr         1.8.4   2016-06-08 CRAN (R 3.3.2)                   
##  psych        1.6.12  2017-01-08 CRAN (R 3.3.2)                   
##  purrr      * 0.2.2   2016-06-18 CRAN (R 3.3.2)                   
##  R6           2.2.0   2016-10-05 CRAN (R 3.3.2)                   
##  Rcpp         0.12.9  2017-01-14 CRAN (R 3.3.2)                   
##  readr      * 1.0.0   2016-08-03 CRAN (R 3.3.2)                   
##  reshape2     1.4.2   2016-10-22 CRAN (R 3.3.2)                   
##  rmarkdown    1.3     2016-12-21 CRAN (R 3.3.3)                   
##  rprojroot    1.2     2017-01-16 CRAN (R 3.3.3)                   
##  scales       0.4.1   2016-11-09 CRAN (R 3.3.2)                   
##  stringi      1.1.2   2016-10-01 CRAN (R 3.3.2)                   
##  stringr      1.2.0   2017-02-18 CRAN (R 3.3.2)                   
##  tibble       1.2     2016-08-26 CRAN (R 3.3.2)                   
##  tidyr      * 0.6.1   2017-01-10 CRAN (R 3.3.2)                   
##  withr        1.0.2   2016-06-20 CRAN (R 3.3.3)                   
##  yaml         2.1.14  2016-11-12 CRAN (R 3.3.3)&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Análise de componentes principais</title>
      <link>/analise-de-componentes-principais/</link>
      <pubDate>Mon, 01 Aug 2016 00:00:00 +0000</pubDate>
      
      <guid>/analise-de-componentes-principais/</guid>
      <description>&lt;p&gt;Quando temos dados multivariados, a análise de componentes principais (PCA) é um recurso muito interessante e relativamente simples, em termos de conceito teórico e interpretação prática. Para exemplificar, vamos trabalhar com os dados climáticos de algumas cidades brasileiras. Os dados climáticos foram compilados a partir de estações automáticas do &lt;a href=&#34;http://www.inmet.gov.br/portal/index.php?r=estacoes/estacoesautomaticas&#34;&gt;INMET&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;No R, temos a facilidade de poder fazer o cálculo dos componentes principais e logo em seguida poder apresentá-los em gráficos elegantes e de fácil entendimento. O Objetivo deste post é apresentar uma rápida demonstração de como rodar um PCA e gerar os gráficos derivados.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;if (!require(&amp;quot;pacman&amp;quot;)) install.packages(&amp;quot;pacman&amp;quot;)
pacman::p_load(readr, dplyr, ggplot2, ggrepel)
pacman::p_load_gh(&amp;quot;vqv/ggbiplot&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;dados &amp;lt;- read_csv2(
  &amp;quot;https://github.com/italocegatta/italocegatta.github.io_source/raw/master/content/dados/base_clima.csv&amp;quot;
)

print(dados, n=31)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 31 × 6
##                Cidade Koppen  Tmed    PPT    ETP   DEF
##                 &amp;lt;chr&amp;gt;  &amp;lt;chr&amp;gt; &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt;
## 1        Bom Despacho    Cwa 22.64  801.8 1112.1 238.4
## 2         Niquelandia     Aw 24.63  562.2 1372.5 655.7
## 3             Arapoti    Cfb 18.48 1367.0  669.7  25.4
## 4           Rio Verde     Aw 23.34 1244.8 1196.2 425.4
## 5        Belo Oriente     Aw 22.56 1053.5 1104.8 125.4
## 6            Guanhaes    Cwa 20.62  817.6  866.0 187.9
## 7     Eldorado do Sul    Cfa 20.58 1787.4  858.7  10.7
## 8         Sao Gabriel    Cfa 20.23 1782.6  927.4   2.8
## 9           Inhambupe     As 24.23  715.2 1318.4 607.4
## 10           Botucatu    Cfb 21.94 1012.8 1030.0 184.1
## 11     Estrela do Sul    Cwa 23.41 1133.6 1208.4 206.2
## 12               Buri    Cfa 19.98 1404.4  805.0   3.6
## 13          Inocencia     Am 24.48 1019.6 1374.8 389.2
## 14    Chapadao do Sul     Am 22.62 1026.6 1097.7 325.8
## 15            Aracruz     Aw 23.89  849.4 1276.9 335.5
## 16        Tres Lagoas     Aw 25.23  943.8 1501.6 538.4
## 17        Tres Marias     Aw 22.25  811.4 1052.1 404.8
## 18              Peixe     Aw 26.29 1207.6 1630.3 674.5
## 19         Mogi Guacu    Cwa 22.40  923.6 1100.4 209.9
## 20 Brejinho de Nazare     Aw 25.88 1507.2 1563.4 495.7
## 21      Monte Dourado     Am 27.38 2528.7 1820.6 529.7
## 22     Otacilio Costa    Cfb 16.91 2092.2  547.8   0.0
## 23     Telemaco Borba    Cfa 18.48 1367.0  669.7  28.0
## 24             Borebi    Cfa 22.12  947.6 1057.8 200.9
## 25   Coracao de Jesus     As 23.91  413.4 1275.1 743.7
## 26     Antonio Olinto    Cfb 17.67 1740.2  615.8   0.0
## 27        Tres Barras    Cfb 17.30 1122.8  581.0  16.5
## 28      Urbano Santos     Aw 27.05 1437.8 1750.3 935.0
## 29          Eunapolis     Am 22.88 1419.2 1127.6  31.2
## 30         Itagimirim     Aw 25.18  490.6 1460.3 869.5
## 31           Bocaiuva     Aw 23.91  413.4 1275.5 641.8&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A análise de componentes principais nos mostra o quanto cada grupo de variáveis explicam a variabilidade total dados. No nosso caso, o primeiro componente responde por 72% da variabilidade e tem efeito quase que igual da temperatura (Tmed), evapotranspiração (ETP) e déficit hídrico (DEF). O segundo componente é majoritariamente o efeito da chuva (PPT). Juntos, os dois componente explicam 95% dos dados.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;pca &amp;lt;- select(dados, Tmed:DEF) %&amp;gt;%
  princomp(cor = T)

summary(pca); loadings(pca)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Importance of components:
##                           Comp.1    Comp.2     Comp.3       Comp.4
## Standard deviation     1.7007490 0.9709348 0.40137904 0.0602784852
## Proportion of Variance 0.7231368 0.2356786 0.04027628 0.0009083739
## Cumulative Proportion  0.7231368 0.9588153 0.99909163 1.0000000000&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 
## Loadings:
##      Comp.1 Comp.2 Comp.3 Comp.4
## Tmed  0.567 -0.201 -0.437  0.668
## PPT  -0.241 -0.933  0.251       
## ETP   0.561 -0.284 -0.261 -0.732
## DEF   0.553         0.823       
## 
##                Comp.1 Comp.2 Comp.3 Comp.4
## SS loadings      1.00   1.00   1.00   1.00
## Proportion Var   0.25   0.25   0.25   0.25
## Cumulative Var   0.25   0.50   0.75   1.00&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A Figura &lt;a href=&#34;#fig:8-pca&#34;&gt;1&lt;/a&gt; ajuda-nos a visualizar a disposição das cidades em função dos dois principais componentes. Se analisarmos por quadrantes, podemos agrupar as cidades de clima semelhante e ainda verificar a relação com as variáveis de clima. As setas indicam o efeito positivo ou negativo da variável. Por exemplo, o quadrante Q4 é caracterizado por valores altos de chuva e praticamente nenhum deficit hídrico. No oposto, temos o Q2 com baixa precipitação e alto déficit hídrico.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggbiplot(pca) +
  geom_point() +
  geom_vline(xintercept = 0, size = 1.2, linetype = 6) +
  geom_hline(yintercept = 0, size = 1.2, linetype = 6) +
  geom_label_repel(aes(label = dados$Cidade), size = 3, nudge_x = .2) +
  annotate(
    &amp;quot;text&amp;quot;,
    x = c(-2, 2, 2, -2),
    y = c(2, 2, -2, -2), 
    label = paste0(&amp;quot;Q&amp;quot;, 1:4), size = 6
  ) +
  lims(x = c(-2,2), y = c(-2,2)) +
  theme_bw()&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;figure&#34;&gt;&lt;span id=&#34;fig:8-pca&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;/post/2016-08-01-analise-de-componentes-principais_files/figure-html/8-pca-1.png&#34; alt=&#34;Representação gráfica dos componentes principais.&#34; width=&#34;3200&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figura  1: Representação gráfica dos componentes principais.
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Como também temos a informação do clima Koppen, podemos colorir o gráfico em função deste atributo (Figura &lt;a href=&#34;#fig:8-pca-koppen&#34;&gt;2&lt;/a&gt;).&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggbiplot(pca) +
  geom_point(aes(color = dados$Koppen)) +
  geom_vline(xintercept = 0, size = 1.2, linetype = 6) +
  geom_hline(yintercept = 0, size = 1.2, linetype = 6) +
  geom_label_repel(
    aes(color = dados$Koppen, label = dados$Cidade),
    size = 3, nudge_x = .2, show.legend = F
  ) +
  lims(x = c(-2,2), y = c(-2,2)) +
  scale_color_brewer(&amp;quot;Clima Koppen&amp;quot;, palette = &amp;quot;Dark2&amp;quot;) +
  theme_bw()+
  theme(legend.position = &amp;quot;top&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;figure&#34;&gt;&lt;span id=&#34;fig:8-pca-koppen&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;/post/2016-08-01-analise-de-componentes-principais_files/figure-html/8-pca-koppen-1.png&#34; alt=&#34;Representação gráfica dos componentes principais com classificação Koppen.&#34; width=&#34;3200&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figura  2: Representação gráfica dos componentes principais com classificação Koppen.
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Caso tenha alguma dúvida ou sugestão sobre o post, fique à vontade para fazer um comentário ou me contactar por Email.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;devtools::session_info()&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  setting  value                       
##  version  R version 3.3.3 (2017-03-06)
##  system   x86_64, mingw32             
##  ui       RTerm                       
##  language (EN)                        
##  collate  Portuguese_Brazil.1252      
##  tz       America/Sao_Paulo           
##  date     2017-04-08                  
## 
##  package      * version date       source                           
##  assertthat     0.1     2013-12-06 CRAN (R 3.3.2)                   
##  backports      1.0.5   2017-01-18 CRAN (R 3.3.2)                   
##  blogdown       0.0.25  2017-03-23 Github (rstudio/blogdown@1c10d16)
##  bookdown       0.3.14  2017-03-23 Github (rstudio/bookdown@f427fdf)
##  colorspace     1.3-2   2016-12-14 CRAN (R 3.3.2)                   
##  curl           2.3     2016-11-24 CRAN (R 3.3.2)                   
##  DBI            0.5-1   2016-09-10 CRAN (R 3.3.2)                   
##  devtools       1.12.0  2016-06-24 CRAN (R 3.3.3)                   
##  digest         0.6.12  2017-01-27 CRAN (R 3.3.2)                   
##  dplyr        * 0.5.0   2016-06-24 CRAN (R 3.3.2)                   
##  evaluate       0.10    2016-10-11 CRAN (R 3.3.3)                   
##  ggbiplot     * 0.55    2017-03-24 Github (vqv/ggbiplot@7325e88)    
##  ggplot2      * 2.2.1   2016-12-30 CRAN (R 3.3.2)                   
##  ggrepel      * 0.6.5   2016-11-24 CRAN (R 3.3.3)                   
##  gtable         0.2.0   2016-02-26 CRAN (R 3.3.2)                   
##  highr          0.6     2016-05-09 CRAN (R 3.3.3)                   
##  htmltools      0.3.5   2016-03-21 CRAN (R 3.3.3)                   
##  knitr          1.15.1  2016-11-22 CRAN (R 3.3.3)                   
##  labeling       0.3     2014-08-23 CRAN (R 3.3.2)                   
##  lazyeval       0.2.0   2016-06-12 CRAN (R 3.3.2)                   
##  magrittr       1.5     2014-11-22 CRAN (R 3.3.2)                   
##  memoise        1.0.0   2016-01-29 CRAN (R 3.3.3)                   
##  munsell        0.4.3   2016-02-13 CRAN (R 3.3.2)                   
##  pacman       * 0.4.1   2016-03-30 CRAN (R 3.3.3)                   
##  plyr         * 1.8.4   2016-06-08 CRAN (R 3.3.2)                   
##  R6             2.2.0   2016-10-05 CRAN (R 3.3.2)                   
##  RColorBrewer   1.1-2   2014-12-07 CRAN (R 3.3.2)                   
##  Rcpp           0.12.9  2017-01-14 CRAN (R 3.3.2)                   
##  readr        * 1.0.0   2016-08-03 CRAN (R 3.3.2)                   
##  rmarkdown      1.3     2016-12-21 CRAN (R 3.3.3)                   
##  rprojroot      1.2     2017-01-16 CRAN (R 3.3.3)                   
##  scales       * 0.4.1   2016-11-09 CRAN (R 3.3.2)                   
##  stringi        1.1.2   2016-10-01 CRAN (R 3.3.2)                   
##  stringr        1.2.0   2017-02-18 CRAN (R 3.3.2)                   
##  tibble         1.2     2016-08-26 CRAN (R 3.3.2)                   
##  withr          1.0.2   2016-06-20 CRAN (R 3.3.3)                   
##  yaml           2.1.14  2016-11-12 CRAN (R 3.3.3)&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Os gráficos que explicam nossos dados (histograma)</title>
      <link>/os-graficos-que-explicam-nossos-dados-histograma/</link>
      <pubDate>Fri, 15 Jul 2016 00:00:00 +0000</pubDate>
      
      <guid>/os-graficos-que-explicam-nossos-dados-histograma/</guid>
      <description>&lt;p&gt;Histogramas são usados para mostrar a frequência com que uma variável ocorre. Isto é muito interessante para mostrar qual a distribuição dos seus dados e podemos apresentar em forma de frequência absoluta, relativa, percentual e acumulada. Para exemplificar este tipo gráfico, vamos utilizar os dados de inventário de uma propriedade fictícia na Amazônia. Estes dados são meramente ilustrativos e não tem valor real. O objetivo aqui é apresentar algumas particularidades da construção de gráficos de barras no R e facilitar a vida de quem quer abandonar os gráficos do Excel.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;if (!require(&amp;quot;pacman&amp;quot;)) install.packages(&amp;quot;pacman&amp;quot;)
pacman::p_load(readr, dplyr, ggplot2, ggthemes)&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;dados &amp;lt;- read_csv2(
  &amp;quot;https://raw.githubusercontent.com/italocegatta/italocegatta.github.io_source/master/content/dados/base_amazonia.csv&amp;quot;
)

dados&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 276 × 7
##             Especie              Nome_cientifico Comercial   DAP  HCom
##               &amp;lt;chr&amp;gt;                        &amp;lt;chr&amp;gt;     &amp;lt;chr&amp;gt; &amp;lt;int&amp;gt; &amp;lt;int&amp;gt;
## 1  NAO IDENTIFICADA             Nao Identificada       Nao    20    10
## 2            EMBIRA                Lecythidaceae       Nao    34    13
## 3  NAO IDENTIFICADA             Nao Identificada       Nao    18     6
## 4          SUCUPIRA   Leguminosae-Papilionoideae       Nao    18     7
## 5            CANELA                    Lauraceae       Nao    24    10
## 6             TACHI                Lecythidaceae       Sim    21    10
## 7       ENVIRA CAJU                   Annonaceae       Nao    20    11
## 8             JUTAI Leguminosae-Caesalpinioideae       Nao    38    13
## 9           CATUABA                 Vochysiaceae       Sim    57    13
## 10 NAO IDENTIFICADA             Nao Identificada       Nao    22     7
## # ... with 266 more rows, and 2 more variables: Volume &amp;lt;dbl&amp;gt;, QF &amp;lt;int&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Primeiro vamos ver qual a distribuição dos indivíduos em classes de diâmetro. A Figura &lt;a href=&#34;#fig:7-hist-dap&#34;&gt;1&lt;/a&gt; mostra a frequência de indivíduos em classes de diâmetro de 10 cm. Visivelmente, podemos ver que a faixa de diâmetro mais frequente está entre 15 e 35 cm (centro de classe 20 e 30 cm, respectivamente).&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggplot(dados, aes(DAP)) +
  geom_histogram(binwidth = 10, color = &amp;quot;white&amp;quot;) +
  labs(x = &amp;quot;Diâmetro (cm)&amp;quot;, y = &amp;quot;Frequência (arv/ha)&amp;quot;) +
  scale_x_continuous(breaks = seq(0, 100,10)) +
  theme_few()&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;figure&#34;&gt;&lt;span id=&#34;fig:7-hist-dap&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;/post/2016-07-15-os-graficos-que-explicam-nossos-dados-histograma_files/figure-html/7-hist-dap-1.png&#34; alt=&#34;Histograma com a frequência absoluta por classes de diâmetro.&#34; width=&#34;4000&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figura  1: Histograma com a frequência absoluta por classes de diâmetro.
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Mas, e quanto às espécies comerciais? Como elas estão distribuídas? A Figura &lt;a href=&#34;#fig:7-hist-dap-comerc&#34;&gt;2&lt;/a&gt; faz esta diferenciação. E lembre-se, no manejo florestal da Amazônia só é permitido a exploração de árvores com diâmetro maior que 50 cm.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggplot(dados, aes(DAP, fill = Comercial)) +
  geom_histogram(binwidth = 10, color = &amp;quot;white&amp;quot;, alpha = 0.5) +
  labs(x = &amp;quot;Diâmetro (cm)&amp;quot;, y = &amp;quot;Frequência (arv/ha)&amp;quot;) +
  scale_x_continuous(breaks = seq(0, 100,10)) +
  theme_few() +
  theme(legend.position = c(.9, .9)) +
  scale_fill_hue(&amp;quot;Comercial?&amp;quot;, labels = c(&amp;quot;Não&amp;quot;, &amp;quot;Sim&amp;quot;))&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;figure&#34;&gt;&lt;span id=&#34;fig:7-hist-dap-comerc&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;/post/2016-07-15-os-graficos-que-explicam-nossos-dados-histograma_files/figure-html/7-hist-dap-comerc-1.png&#34; alt=&#34;Histograma com a frequência absoluta por classes de diâmetro e separação pelo fator de árvores de interesse comercial.&#34; width=&#34;4000&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figura  2: Histograma com a frequência absoluta por classes de diâmetro e separação pelo fator de árvores de interesse comercial.
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Vamos melhorar um pouco mais a informação sob o ponto de vista da exploração: qual a frequência de indivíduos que são de interesse comercial e tem diâmetro mais que 50 cm? (Figura &lt;a href=&#34;#fig:7-hist-vol-exp&#34;&gt;3&lt;/a&gt;).&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggplot(dados, aes(Volume, fill = DAP &amp;gt; 50 &amp;amp; Comercial == &amp;quot;Sim&amp;quot;)) +
  geom_histogram(binwidth = 0.5, color = &amp;quot;white&amp;quot;, alpha = 0.5) +
  labs(x = Volume~individual ~ (m^3 / arv), y = &amp;quot;Frequência (arv/ha)&amp;quot;) +
  scale_y_continuous(breaks = seq(0, 150, 20)) +
  scale_x_continuous(breaks = seq(0, 10, 0.5)) +
  theme_few()  +
  theme(legend.position = c(.9, .9)) +
  scale_fill_hue(&amp;quot;Pode explorar?&amp;quot;, labels = c(&amp;quot;Não&amp;quot;, &amp;quot;Sim&amp;quot;))&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;figure&#34;&gt;&lt;span id=&#34;fig:7-hist-vol-exp&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;/post/2016-07-15-os-graficos-que-explicam-nossos-dados-histograma_files/figure-html/7-hist-vol-exp-1.png&#34; alt=&#34;Histograma com a frequência absoluta por classes de volume individual e separação pelo fator de árvores de interesse comercial e diâmetro maior que 50 cm.&#34; width=&#34;4000&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figura  3: Histograma com a frequência absoluta por classes de volume individual e separação pelo fator de árvores de interesse comercial e diâmetro maior que 50 cm.
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Se quisermos ainda apresentar o gráfico em termos das frequências relativas, podemos fazer a seguinte modificação, conforme a Figura &lt;a href=&#34;#fig:7-hist-vol-exp-rel&#34;&gt;4&lt;/a&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggplot(dados, aes(Volume, fill = DAP &amp;gt; 50 &amp;amp; Comercial == &amp;quot;Sim&amp;quot;)) +
  geom_histogram(
    aes(y = ..count../sum(..count..)),
    binwidth = 0.5, color = &amp;quot;white&amp;quot;, alpha = 0.5
  ) +
  labs(x =  Volume~individual ~ (m^3 / arv), y = &amp;quot;Frequência (arv/ha)&amp;quot;) +
  scale_y_continuous(breaks = seq(0, .5, 0.05), labels = scales::percent) +
  scale_x_continuous(breaks = seq(0, 10, 0.5)) +
  theme_few()  +
  theme(legend.position = c(.9, .9)) +
  scale_fill_hue(&amp;quot;Pode explorar?&amp;quot;, labels = c(&amp;quot;Não&amp;quot;, &amp;quot;Sim&amp;quot;))&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;figure&#34;&gt;&lt;span id=&#34;fig:7-hist-vol-exp-rel&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;/post/2016-07-15-os-graficos-que-explicam-nossos-dados-histograma_files/figure-html/7-hist-vol-exp-rel-1.png&#34; alt=&#34;Histograma com a frequência relativa por classes de volume individual e separação pelo fator de árvores de interesse comercial e diâmetro maior que 50 cm.&#34; width=&#34;4000&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figura  4: Histograma com a frequência relativa por classes de volume individual e separação pelo fator de árvores de interesse comercial e diâmetro maior que 50 cm.
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Caso tenha alguma dúvida ou sugestão sobre o post, fique à vontade para fazer um comentário ou me contactar por Email.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;devtools::session_info()&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  setting  value                       
##  version  R version 3.3.3 (2017-03-06)
##  system   x86_64, mingw32             
##  ui       RTerm                       
##  language (EN)                        
##  collate  Portuguese_Brazil.1252      
##  tz       America/Sao_Paulo           
##  date     2017-04-08                  
## 
##  package    * version date       source                           
##  assertthat   0.1     2013-12-06 CRAN (R 3.3.2)                   
##  backports    1.0.5   2017-01-18 CRAN (R 3.3.2)                   
##  blogdown     0.0.25  2017-03-23 Github (rstudio/blogdown@1c10d16)
##  bookdown     0.3.14  2017-03-23 Github (rstudio/bookdown@f427fdf)
##  colorspace   1.3-2   2016-12-14 CRAN (R 3.3.2)                   
##  curl         2.3     2016-11-24 CRAN (R 3.3.2)                   
##  DBI          0.5-1   2016-09-10 CRAN (R 3.3.2)                   
##  devtools     1.12.0  2016-06-24 CRAN (R 3.3.3)                   
##  digest       0.6.12  2017-01-27 CRAN (R 3.3.2)                   
##  dplyr      * 0.5.0   2016-06-24 CRAN (R 3.3.2)                   
##  evaluate     0.10    2016-10-11 CRAN (R 3.3.3)                   
##  ggplot2    * 2.2.1   2016-12-30 CRAN (R 3.3.2)                   
##  ggthemes   * 3.4.0   2017-02-19 CRAN (R 3.3.3)                   
##  gtable       0.2.0   2016-02-26 CRAN (R 3.3.2)                   
##  highr        0.6     2016-05-09 CRAN (R 3.3.3)                   
##  htmltools    0.3.5   2016-03-21 CRAN (R 3.3.3)                   
##  knitr        1.15.1  2016-11-22 CRAN (R 3.3.3)                   
##  labeling     0.3     2014-08-23 CRAN (R 3.3.2)                   
##  lazyeval     0.2.0   2016-06-12 CRAN (R 3.3.2)                   
##  magrittr     1.5     2014-11-22 CRAN (R 3.3.2)                   
##  memoise      1.0.0   2016-01-29 CRAN (R 3.3.3)                   
##  munsell      0.4.3   2016-02-13 CRAN (R 3.3.2)                   
##  pacman     * 0.4.1   2016-03-30 CRAN (R 3.3.3)                   
##  plyr         1.8.4   2016-06-08 CRAN (R 3.3.2)                   
##  R6           2.2.0   2016-10-05 CRAN (R 3.3.2)                   
##  Rcpp         0.12.9  2017-01-14 CRAN (R 3.3.2)                   
##  readr      * 1.0.0   2016-08-03 CRAN (R 3.3.2)                   
##  rmarkdown    1.3     2016-12-21 CRAN (R 3.3.3)                   
##  rprojroot    1.2     2017-01-16 CRAN (R 3.3.3)                   
##  scales       0.4.1   2016-11-09 CRAN (R 3.3.2)                   
##  stringi      1.1.2   2016-10-01 CRAN (R 3.3.2)                   
##  stringr      1.2.0   2017-02-18 CRAN (R 3.3.2)                   
##  tibble       1.2     2016-08-26 CRAN (R 3.3.2)                   
##  withr        1.0.2   2016-06-20 CRAN (R 3.3.3)                   
##  yaml         2.1.14  2016-11-12 CRAN (R 3.3.3)&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Os gráficos que explicam nossos dados (heatmap)</title>
      <link>/os-graficos-que-explicam-nossos-dados-heatmap/</link>
      <pubDate>Sat, 09 Jul 2016 00:00:00 +0000</pubDate>
      
      <guid>/os-graficos-que-explicam-nossos-dados-heatmap/</guid>
      <description>&lt;p&gt;O heatmap é um gráfico muito útil para identificar padrões, principalmente quando temos muitas variáveis no gráfico. Essencialmente o heatmap necessita de 3 variáveis: uma variável resposta e duas outras variáveis para compor os eixos x e y. Não há restrição quanto ao tipo de variável, qualquer uma delas podem ser quantitativa ou qualitativa. Talvez esse seja o trunfo do heatmap, essa flexbilidade quanto a natureza das variáveis nos permite utilizá-lo em diversos momentos e substituir gráficos mais tradicionais quando eles não dão conta do recado.&lt;/p&gt;
&lt;p&gt;Vamos trabalhar com os dados do &lt;a href=&#34;http://www.projetotume.com/&#34;&gt;Projeto TUME&lt;/a&gt;, especificamente com o TUME 0, plantado na Estação Experimental de Itatinga. O TUME é um projeto muito interessante e possui informações importantes sobre plantios de &lt;em&gt;Eucalyptus&lt;/em&gt; no Brasil, vale a pena visitar o site e aproveitar o conteúdo disponível.&lt;/p&gt;
&lt;p&gt;Vamos primeiro carregar os dados e fazer algumas alterações. Para auxiliar na ordem dos fatores no gráfico vamos adicionar um atributo na coluna &lt;code&gt;Esp&lt;/code&gt; informando a ordem crescente das espécies em função da altura dominante. Em seguida, apenas por conveniência, converti a idade dos inventários de meses para anos.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;if (!require(&amp;quot;pacman&amp;quot;)) install.packages(&amp;quot;pacman&amp;quot;)
pacman::p_load(readr, dplyr, ggplot2, ggthemes, viridis)&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;dados &amp;lt;- read_csv2(
  &amp;quot;https://github.com/italocegatta/italocegatta.github.io_source/raw/master/content/dados/tume0.csv&amp;quot;
)

# Cria um fator com o atributo para a variável Esp que informa a ordem crescente
# das espécies em função da altura dominante.
dados &amp;lt;- dados %&amp;gt;% 
  mutate(
    Esp = reorder(Esp, Hdom, function(x) max(x)),
    Idade = round(I_meses/12,1)
  )
dados&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 138 × 16
##    N_tume             Esp I_meses Parc_m2 DAPmed DAPsd  Hmed   Hsd  Hdom
##     &amp;lt;int&amp;gt;          &amp;lt;fctr&amp;gt;   &amp;lt;int&amp;gt;   &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt;
## 1       0         Clone_1      52  1425.6   11.4   1.4  16.5   1.3  17.8
## 2       0         Clone_2      52  1425.6   10.2   1.4  15.9   1.4  16.6
## 3       0         Clone_3      52  1425.6   10.7   1.6  15.0   1.3  16.1
## 4       0     E_benthamii      52  1425.6    9.0   2.7   9.8   2.3  13.0
## 5       0    E_botryoides      52  1425.6    9.1   4.3  10.8   3.4  15.3
## 6       0 E_camaldulensis      52  1425.6    8.3   2.9   8.3   2.3  11.8
## 7       0    E_citriodora      52  1425.6    8.0   3.5   8.3   2.8  12.0
## 8       0     E_cloeziana      52   928.8    7.5   2.5   7.0   2.0   9.6
## 9       0        E_deanei      52  1425.6   10.6   2.9  11.3   1.8  13.4
## 10      0        E_dunnii      52  1425.6    6.7   3.7   6.1   2.4  10.3
## # ... with 128 more rows, and 7 more variables: N_fuste &amp;lt;int&amp;gt;, Sobr &amp;lt;dbl&amp;gt;,
## #   G &amp;lt;dbl&amp;gt;, V &amp;lt;int&amp;gt;, IMA &amp;lt;dbl&amp;gt;, B &amp;lt;int&amp;gt;, Idade &amp;lt;dbl&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Se fizermos a seguinte pergunta: qual gráfico podemos utilizar para mostrar o crescimento da altura dominantes dos materiais? Penso que a resposta rápida seria, um gráfico de linhas! Ok, vamos tentar, veja a Figura &lt;a href=&#34;#fig:6-linhas&#34;&gt;1&lt;/a&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggplot(dados, aes(Idade, Hdom, color = Esp)) +
  geom_line(size=1.5) +
  labs(x = &amp;quot;Idade (anos)&amp;quot;, y = &amp;quot;Altura dominante (m)&amp;quot;) +
  theme_few() +
  scale_color_viridis(
    name = &amp;quot;Materiais genéticos&amp;quot;,
    direction = -1, discrete = T
  ) +
  guides(col = guide_legend(ncol = 1, reverse = TRUE))&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;figure&#34;&gt;&lt;span id=&#34;fig:6-linhas&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;/post/2016-07-09-os-graficos-que-explicam-nossos-dados-heatmap_files/figure-html/6-linhas-1.png&#34; alt=&#34;Aumento da altura dominante utilizando gráficos de linhas.&#34; width=&#34;4000&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figura  1: Aumento da altura dominante utilizando gráficos de linhas.
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Muito bem, o gráfico consegue mostar a tendência e o padrão de crescimento. Mas se alguém perguntar sobre o &lt;em&gt;Eucaluptus dunnii&lt;/em&gt;, capaz de demorarmos um tempo para encontrar a linha correspondente. Capaz ainda de não conseguirmos distinguir entre uma cor e outra. Essa é uma limitação do gráfico de linhas, quanto temos muitos fatores na legenda fica difícil a distinção entre eles. E quando se tem uma restrição de cor e o gráfico precisa estar em escala de cinza? Esquece! Há quem tente utilizar símbolos ou tipos de traços para distinguir os fatores, mas mesmo assim, não é uma tarefa fácil.&lt;/p&gt;
&lt;p&gt;É neste momento que podemos nos aproveitar do heatmap. Agora a intencidade de cor indica a variável resposta (Figura &lt;a href=&#34;#fig:6-heatmap-cont&#34;&gt;2&lt;/a&gt;). Veja que fica mais fácil acompanhar o crescimento de uma espécies em especial.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggplot(dados, aes(factor(Idade), Esp, fill = Hdom)) +
  geom_tile() +
  labs(x = &amp;quot;Idade (anos)&amp;quot;, y = &amp;quot;Materiais genéticos&amp;quot;) +
  theme_few() +
  scale_fill_viridis(name = &amp;quot;Altura dominante (m)&amp;quot;, direction = -1) +
  guides(col = guide_legend(reverse = TRUE))&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;figure&#34;&gt;&lt;span id=&#34;fig:6-heatmap-cont&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;/post/2016-07-09-os-graficos-que-explicam-nossos-dados-heatmap_files/figure-html/6-heatmap-cont-1.png&#34; alt=&#34;Aumento da altura dominante utilizando heatmap com escala de cor contínua.&#34; width=&#34;4000&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figura  2: Aumento da altura dominante utilizando heatmap com escala de cor contínua.
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Se for do interesse controlar a escala de cor em intervalos e classes, a alteração é simples (Figura &lt;a href=&#34;#fig:6-heatmap-discr&#34;&gt;3&lt;/a&gt;). Se reduzirmos as classes de cor, perdemos resolução na escala da variável resposta. Dependendo do objetivo do gráfico isso pode ser bom ou ruim. Neste caso, escolhi intervalos de 2 metros, pois achei mais adequado.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggplot(dados, aes(factor(Idade),
       Esp, fill = cut(Hdom, breaks = seq(0, 40, 2)))) +
 geom_tile() +
 labs(x = &amp;quot;Idade (anos)&amp;quot;, y = &amp;quot;Materiais genéticos&amp;quot;) +
 theme_few() +
 scale_fill_viridis(
   name = &amp;quot;Altura dominante (m)&amp;quot;,
   discrete = T, direction = -1
 ) +
 guides(col = guide_legend(reverse = TRUE))&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;figure&#34;&gt;&lt;span id=&#34;fig:6-heatmap-discr&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;/post/2016-07-09-os-graficos-que-explicam-nossos-dados-heatmap_files/figure-html/6-heatmap-discr-1.png&#34; alt=&#34;Aumento da altura dominante utilizando heatmap com escala de cor discreta.&#34; width=&#34;4000&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figura  3: Aumento da altura dominante utilizando heatmap com escala de cor discreta.
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Se quisermos deixar explícito o valor da variável resposta podemos indicá-la no gráfico, como na Figura &lt;a href=&#34;#fig:6-heatmap-discr-label&#34;&gt;4&lt;/a&gt;. Eu particularmente acho que fica muito poluído, mas em alguns casos pode ser interessante.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggplot(dados, aes(factor(Idade),
       Esp, fill = cut(Hdom, breaks = seq(0, 40, 2)))) +
 geom_tile() +
 geom_text(aes(label = Hdom), color = &amp;quot;white&amp;quot;) +
 labs(x = &amp;quot;Idade (anos)&amp;quot;, y = &amp;quot;Materiais genéticos&amp;quot;) +
 theme_few() +
 scale_fill_viridis(
   name = &amp;quot;Altura dominante (m)&amp;quot;,
   discrete = T, direction = -1
 ) +
 guides(col = guide_legend(reverse = TRUE))&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;figure&#34;&gt;&lt;span id=&#34;fig:6-heatmap-discr-label&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;/post/2016-07-09-os-graficos-que-explicam-nossos-dados-heatmap_files/figure-html/6-heatmap-discr-label-1.png&#34; alt=&#34;Aumento da altura dominante utilizando heatmap com escala de cor discreta e informação do valor no grid.&#34; width=&#34;4000&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figura  4: Aumento da altura dominante utilizando heatmap com escala de cor discreta e informação do valor no grid.
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Note que o eixo x é uma variável temporal, entretanto o gráfico não dá a escala entre os anos. Um observador desatento pode achar que as medições ocorreram em intervalos regulares, mas isso não é verdade. Essa é uma desvantagem do heatmap. Quando as variáveis dos eixos são numéricas e representam uma escala comparativa, este atributo fica comprometido.&lt;/p&gt;
&lt;p&gt;Caso tenha alguma dúvida ou sugestão sobre o post, fique à vontade para fazer um comentário ou me contactar por Email.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;devtools::session_info()&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  setting  value                       
##  version  R version 3.3.3 (2017-03-06)
##  system   x86_64, mingw32             
##  ui       RTerm                       
##  language (EN)                        
##  collate  Portuguese_Brazil.1252      
##  tz       America/Sao_Paulo           
##  date     2017-04-08                  
## 
##  package    * version date       source                           
##  assertthat   0.1     2013-12-06 CRAN (R 3.3.2)                   
##  backports    1.0.5   2017-01-18 CRAN (R 3.3.2)                   
##  blogdown     0.0.25  2017-03-23 Github (rstudio/blogdown@1c10d16)
##  bookdown     0.3.14  2017-03-23 Github (rstudio/bookdown@f427fdf)
##  colorspace   1.3-2   2016-12-14 CRAN (R 3.3.2)                   
##  curl         2.3     2016-11-24 CRAN (R 3.3.2)                   
##  DBI          0.5-1   2016-09-10 CRAN (R 3.3.2)                   
##  devtools     1.12.0  2016-06-24 CRAN (R 3.3.3)                   
##  digest       0.6.12  2017-01-27 CRAN (R 3.3.2)                   
##  dplyr      * 0.5.0   2016-06-24 CRAN (R 3.3.2)                   
##  evaluate     0.10    2016-10-11 CRAN (R 3.3.3)                   
##  ggplot2    * 2.2.1   2016-12-30 CRAN (R 3.3.2)                   
##  ggthemes   * 3.4.0   2017-02-19 CRAN (R 3.3.3)                   
##  gridExtra    2.2.1   2016-02-29 CRAN (R 3.3.3)                   
##  gtable       0.2.0   2016-02-26 CRAN (R 3.3.2)                   
##  highr        0.6     2016-05-09 CRAN (R 3.3.3)                   
##  htmltools    0.3.5   2016-03-21 CRAN (R 3.3.3)                   
##  knitr        1.15.1  2016-11-22 CRAN (R 3.3.3)                   
##  labeling     0.3     2014-08-23 CRAN (R 3.3.2)                   
##  lazyeval     0.2.0   2016-06-12 CRAN (R 3.3.2)                   
##  magrittr     1.5     2014-11-22 CRAN (R 3.3.2)                   
##  memoise      1.0.0   2016-01-29 CRAN (R 3.3.3)                   
##  munsell      0.4.3   2016-02-13 CRAN (R 3.3.2)                   
##  pacman     * 0.4.1   2016-03-30 CRAN (R 3.3.3)                   
##  plyr         1.8.4   2016-06-08 CRAN (R 3.3.2)                   
##  R6           2.2.0   2016-10-05 CRAN (R 3.3.2)                   
##  Rcpp         0.12.9  2017-01-14 CRAN (R 3.3.2)                   
##  readr      * 1.0.0   2016-08-03 CRAN (R 3.3.2)                   
##  rmarkdown    1.3     2016-12-21 CRAN (R 3.3.3)                   
##  rprojroot    1.2     2017-01-16 CRAN (R 3.3.3)                   
##  scales       0.4.1   2016-11-09 CRAN (R 3.3.2)                   
##  stringi      1.1.2   2016-10-01 CRAN (R 3.3.2)                   
##  stringr      1.2.0   2017-02-18 CRAN (R 3.3.2)                   
##  tibble       1.2     2016-08-26 CRAN (R 3.3.2)                   
##  viridis    * 0.3.4   2016-03-12 CRAN (R 3.3.3)                   
##  withr        1.0.2   2016-06-20 CRAN (R 3.3.3)                   
##  yaml         2.1.14  2016-11-12 CRAN (R 3.3.3)&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Os gráficos que explicam nossos dados (barras)</title>
      <link>/os-graficos-que-explicam-nossos-dados-barras/</link>
      <pubDate>Sat, 14 May 2016 00:00:00 +0000</pubDate>
      
      <guid>/os-graficos-que-explicam-nossos-dados-barras/</guid>
      <description>&lt;p&gt;Este é o segundo post de uma série que estou fazendo sobre tipos de gráficos. Falamos um pouco sobre o &lt;a href=&#34;https://italocegatta.github.io/os-graficos-que-explicam-nossos-dados-boxplot&#34;&gt;boxplot&lt;/a&gt; e agora vamos ao gráfico de barras.&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;Gráficos de barras são muito úteis para podermos comparar fatores. Quando estão um ao lado do outro a comparação é feita rapidamente, já que as barras dão a noção de escala. Normalmente as barras informam um resumo (i. e. média, soma ou contagem), mas podemos ainda adicionar uma barra de erro ou desvio e deixar o gráfico mais detalhado.&lt;/p&gt;
&lt;p&gt;Continuaremos com o banco de dados apresentado no post sobre &lt;a href=&#34;https://italocegatta.github.io/o-conceito-tidy-data.html&#34;&gt;tidy data&lt;/a&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;if (!require(&amp;quot;pacman&amp;quot;)) install.packages(&amp;quot;pacman&amp;quot;)
pacman::p_load(readr, dplyr, ggplot2, ggthemes)&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;dados &amp;lt;- read_csv2(
  &amp;quot;https://github.com/italocegatta/italocegatta.github.io_source/raw/master/content/dados/base_vespa.csv&amp;quot;
)

dados&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 2,100 × 5
##    Tratamento Individuo Coleta   Local Galhas
##         &amp;lt;chr&amp;gt;     &amp;lt;int&amp;gt;  &amp;lt;int&amp;gt;   &amp;lt;chr&amp;gt;  &amp;lt;int&amp;gt;
## 1   Actara d1         1      1 Peciolo      1
## 2   Actara d1         2      1 Peciolo     NA
## 3   Actara d1         3      1 Peciolo     NA
## 4   Actara d1         4      1 Peciolo     NA
## 5   Actara d1         5      1 Peciolo     NA
## 6   Actara d1         6      1 Peciolo     NA
## 7   Actara d1         7      1 Peciolo     NA
## 8   Actara d1         8      1 Peciolo     NA
## 9   Actara d1         9      1 Peciolo     NA
## 10  Actara d1        10      1 Peciolo     NA
## # ... with 2,090 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;div id=&#34;basico&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Básico&lt;/h2&gt;
&lt;p&gt;A primeira sequência de gráficos está relacionada ao total de galhas encontradas nas mudas de cada tratamento. Nessa comparação, temos de considerar tratamentos como fatores e os locais onde a galha foi encontrada como níveis do fator local. Essa distinção vai nos ajuda a escolher a melhor forma de construir um gráfico de acordo com o que queremos mostrar.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# seleciona apenas as Coletas de numero 5, em seguida monta um fator de 
# agrupamento em função de Tratamento. Aplica a soma de todas as
# observações (Galhas) de acordo com o fator de agrupamento.

total_trat &amp;lt;- dados %&amp;gt;%
  filter(Coleta == 5) %&amp;gt;%
  group_by(Tratamento) %&amp;gt;%
  summarise(Galhas = sum(Galhas, na.rm=T))

total_trat&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 7 × 2
##    Tratamento Galhas
##         &amp;lt;chr&amp;gt;  &amp;lt;int&amp;gt;
## 1   Actara d1     73
## 2   Actara d2     57
## 3   Actara d3     30
## 4 Evidence d1     27
## 5 Evidence d2     21
## 6 Evidence d3     12
## 7  Testemunha     77&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Agora já podemos fazer o primeiro gráfico simples e básico (Figura &lt;a href=&#34;#fig:5-bar-basico&#34;&gt;1&lt;/a&gt;).&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggplot(total_trat, aes(Tratamento, Galhas)) +
  geom_bar(stat = &amp;quot;identity&amp;quot;) +
  theme_few()&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;figure&#34;&gt;&lt;span id=&#34;fig:5-bar-basico&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;/post/2016-05-14-os-graficos-que-explicam-nossos-dados-barras_files/figure-html/5-bar-basico-1.png&#34; alt=&#34;Número total de galhas de cada tratamento.&#34; width=&#34;4000&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figura  1: Número total de galhas de cada tratamento.
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Mas ainda temos a variável &lt;code&gt;Local&lt;/code&gt;, certo? Podemos apresentá-la sem muito esforço.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;total_trat_local &amp;lt;- dados %&amp;gt;%
  filter(Coleta == 5) %&amp;gt;%
  group_by(Tratamento, Local) %&amp;gt;%
  summarise(Galhas = sum(Galhas, na.rm=T))

total_trat_local&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Source: local data frame [21 x 3]
## Groups: Tratamento [?]
## 
##     Tratamento   Local Galhas
##          &amp;lt;chr&amp;gt;   &amp;lt;chr&amp;gt;  &amp;lt;int&amp;gt;
## 1    Actara d1   Caule     13
## 2    Actara d1 Nervura     19
## 3    Actara d1 Peciolo     41
## 4    Actara d2   Caule     10
## 5    Actara d2 Nervura      9
## 6    Actara d2 Peciolo     38
## 7    Actara d3   Caule      7
## 8    Actara d3 Nervura      6
## 9    Actara d3 Peciolo     17
## 10 Evidence d1   Caule      6
## # ... with 11 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggplot(total_trat_local, aes(Tratamento, Galhas, fill = Local)) +
  geom_bar(stat = &amp;quot;identity&amp;quot;) +
  theme_few() +
  scale_fill_brewer(palette = &amp;quot;Spectral&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;figure&#34;&gt;&lt;span id=&#34;fig:5-bar-local&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;/post/2016-05-14-os-graficos-que-explicam-nossos-dados-barras_files/figure-html/5-bar-local-1.png&#34; alt=&#34;Número total de galhas de cada tratamento em diferentes locais - níveis agrupados.&#34; width=&#34;4000&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figura  2: Número total de galhas de cada tratamento em diferentes locais - níveis agrupados.
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;No caso da Figura &lt;a href=&#34;#fig:5-bar-local&#34;&gt;2&lt;/a&gt;, à primeira vista comparamos as barras (fatores) e depois as cores (níveis). Podemos dar mais evidência aos níveis, transformando-os em barras como na Figura &lt;a href=&#34;#fig:5-bar-local-dodge&#34;&gt;3&lt;/a&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggplot(total_trat_local, aes(Tratamento, Galhas, fill = Local)) +
  geom_bar(stat = &amp;quot;identity&amp;quot;, position = &amp;quot;dodge&amp;quot;) +
  theme_few() +
  scale_fill_brewer(palette = &amp;quot;Spectral&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;figure&#34;&gt;&lt;span id=&#34;fig:5-bar-local-dodge&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;/post/2016-05-14-os-graficos-que-explicam-nossos-dados-barras_files/figure-html/5-bar-local-dodge-1.png&#34; alt=&#34;Número total de galhas de cada tratamento em diferentes locais - níveis lado a lados.&#34; width=&#34;4000&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figura  3: Número total de galhas de cada tratamento em diferentes locais - níveis lado a lados.
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Como alternativa, podemos subdividir os níveis em painéis e deixar o gráfico mais balanceado, ou seja, sem concentrar a informação em fatores ou níveis (Figura &lt;a href=&#34;#fig:5-bar-local-facet&#34;&gt;4&lt;/a&gt;).&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggplot(total_trat_local, aes(Tratamento, Galhas )) +
  geom_bar(stat = &amp;quot;identity&amp;quot;, position = &amp;quot;dodge&amp;quot;) +
  facet_wrap(~Local) +
  theme_few() +
  theme(axis.text.x = element_text(angle = 30, hjust = 0.5, vjust = 0.5))&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;figure&#34;&gt;&lt;span id=&#34;fig:5-bar-local-facet&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;/post/2016-05-14-os-graficos-que-explicam-nossos-dados-barras_files/figure-html/5-bar-local-facet-1.png&#34; alt=&#34;Número total de galhas de cada tratamento em diferentes locais - níveis em painel.&#34; width=&#34;4000&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figura  4: Número total de galhas de cada tratamento em diferentes locais - níveis em painel.
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Note que nos 3 gráficos anteriores o banco de dados para formação do gráfico é o mesmo, mas cada um dá ênfase em um aspecto diferente. A parte boa é que podemos modificá-los de acordo com o nosso interesse de uma forma rápida e bem simples.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;adicionando-valores-as-barras&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Adicionando valores às barras&lt;/h2&gt;
&lt;p&gt;Se quisermos adicionar o valor de cada nível ou fator na barra, temos de alterar o banco de dados para que ele coincida com o que queremos mostrar.&lt;/p&gt;
&lt;p&gt;Para a Figura &lt;a href=&#34;#fig:5-bar-basico-annot&#34;&gt;5&lt;/a&gt;, modificamos apenas o código do gráfico.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggplot(total_trat, aes(Tratamento, Galhas)) +
  geom_bar(stat = &amp;quot;identity&amp;quot;) +
  geom_text(aes(label = Galhas), size = 6, vjust = -0.2) +
  theme_few()&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;figure&#34;&gt;&lt;span id=&#34;fig:5-bar-basico-annot&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;/post/2016-05-14-os-graficos-que-explicam-nossos-dados-barras_files/figure-html/5-bar-basico-annot-1.png&#34; alt=&#34;Número total de galhas de cada tratamento com o valor na respectiva barra.&#34; width=&#34;4000&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figura  5: Número total de galhas de cada tratamento com o valor na respectiva barra.
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Para a próxima figura temos de criar uma coluna que informa a posição em que o valor deve ficar no eixo y, uma vez que ele deve estar exatamente no centro do respectivo compartimento da barra. Como resultado temos a Figura &lt;a href=&#34;#fig:5-bar-local-annot&#34;&gt;6&lt;/a&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# Cria uma nova coluna que contem a posição no eixo y que corresponde ao centro
# da barra. Esta posição correnponde ao local onde o label de cada barra
# será mostrado

total_trat_local_y &amp;lt;- total_trat_local %&amp;gt;%
  mutate(Galhas_y = replace(cumsum(Galhas) - (0.5*Galhas),
    Galhas  ==  0, NA))

ggplot(total_trat_local_y, aes(Tratamento, Galhas, fill = Local)) +
  geom_bar(stat = &amp;quot;identity&amp;quot;) +
  geom_text(aes(label = Galhas, y = Galhas_y)) +
  theme_few() +
  scale_fill_brewer(palette = &amp;quot;Spectral&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;figure&#34;&gt;&lt;span id=&#34;fig:5-bar-local-annot&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;/post/2016-05-14-os-graficos-que-explicam-nossos-dados-barras_files/figure-html/5-bar-local-annot-1.png&#34; alt=&#34;Número total de galhas de cada tratamento em diferentes locais com o valor da respectiva barra - níveis agrupados.&#34; width=&#34;4000&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figura  6: Número total de galhas de cada tratamento em diferentes locais com o valor da respectiva barra - níveis agrupados.
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;As Figuras &lt;a href=&#34;#fig:5-bar-local-dodge-annot&#34;&gt;7&lt;/a&gt; e &lt;a href=&#34;#fig:5-bar-local-facet-annot&#34;&gt;8&lt;/a&gt; foram criadas apenas alterando o código do gráfico.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggplot(total_trat_local, aes(Tratamento, Galhas, fill = Local)) +
  geom_bar(stat = &amp;quot;identity&amp;quot;, position = &amp;quot;dodge&amp;quot;) +
  geom_text(aes(label = Galhas),
    position = position_dodge(width=0.9), vjust = -0.2) +
  theme_few() +
  scale_fill_brewer(palette = &amp;quot;Spectral&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;figure&#34;&gt;&lt;span id=&#34;fig:5-bar-local-dodge-annot&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;/post/2016-05-14-os-graficos-que-explicam-nossos-dados-barras_files/figure-html/5-bar-local-dodge-annot-1.png&#34; alt=&#34;Número total de galhas de cada tratamento em diferentes locais com o valor da respectiva barra - níveis lado a lados.&#34; width=&#34;4000&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figura  7: Número total de galhas de cada tratamento em diferentes locais com o valor da respectiva barra - níveis lado a lados.
&lt;/p&gt;
&lt;/div&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggplot(total_trat_local, aes(Tratamento, Galhas )) +
  geom_bar(stat = &amp;quot;identity&amp;quot;, position = &amp;quot;dodge&amp;quot;) +
    geom_text(aes(label = Galhas), vjust = -0.2) +
  facet_wrap(~Local) +
  theme_few() +
  theme(axis.text.x = element_text(angle = 30, hjust = 0.5, vjust = 0.5))&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;figure&#34;&gt;&lt;span id=&#34;fig:5-bar-local-facet-annot&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;/post/2016-05-14-os-graficos-que-explicam-nossos-dados-barras_files/figure-html/5-bar-local-facet-annot-1.png&#34; alt=&#34;Número total de galhas de cada tratamento em diferentes locais com o valor da respectiva barra - níveis em painel.&#34; width=&#34;4000&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figura  8: Número total de galhas de cada tratamento em diferentes locais com o valor da respectiva barra - níveis em painel.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;barra-de-desvio&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Barra de desvio&lt;/h2&gt;
&lt;p&gt;Uma outra informação interessante para o gráfico de barras é a barra de erro ou desvio. Com ela, além de informarmos o valor que queremos, também informamos uma medida de dispersão associada a esse valor. Nos gráficos anteriores apresentei o total de galhas por tratamento e local. Não faz sentido, nesse caso, colocar uma barra de desvio, pois a soma não é uma medida de posição. Portanto, vamos resumir novamente os dados em função da média e acrescentar o erro padrão da média.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# Seleciona apenas as Coletas de numero 5, em seguida calcula a média e o
# desvio padrão de cada Tratamento.

media_trat_desv &amp;lt;- dados %&amp;gt;%
  filter(Coleta == 5) %&amp;gt;%
  group_by(Tratamento) %&amp;gt;%
  summarise(desv = sd(Galhas, na.rm=T)/sqrt(n()),
    Galhas = mean(Galhas, na.rm=T))

media_trat_desv&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 7 × 3
##    Tratamento      desv   Galhas
##         &amp;lt;chr&amp;gt;     &amp;lt;dbl&amp;gt;    &amp;lt;dbl&amp;gt;
## 1   Actara d1 0.4799351 4.055556
## 2   Actara d2 0.4893473 3.352941
## 3   Actara d3 0.1331730 2.307692
## 4 Evidence d1 0.5889188 3.857143
## 5 Evidence d2 0.2667039 2.625000
## 6 Evidence d3 0.1632993 2.000000
## 7  Testemunha 0.3601529 3.347826&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Após criar o &lt;em&gt;data frame&lt;/em&gt; com o desvio, a Figura &lt;a href=&#34;#fig:5-bar-basico-desv&#34;&gt;9&lt;/a&gt; é facilmente criada com o código abaixo.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggplot(media_trat_desv, aes(Tratamento, Galhas)) +
  geom_bar(stat = &amp;quot;identity&amp;quot;) +
  geom_errorbar(aes(ymin = Galhas - desv,
     ymax = Galhas + desv), width = 0.4) +
  theme_few()&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;figure&#34;&gt;&lt;span id=&#34;fig:5-bar-basico-desv&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;/post/2016-05-14-os-graficos-que-explicam-nossos-dados-barras_files/figure-html/5-bar-basico-desv-1.png&#34; alt=&#34;Número total de galhas de cada tratamento com barra de desvio.&#34; width=&#34;4000&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figura  9: Número total de galhas de cada tratamento com barra de desvio.
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;No caso das Figuras &lt;a href=&#34;#fig:5-bar-local-dodge-desv&#34;&gt;10&lt;/a&gt; e &lt;a href=&#34;#fig:5-bar-local-facet-desv&#34;&gt;11&lt;/a&gt;, precisamos dados dados agrupados por &lt;code&gt;Tratamento&lt;/code&gt; e &lt;code&gt;Local&lt;/code&gt;. O código para o gráfico é muito semelhante aos anteriores. Em alguns tratamentos há somente um indivíduo indivídio com contagem de galhas. Nesta situação não há barra de desvio.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# Seleciona apenas as Coletas de numero 5, em seguida calcula a mediana e o
# desvio padrão em função de cada Trtatamento e Local.

mediana_trat_local_desv &amp;lt;- dados %&amp;gt;%
  filter(Coleta == 5) %&amp;gt;%
  group_by(Tratamento, Local) %&amp;gt;%
  summarise(desv = sd(Galhas, na.rm=T)/sqrt(n()),
    Galhas = median(Galhas, na.rm=T))

mediana_trat_local_desv&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Source: local data frame [21 x 4]
## Groups: Tratamento [?]
## 
##     Tratamento   Local      desv Galhas
##          &amp;lt;chr&amp;gt;   &amp;lt;chr&amp;gt;     &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt;
## 1    Actara d1   Caule 0.3291403      2
## 2    Actara d1 Nervura 0.8276473      3
## 3    Actara d1 Peciolo 1.0200373      4
## 4    Actara d2   Caule 0.2708013      1
## 5    Actara d2 Nervura 0.2813657      2
## 6    Actara d2 Peciolo 1.1751393      4
## 7    Actara d3   Caule 0.1118034      2
## 8    Actara d3 Nervura 0.0000000      2
## 9    Actara d3 Peciolo 0.2972092      3
## 10 Evidence d1   Caule 0.2236068      2
## # ... with 11 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggplot(mediana_trat_local_desv, aes(Tratamento, Galhas, fill = Local)) +
  geom_bar(stat = &amp;quot;identity&amp;quot;, position = &amp;quot;dodge&amp;quot;) +
  geom_errorbar(aes(ymin = Galhas - desv, ymax = Galhas + desv),
    position = position_dodge(width=0.9), width = 0.4) +
  theme_few() +
  scale_fill_brewer(palette = &amp;quot;Spectral&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;figure&#34;&gt;&lt;span id=&#34;fig:5-bar-local-dodge-desv&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;/post/2016-05-14-os-graficos-que-explicam-nossos-dados-barras_files/figure-html/5-bar-local-dodge-desv-1.png&#34; alt=&#34;Número total de galhas de cada tratamento em diferentes locais com barra de desvio - níveis lado a lados.&#34; width=&#34;4000&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figura  10: Número total de galhas de cada tratamento em diferentes locais com barra de desvio - níveis lado a lados.
&lt;/p&gt;
&lt;/div&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggplot(mediana_trat_local_desv, aes(Tratamento, Galhas )) +
  geom_bar(stat = &amp;quot;identity&amp;quot;, position = &amp;quot;dodge&amp;quot;) +
  geom_errorbar(aes(ymin = Galhas - desv,
    ymax = Galhas + desv), width = 0.4) +
  facet_wrap(~Local) +
  theme_few() +
  theme(axis.text.x = element_text(angle = 30, hjust = 0.5, vjust = 0.5))&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;figure&#34;&gt;&lt;span id=&#34;fig:5-bar-local-facet-desv&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;/post/2016-05-14-os-graficos-que-explicam-nossos-dados-barras_files/figure-html/5-bar-local-facet-desv-1.png&#34; alt=&#34;Número total de galhas de cada tratamento em diferentes locais com barra de desvio - níveis em painel.&#34; width=&#34;4000&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figura  11: Número total de galhas de cada tratamento em diferentes locais com barra de desvio - níveis em painel.
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Caso tenha alguma dúvida ou sugestão sobre o post, fique à vontade para fazer um comentário ou me contactar por Email.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;devtools::session_info()&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  setting  value                       
##  version  R version 3.3.3 (2017-03-06)
##  system   x86_64, mingw32             
##  ui       RTerm                       
##  language (EN)                        
##  collate  Portuguese_Brazil.1252      
##  tz       America/Sao_Paulo           
##  date     2017-04-08                  
## 
##  package      * version date       source                           
##  assertthat     0.1     2013-12-06 CRAN (R 3.3.2)                   
##  backports      1.0.5   2017-01-18 CRAN (R 3.3.2)                   
##  blogdown       0.0.25  2017-03-23 Github (rstudio/blogdown@1c10d16)
##  bookdown       0.3.14  2017-03-23 Github (rstudio/bookdown@f427fdf)
##  colorspace     1.3-2   2016-12-14 CRAN (R 3.3.2)                   
##  curl           2.3     2016-11-24 CRAN (R 3.3.2)                   
##  DBI            0.5-1   2016-09-10 CRAN (R 3.3.2)                   
##  devtools       1.12.0  2016-06-24 CRAN (R 3.3.3)                   
##  digest         0.6.12  2017-01-27 CRAN (R 3.3.2)                   
##  dplyr        * 0.5.0   2016-06-24 CRAN (R 3.3.2)                   
##  evaluate       0.10    2016-10-11 CRAN (R 3.3.3)                   
##  ggplot2      * 2.2.1   2016-12-30 CRAN (R 3.3.2)                   
##  ggthemes     * 3.4.0   2017-02-19 CRAN (R 3.3.3)                   
##  gtable         0.2.0   2016-02-26 CRAN (R 3.3.2)                   
##  highr          0.6     2016-05-09 CRAN (R 3.3.3)                   
##  htmltools      0.3.5   2016-03-21 CRAN (R 3.3.3)                   
##  knitr          1.15.1  2016-11-22 CRAN (R 3.3.3)                   
##  labeling       0.3     2014-08-23 CRAN (R 3.3.2)                   
##  lazyeval       0.2.0   2016-06-12 CRAN (R 3.3.2)                   
##  magrittr       1.5     2014-11-22 CRAN (R 3.3.2)                   
##  memoise        1.0.0   2016-01-29 CRAN (R 3.3.3)                   
##  munsell        0.4.3   2016-02-13 CRAN (R 3.3.2)                   
##  pacman       * 0.4.1   2016-03-30 CRAN (R 3.3.3)                   
##  plyr           1.8.4   2016-06-08 CRAN (R 3.3.2)                   
##  R6             2.2.0   2016-10-05 CRAN (R 3.3.2)                   
##  RColorBrewer   1.1-2   2014-12-07 CRAN (R 3.3.2)                   
##  Rcpp           0.12.9  2017-01-14 CRAN (R 3.3.2)                   
##  readr        * 1.0.0   2016-08-03 CRAN (R 3.3.2)                   
##  rmarkdown      1.3     2016-12-21 CRAN (R 3.3.3)                   
##  rprojroot      1.2     2017-01-16 CRAN (R 3.3.3)                   
##  scales         0.4.1   2016-11-09 CRAN (R 3.3.2)                   
##  stringi        1.1.2   2016-10-01 CRAN (R 3.3.2)                   
##  stringr        1.2.0   2017-02-18 CRAN (R 3.3.2)                   
##  tibble         1.2     2016-08-26 CRAN (R 3.3.2)                   
##  withr          1.0.2   2016-06-20 CRAN (R 3.3.3)                   
##  yaml           2.1.14  2016-11-12 CRAN (R 3.3.3)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Os gráficos que explicam nossos dados (boxplot)</title>
      <link>/os-graficos-que-explicam-nossos-dados-boxplot/</link>
      <pubDate>Fri, 06 May 2016 00:00:00 +0000</pubDate>
      
      <guid>/os-graficos-que-explicam-nossos-dados-boxplot/</guid>
      <description>&lt;p&gt;Nossos dados merecem ser apresentados de forma clara, atraente e inspiradora. Não há nada mais frustrante que dar duro no campo para coletar os dados e depois apresentá-los numa simples tabela de resumos. Podemos e devemos fazer mais, certo?&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;Vou começar agora uma série de posts sobre tipos de gráficos. Como disse no primeiro post desse &lt;a href=&#34;https://italocegatta.github.io/sobre-esse-blog.html&#34;&gt;blog&lt;/a&gt;, minha intenção é documentar os scripts que escrevi durante a graduação, portanto os gráficos que vou apresentar se resumem aos que tive de fazer por conta de alguma demanda específica.&lt;/p&gt;
&lt;p&gt;Para iniciar, escolhi o gráfico boxplot. É um gráfico muito útil para entender a variabilidade das nossas observações. No boxplot temos 5 informações básicas: valor mínimo, primeiro quartil, mediana, terceiro quartil e valor máximo. Há ainda a notificação de &lt;em&gt;outliers&lt;/em&gt;, quando a observação é maior ou menor que 1,5 vezes a distância interquartílica.&lt;/p&gt;
&lt;p&gt;Vamos trabalhar com os dados que apresentei no post anterior sobre &lt;a href=&#34;https://italocegatta.github.io/o-conceito-tidy-data.html&#34;&gt;tidy data&lt;/a&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(pacman)
p_load(readr, dplyr, tidyr, ggplot2, ggthemes)&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;dados &amp;lt;- read_csv2(
  &amp;quot;https://raw.githubusercontent.com/italocegatta/italocegatta.github.io_source/master/content/dados/base_vespa.csv&amp;quot;
)

dados&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 2,100 × 5
##    Tratamento Individuo Coleta   Local Galhas
##         &amp;lt;chr&amp;gt;     &amp;lt;int&amp;gt;  &amp;lt;int&amp;gt;   &amp;lt;chr&amp;gt;  &amp;lt;int&amp;gt;
## 1   Actara d1         1      1 Peciolo      1
## 2   Actara d1         2      1 Peciolo     NA
## 3   Actara d1         3      1 Peciolo     NA
## 4   Actara d1         4      1 Peciolo     NA
## 5   Actara d1         5      1 Peciolo     NA
## 6   Actara d1         6      1 Peciolo     NA
## 7   Actara d1         7      1 Peciolo     NA
## 8   Actara d1         8      1 Peciolo     NA
## 9   Actara d1         9      1 Peciolo     NA
## 10  Actara d1        10      1 Peciolo     NA
## # ... with 2,090 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Primeiro vamos processar os dados da última medição (Coleta 5) para verificar o nº total de galhas de cada tratamento, desconsiderando o local da galha. Nesse caso estou considerando apenas as mudas que foram atacadas e tiveram o desenvolvimento de galhas.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# seleciona apenas as Coletas de numero 5, em seguida monta um fator de 
# agrupamento em função de Tratamento e Individuo. Aplica a soma de todas as
# observações (Galhas) de acordo com o fator de agrupamento. Troca os valores
# 0 (quando não há galhas) por NA.

total &amp;lt;- dados %&amp;gt;%
  filter(Coleta == 5) %&amp;gt;%
  group_by(Tratamento, Individuo) %&amp;gt;%
  summarise(Galhas = sum(Galhas, na.rm=T)) %&amp;gt;%
  mutate(Galhas = replace(Galhas, Galhas == 0, NA))

total&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Source: local data frame [140 x 3]
## Groups: Tratamento [7]
## 
##    Tratamento Individuo Galhas
##         &amp;lt;chr&amp;gt;     &amp;lt;int&amp;gt;  &amp;lt;int&amp;gt;
## 1   Actara d1         1     11
## 2   Actara d1         2     NA
## 3   Actara d1         3      4
## 4   Actara d1         4     NA
## 5   Actara d1         5     NA
## 6   Actara d1         6     NA
## 7   Actara d1         7     30
## 8   Actara d1         8     NA
## 9   Actara d1         9     NA
## 10  Actara d1        10     NA
## # ... with 130 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;O boxplot é um gráfico unidimensional, ou seja, precisamos de apenas uma variável para construí-lo. Entretanto, podemos usar variáveis categóricas para servir de agrupamento e replicar o gráfico para todos os níveis da variável. Por exemplo, no nosso banco de dados temos &lt;code&gt;Galhas&lt;/code&gt; como variável quantitativa e &lt;code&gt;Tratamento&lt;/code&gt;, &lt;code&gt;Coleta&lt;/code&gt; e &lt;code&gt;Local&lt;/code&gt; como variável qualitativa.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggplot(total, aes(&amp;quot;Total&amp;quot;, Galhas)) +
  geom_boxplot() +
  theme_few()&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;figure&#34;&gt;&lt;span id=&#34;fig:4-boxplot-total&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;/post/2016-05-06-os-graficos-que-explicam-nossos-dados-boxplot_files/figure-html/4-boxplot-total-1.png&#34; alt=&#34;Boxplot que mostra o nº de galhas de todos os tratamentos.&#34; width=&#34;4000&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figura  1: Boxplot que mostra o nº de galhas de todos os tratamentos.
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;A Figura &lt;a href=&#34;#fig:4-boxplot-total&#34;&gt;1&lt;/a&gt; dá uma visão geral de todas as observações em um único boxplot, mas não nos explica muita coisa. No caso da Figura &lt;a href=&#34;#fig:4-boxplot-trat&#34;&gt;2&lt;/a&gt;, &lt;code&gt;Tratamento&lt;/code&gt; tratamento é uma variável categórica e nos permite subdividir os boxplots para todos os níveis e assim podemos compará-los.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggplot(total, aes(Tratamento, Galhas)) +
  geom_boxplot() +
  theme_few()&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;figure&#34;&gt;&lt;span id=&#34;fig:4-boxplot-trat&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;/post/2016-05-06-os-graficos-que-explicam-nossos-dados-boxplot_files/figure-html/4-boxplot-trat-1.png&#34; alt=&#34;Boxplot que mostra o nº de galhas em função de cada tratamento.&#34; width=&#34;4000&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figura  2: Boxplot que mostra o nº de galhas em função de cada tratamento.
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Note que no tratamento &lt;em&gt;Actara d1&lt;/em&gt;, há um indivíduo discrepante (&lt;em&gt;outlier&lt;/em&gt;) que se destaca com 30 galhas. Note também a grande variabilidade entre os tratamentos, muito comum em experimentos envolvendo insetos. Normalmente o coeficiente de variação é extremamente alto e dificilmente há homogeneidade de variância. Um comentário interessante sobre o boxplot é que a caixa, valores entre o 1º e 3º quartil, corresponde a 50% das observações.&lt;/p&gt;
&lt;p&gt;Podemos também avaliar a variabilidade do nº de galhas por local. Para isso vamos incluir a variável &lt;code&gt;Local&lt;/code&gt; no agrupamento (Figura &lt;a href=&#34;#fig:4-boxplot-local&#34;&gt;3&lt;/a&gt;).&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# Adiciona mais um fator de agrupamento para o resumo. Nesse caso cada
# indivíduo terá o nº de galhas explicito em cada local.

local &amp;lt;- dados %&amp;gt;%
  filter(Coleta == 5) %&amp;gt;%
  group_by(Tratamento, Individuo, Local) %&amp;gt;%
  summarise(Galhas = sum(Galhas, na.rm=T)) %&amp;gt;%
  mutate(Galhas = replace(Galhas, Galhas == 0, NA))

local&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Source: local data frame [420 x 4]
## Groups: Tratamento, Individuo [140]
## 
##    Tratamento Individuo   Local Galhas
##         &amp;lt;chr&amp;gt;     &amp;lt;int&amp;gt;   &amp;lt;chr&amp;gt;  &amp;lt;int&amp;gt;
## 1   Actara d1         1   Caule      2
## 2   Actara d1         1 Nervura      3
## 3   Actara d1         1 Peciolo      6
## 4   Actara d1         2   Caule     NA
## 5   Actara d1         2 Nervura     NA
## 6   Actara d1         2 Peciolo     NA
## 7   Actara d1         3   Caule      1
## 8   Actara d1         3 Nervura      1
## 9   Actara d1         3 Peciolo      2
## 10  Actara d1         4   Caule     NA
## # ... with 410 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggplot(local, aes(Tratamento, Galhas, fill = Local)) +
  geom_boxplot() +
  theme_few() +
  scale_fill_brewer(palette = &amp;quot;Spectral&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;figure&#34;&gt;&lt;span id=&#34;fig:4-boxplot-local&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;/post/2016-05-06-os-graficos-que-explicam-nossos-dados-boxplot_files/figure-html/4-boxplot-local-1.png&#34; alt=&#34;Boxplot que mostra o nº de galhas por local e tratamento.&#34; width=&#34;4000&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figura  3: Boxplot que mostra o nº de galhas por local e tratamento.
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Uma outra perspectiva é avaliar a evolução do total de galhas por coleta. Para isto basta incluir a variável &lt;code&gt;Coleta&lt;/code&gt; no agrupamento (Figura &lt;a href=&#34;#fig:4-boxplot-coleta&#34;&gt;4&lt;/a&gt;). Para facilitar a visualização, vou excluir a primeira coleta. Podemos ainda adicionar os pontos que representam as observações para poder identificar quantas observações tem cada tratamento.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;total_coleta &amp;lt;- dados %&amp;gt;%
  filter(Coleta != 1 ) %&amp;gt;%
  group_by(Tratamento, Coleta, Individuo) %&amp;gt;%
  summarise(Galhas = sum(Galhas, na.rm=T)) %&amp;gt;%
  mutate(Galhas = replace(Galhas, Galhas == 0, NA))

total_coleta&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Source: local data frame [560 x 4]
## Groups: Tratamento, Coleta [28]
## 
##    Tratamento Coleta Individuo Galhas
##         &amp;lt;chr&amp;gt;  &amp;lt;int&amp;gt;     &amp;lt;int&amp;gt;  &amp;lt;int&amp;gt;
## 1   Actara d1      2         1      3
## 2   Actara d1      2         2     NA
## 3   Actara d1      2         3     NA
## 4   Actara d1      2         4     NA
## 5   Actara d1      2         5     NA
## 6   Actara d1      2         6     NA
## 7   Actara d1      2         7      2
## 8   Actara d1      2         8     NA
## 9   Actara d1      2         9     NA
## 10  Actara d1      2        10     NA
## # ... with 550 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggplot(total_coleta, aes(Tratamento, Galhas)) +
  geom_boxplot() +
  geom_jitter(alpha = 0.4) +
  facet_wrap(~ Coleta, labeller = label_both) +
  theme_few() +
  theme(axis.text.x = element_text(angle = 30, hjust = 0.5, vjust = 0.5))&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;figure&#34;&gt;&lt;span id=&#34;fig:4-boxplot-coleta&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;/post/2016-05-06-os-graficos-que-explicam-nossos-dados-boxplot_files/figure-html/4-boxplot-coleta-1.png&#34; alt=&#34;Boxplot que mostra a dispersão do total de galhas por tratamento  e coletas.&#34; width=&#34;4000&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figura  4: Boxplot que mostra a dispersão do total de galhas por tratamento e coletas.
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;É importante destacar que o gráfico da Figura &lt;a href=&#34;#fig:4-boxplot-coleta&#34;&gt;4&lt;/a&gt; não é adequado para esse tipo de informação. Nesse caso seria mais interessante um gráfico de linhas em que cada linha representa um tratamento (veremos esse gráfico em um futuro post).&lt;/p&gt;
&lt;p&gt;Caso tenha alguma dúvida ou sugestão sobre o post, fique à vontade para fazer um comentário ou me contactar por Email.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;devtools::session_info()&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  setting  value                       
##  version  R version 3.3.3 (2017-03-06)
##  system   x86_64, mingw32             
##  ui       RTerm                       
##  language (EN)                        
##  collate  Portuguese_Brazil.1252      
##  tz       America/Sao_Paulo           
##  date     2017-04-30                  
## 
##  package      * version date       source                           
##  assertthat     0.2.0   2017-04-11 CRAN (R 3.3.3)                   
##  backports      1.0.5   2017-01-18 CRAN (R 3.3.2)                   
##  blogdown       0.0.25  2017-03-23 Github (rstudio/blogdown@1c10d16)
##  bookdown       0.3.14  2017-03-23 Github (rstudio/bookdown@f427fdf)
##  colorspace     1.3-2   2016-12-14 CRAN (R 3.3.2)                   
##  curl           2.6     2017-04-27 CRAN (R 3.3.3)                   
##  DBI            0.6-1   2017-04-01 CRAN (R 3.3.3)                   
##  devtools       1.12.0  2016-06-24 CRAN (R 3.3.3)                   
##  digest         0.6.12  2017-01-27 CRAN (R 3.3.2)                   
##  dplyr        * 0.5.0   2016-06-24 CRAN (R 3.3.2)                   
##  evaluate       0.10    2016-10-11 CRAN (R 3.3.3)                   
##  ggplot2      * 2.2.1   2016-12-30 CRAN (R 3.3.2)                   
##  ggthemes     * 3.4.0   2017-02-19 CRAN (R 3.3.3)                   
##  gtable         0.2.0   2016-02-26 CRAN (R 3.3.2)                   
##  highr          0.6     2016-05-09 CRAN (R 3.3.3)                   
##  hms            0.3     2016-11-22 CRAN (R 3.3.2)                   
##  htmltools      0.3.6   2017-04-28 CRAN (R 3.3.3)                   
##  knitr          1.15.1  2016-11-22 CRAN (R 3.3.3)                   
##  labeling       0.3     2014-08-23 CRAN (R 3.3.2)                   
##  lazyeval       0.2.0   2016-06-12 CRAN (R 3.3.2)                   
##  magrittr       1.5     2014-11-22 CRAN (R 3.3.2)                   
##  memoise        1.1.0   2017-04-21 CRAN (R 3.3.3)                   
##  munsell        0.4.3   2016-02-13 CRAN (R 3.3.2)                   
##  pacman       * 0.4.1   2016-03-30 CRAN (R 3.3.3)                   
##  plyr           1.8.4   2016-06-08 CRAN (R 3.3.2)                   
##  R6             2.2.0   2016-10-05 CRAN (R 3.3.2)                   
##  RColorBrewer   1.1-2   2014-12-07 CRAN (R 3.3.2)                   
##  Rcpp           0.12.10 2017-03-19 CRAN (R 3.3.3)                   
##  readr        * 1.1.0   2017-03-22 CRAN (R 3.3.3)                   
##  rmarkdown      1.5     2017-04-26 CRAN (R 3.3.3)                   
##  rprojroot      1.2     2017-01-16 CRAN (R 3.3.3)                   
##  scales         0.4.1   2016-11-09 CRAN (R 3.3.2)                   
##  stringi        1.1.5   2017-04-07 CRAN (R 3.3.3)                   
##  stringr        1.2.0   2017-02-18 CRAN (R 3.3.2)                   
##  tibble         1.3.0   2017-04-01 CRAN (R 3.3.3)                   
##  tidyr        * 0.6.1   2017-01-10 CRAN (R 3.3.2)                   
##  withr          1.0.2   2016-06-20 CRAN (R 3.3.3)                   
##  yaml           2.1.14  2016-11-12 CRAN (R 3.3.3)&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>