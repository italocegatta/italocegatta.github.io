<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Readr on Italo Cegatta</title>
    <link>/tags/readr/</link>
    <description>Recent content in Readr on Italo Cegatta</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>pt-br</language>
    <lastBuildDate>Sun, 15 Jul 2018 00:00:00 +0000</lastBuildDate>
    
        <atom:link href="/tags/readr/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Risco de incêndio pela Fórmula de Monte Alegre</title>
      <link>/risco-de-incendio-pela-formula-de-monte-alegre/</link>
      <pubDate>Sun, 15 Jul 2018 00:00:00 +0000</pubDate>
      
      <guid>/risco-de-incendio-pela-formula-de-monte-alegre/</guid>
      <description>No setor florestal o fogo é uma questão recorrente e preocupante. Utilizar um índice de risco ou perigo de incêndio ajuda, no mínimo, no planejamento e no alerta para quem mora no entorno de maciços florestais como parques, hortos e plantios florestais.
A Fórmula de Monte Alegre (FMA) é um índice bastante simples, foi proposta em 1972 por Soares (1972) e utiliza apenas a umidade relativa do ar às 13h e a precipitação para calcular o risco de incêndio.</description>
      <content:encoded>
        


&lt;p&gt;No setor florestal o fogo é uma questão recorrente e preocupante. Utilizar um índice de risco ou perigo de incêndio ajuda, no mínimo, no planejamento e no alerta para quem mora no entorno de maciços florestais como parques, hortos e plantios florestais.&lt;/p&gt;
&lt;p&gt;A Fórmula de Monte Alegre (FMA) é um índice bastante simples, foi proposta em 1972 por &lt;span class=&#34;citation&#34;&gt;Soares (1972)&lt;/span&gt; e utiliza apenas a umidade relativa do ar às 13h e a precipitação para calcular o risco de incêndio. É um índice que possui 5 classes de risco e é cumulativo, portanto precisa ser calculado todos os dias.&lt;/p&gt;
&lt;p&gt;O objetivo deste post é implementar a FMA utilizando dados de 1988 à 2017 da estação meteorológica convencional da &lt;a href=&#34;http://www.esalq.usp.br/departamentos/leb/postocon.html&#34;&gt;ESALQ em Piracicaba&lt;/a&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;if (!require(&amp;quot;pacman&amp;quot;)) install.packages(&amp;quot;pacman&amp;quot;)
pacman::p_load(readr, dplyr, tidyr, forcats, lubridate, ggplot2, ggridges)&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;base &amp;lt;- read_csv2(
  &amp;quot;https://raw.githubusercontent.com/italocegatta/italocegatta.github.io_source/master/content/dados/posto_esalq_dia.csv&amp;quot;,
  col_types = cols(.default = col_number(), data = col_character())
)

base&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 10,961 x 3
##    data         ppt ur_med
##    &amp;lt;chr&amp;gt;      &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt;
##  1 01/01/1988   0       62
##  2 02/01/1988   0       65
##  3 03/01/1988   0       65
##  4 04/01/1988   0       69
##  5 05/01/1988  33.9     74
##  6 06/01/1988  66       90
##  7 07/01/1988   0       78
##  8 08/01/1988   0.5     88
##  9 09/01/1988  17.1     83
## 10 10/01/1988   7.8     83
## # ... with 10,951 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;O primeiro passo é estimar a umidade relativa às 13h, uma vez que é este valor que a FMA considera para o cálculo. Utilizaremos a equação ajustada por &lt;span class=&#34;citation&#34;&gt;Alvares et al. (2014)&lt;/span&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;base_fma &amp;lt;- base %&amp;gt;%
  mutate(
    data = dmy(data),
    ur13 = (8.77 * exp(0.024 * ur_med)) - 2.943
  ) %&amp;gt;% 
  select(data, ppt, ur13)

base_fma&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 10,961 x 3
##    data         ppt  ur13
##    &amp;lt;date&amp;gt;     &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt;
##  1 1988-01-01   0    35.9
##  2 1988-01-02   0    38.8
##  3 1988-01-03   0    38.8
##  4 1988-01-04   0    43.0
##  5 1988-01-05  33.9  48.9
##  6 1988-01-06  66    73.1
##  7 1988-01-07   0    54.1
##  8 1988-01-08   0.5  69.5
##  9 1988-01-09  17.1  61.3
## 10 1988-01-10   7.8  61.3
## # ... with 10,951 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Agora vamos fazer uma breve análise dos dados brutos. Começando pela chuva, podemos calcular o número médio de dias de chuva forte e fraca neste período. Entre julho e agosto há poucas chuvas em Piracicaba e isso já sugere que neste período o risco de incêndio deve ser alto.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;base_fma %&amp;gt;%
  mutate(ano = year(data), mes = month(data)) %&amp;gt;% 
  mutate(
    d_1 = ifelse(ppt &amp;gt; 1 &amp;amp; ppt &amp;lt;= 5, 1, 0),
    d_5 = ifelse(ppt &amp;gt; 5 , 1, 0)
  ) %&amp;gt;% 
  group_by(ano, mes) %&amp;gt;% 
  summarise_at(vars(d_1, d_5), sum, na.rm = TRUE) %&amp;gt;% 
  group_by(mes) %&amp;gt;% 
  summarise_at(vars(d_1, d_5), ~round(mean(.))) %&amp;gt;% 
  ungroup() %&amp;gt;% 
  rename(`&amp;lt;5` = d_1, `&amp;gt;5` = d_5) %&amp;gt;% 
  gather(nivel, d_chuva, `&amp;lt;5`:`&amp;gt;5`) %&amp;gt;% 
  mutate(
    d_chuva = ifelse(d_chuva == 0, NA, d_chuva),
    nivel = fct_relevel(nivel, &amp;quot;&amp;lt;5&amp;quot; , &amp;quot;&amp;gt;5&amp;quot;)
  ) %&amp;gt;% 
  ggplot(aes(mes, d_chuva, fill = nivel)) +
    geom_col(alpha = 0.8) +
    labs(
      x = &amp;quot;Mês do ano&amp;quot;,
      y = &amp;quot;Nº de dias de chuva (#)&amp;quot;,
      fill = NULL
    ) +
    scale_x_continuous(breaks = 1:12, labels = format(ISOdate(2000, 1:12, 1), &amp;quot;%b&amp;quot;)) +
    scale_y_continuous(breaks = seq(0, 30, 2), expand = expand_scale(mult = c(0.01, .1))) +
    scale_fill_manual(
      values = c(&amp;quot;#4292c6&amp;quot;, &amp;quot;#084594&amp;quot;),
      labels = c(&amp;quot;Chuva fraca (&amp;lt;5 mm)&amp;quot;,&amp;quot;Chuva forte (&amp;gt;5 mm)&amp;quot;)
    ) +
    theme_bw() +
    theme(legend.position = &amp;quot;top&amp;quot;, panel.grid.minor.x = element_blank())&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2018-07-15-risco-de-incendio-pela-formula-de-monte-alegre_files/figure-html/unnamed-chunk-4-1.svg&#34; width=&#34;960&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Olhando para a distribuição da umidade relativa em cada mês, podemos ver que em junho a mediana ainda está próximo dos 50% de umidade. E só em julho que os dias mais secos começam a ter mais frequência e essa tendência aumenta até setembro, depois retorna gradativamente até a mediana de 57% de umidade em dezembro.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;base_fma %&amp;gt;% 
  filter(!is.na(ur13)) %&amp;gt;% 
  mutate(mes = factor(month(data))) %&amp;gt;% 
  ggplot(aes(ur13, mes)) +
    geom_density_ridges(quantile_lines = TRUE, quantiles = 2, fill = &amp;quot;#016c59&amp;quot;, alpha = 0.9) +
    labs(x = &amp;quot;Umidade Relativa às 13h (%)&amp;quot;, y = &amp;quot;Mês do ano&amp;quot;) +
    scale_x_continuous(breaks = seq(10, 100, 10)) +
    scale_y_discrete(labels = format(ISOdate(2000, 1:12, 1), &amp;quot;%b&amp;quot;)) +
    theme_bw()&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2018-07-15-risco-de-incendio-pela-formula-de-monte-alegre_files/figure-html/unnamed-chunk-5-1.svg&#34; width=&#34;960&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Sobre a Fórmula de Monte Alegre, o contexto que motivou seu desenvolvimento foi bastante trágico. Em 1963 um grande incêndio atingiu o estado do Paraná, com centenas de mortes e cerca de 2 milhões de hectares de florestas queimadas. Em 1972 o Professor Ronaldo Soares, da UFPR, defendeu sua tese de mestrado propondo a Fórmula de Monte Alegre com base em registros de incêndios florestais coletados a partir de 1965 na fazenda Monte Alegre (Klabin), em Telêmaco Borba-PR.&lt;/p&gt;
&lt;p&gt;A cálculo do índice é bastante simples, basta calcular o valor FMA do dia corrente e somar com o valor do dia anterior. O FMA é calculado através da seguinte expressão:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.sciweavers.org/tex2img.php?eq=FMA%20%3D%20%20%5Csum_%7Bi%3D1%7D%5En%20%20%5Cfrac%7B100%7D%7BURi_%7B13h%7D%7D%20&amp;bc=White&amp;fc=Black&amp;im=jpg&amp;fs=12&amp;ff=arev&amp;edit=0&#34; align=&#34;center&#34; border=&#34;0&#34; alt=&#34;FMA =  \sum_{i=1}^n  \frac{100}{URi_{13h}} &#34; width=&#34;139&#34; height=&#34;62&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Entretanto é preciso aplicar restrições ao valor FMA de acordo com a chuva do dia, seguindo estes parâmetros:&lt;/p&gt;
&lt;table&gt;
&lt;colgroup&gt;
&lt;col width=&#34;14%&#34; /&gt;
&lt;col width=&#34;85%&#34; /&gt;
&lt;/colgroup&gt;
&lt;thead&gt;
&lt;tr class=&#34;header&#34;&gt;
&lt;th&gt;Precipitação&lt;/th&gt;
&lt;th&gt;Restrição&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td&gt;&amp;lt; 2,5&lt;/td&gt;
&lt;td&gt;Nenhuma&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td&gt;2,5 - 4,9&lt;/td&gt;
&lt;td&gt;0,7 * FMAi-1 + FMAi&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td&gt;5,0 - 9,9&lt;/td&gt;
&lt;td&gt;0,4 * FMAi-1 + FMAi&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td&gt;10,0 - 12,9&lt;/td&gt;
&lt;td&gt;0,2 * FMAi-1 + FMAi&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td&gt;&amp;gt; 12,9&lt;/td&gt;
&lt;td&gt;Interromper o cálculo anterior (FMAi = 0) e começar novo cálculo no dia seguinte&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;O resultado do índice é apresentado com frequência na forma de classes de risco, obedecendo estes limites:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr class=&#34;header&#34;&gt;
&lt;th&gt;FMA&lt;/th&gt;
&lt;th&gt;Grau de perigo&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td&gt;0 - 1,0&lt;/td&gt;
&lt;td&gt;Nulo&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td&gt;1,1 - 3,0&lt;/td&gt;
&lt;td&gt;Pequeno&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td&gt;3,1 - 8,0&lt;/td&gt;
&lt;td&gt;Médio&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td&gt;8,1 – 20,0&lt;/td&gt;
&lt;td&gt;Alto&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td&gt;&amp;gt; 20,0&lt;/td&gt;
&lt;td&gt;Muito alto&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Vamos agora declara as funções que vão calcular o FMA e atribuir as classes de risco aos nossos dados.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;fma &amp;lt;- function(data, ur, ppt) {
  
  # testa se os dados estão ordenados
  if (any(data != sort(data))) {
    stop(&amp;quot;data precisa estar em ordem crescente&amp;quot;)
  }

  # cria o vetor de resultado  
  n &amp;lt;- length(ur)
  fma_vec &amp;lt;- rep(NA_real_, n)
  
  for (i in seq_len(n)) {
    
    # primeiro valor eh 0   
    if (i == 1) {
      fma_vec[i] &amp;lt;- 0
      next()
    }
    
    # se dia anterior nao tem informacao, valor eh 0
    if (is.na(ur[i - 1])) {
      fma_vec[i] &amp;lt;- 0
      next()
    }
    
    # aplica restricoes da chuva
    fma_vec[i] &amp;lt;- case_when(
      ppt[i] &amp;lt; 2.5 ~ (100 / ur[i]) + fma_vec[i - 1] * 1 ,
      ppt[i] &amp;gt;= 2.5 &amp;amp; ppt[i] &amp;lt; 5  ~ (100 / ur[i]) + fma_vec[i - 1] * 0.7,
      ppt[i] &amp;gt;= 5   &amp;amp; ppt[i] &amp;lt; 10 ~ (100 / ur[i]) + fma_vec[i - 1] * 0.4,
      ppt[i] &amp;gt;= 10  &amp;amp; ppt[i] &amp;lt; 13 ~ (100 / ur[i]) + fma_vec[i - 1] * 0.2,
      ppt[i] &amp;gt;= 13 ~ 0
    )
  }
  
  fma_vec
}

fma_classe &amp;lt;- function(fma, limites = c(1, 3, 8, 20)) {
  
  classe &amp;lt;- case_when(
    fma &amp;lt;= 1 ~ &amp;quot;Nulo&amp;quot;,
    fma &amp;gt; 1 &amp;amp; fma &amp;lt;= 3 ~&amp;quot;Pequeno&amp;quot;,
    fma &amp;gt; 3 &amp;amp; fma &amp;lt;= 8 ~ &amp;quot;Médio&amp;quot;,
    fma &amp;gt; 8 &amp;amp; fma &amp;lt;= 20 ~ &amp;quot;Alto&amp;quot;,
    fma &amp;gt; 20 ~ &amp;quot;Muito Alto&amp;quot;
  )
  
  factor(classe, levels = c(&amp;quot;Nulo&amp;quot;, &amp;quot;Pequeno&amp;quot;, &amp;quot;Médio&amp;quot;, &amp;quot;Alto&amp;quot;, &amp;quot;Muito Alto&amp;quot;))
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Seguindo para o cálculo do índice, vamos criar um novo data frame com o valor FMA e as classes de riscos utilizando as funções que acabamos de criar.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;dados_fma &amp;lt;- base_fma %&amp;gt;% 
  mutate(
    fma = fma(data, ur13, ppt),
    risco = fma_classe(fma)
  )

dados_fma&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 10,961 x 5
##    data         ppt  ur13   fma risco  
##    &amp;lt;date&amp;gt;     &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;fct&amp;gt;  
##  1 1988-01-01   0    35.9  0    Nulo   
##  2 1988-01-02   0    38.8  2.58 Pequeno
##  3 1988-01-03   0    38.8  5.16 Médio  
##  4 1988-01-04   0    43.0  7.48 Médio  
##  5 1988-01-05  33.9  48.9  0    Nulo   
##  6 1988-01-06  66    73.1  0    Nulo   
##  7 1988-01-07   0    54.1  1.85 Pequeno
##  8 1988-01-08   0.5  69.5  3.29 Médio  
##  9 1988-01-09  17.1  61.3  0    Nulo   
## 10 1988-01-10   7.8  61.3  1.63 Pequeno
## # ... with 10,951 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A primeira abordagem que quero mostrar é a evolução do valor FMA ao longo do ano. Considerando o dia do ano ou dia juliano, podemos ver a evolução do valor FMA devido á ausência de chuvas fortes. O máximo dessa “corrida” de risco vai até próximo do dia 290, que corresponde ao meio de outubro.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;dados_fma %&amp;gt;% 
  mutate(
    ano = year(data),
    dia_ano = yday(data)
  ) %&amp;gt;% 
  ggplot(aes(dia_ano, factor(ano), fill = fma)) +
  geom_tile() +
  labs(x = &amp;quot;Dia do ano&amp;quot;, y = &amp;quot;Ano&amp;quot;, fill = &amp;quot;FMA&amp;quot;) +
  scale_fill_viridis_c(option = &amp;quot;viridis&amp;quot;) +
  scale_x_continuous(breaks = seq(20, 360, 20), expand = c(0, 0)) +
  theme_bw()&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2018-07-15-risco-de-incendio-pela-formula-de-monte-alegre_files/figure-html/unnamed-chunk-8-1.png&#34; width=&#34;960&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Calculando a frequência das classes dentro de cada ano, podemos ver que predomina o risco Muito Alto, seguido do risco Alto. O risco nulo, ocorre em aproximadamente 10% dos dias do ano.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;dados_fma  %&amp;gt;% 
  filter(!is.na(risco)) %&amp;gt;% 
  group_by(ano = year(data), risco) %&amp;gt;% 
  tally() %&amp;gt;% 
  ggplot(aes(ano, n, fill = risco)) +
  geom_col(position = &amp;quot;fill&amp;quot;, alpha = 0.8) +
  labs(x = &amp;quot;Ano&amp;quot;, y = &amp;quot;Frequência&amp;quot;, fill = &amp;quot;Risco&amp;quot;) +
  scale_y_continuous(breaks = seq(0.1, 1, 0.1), labels = scales::percent) +
  scale_fill_brewer(palette = &amp;quot;Spectral&amp;quot;, direction = -1) +
  theme_bw()&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2018-07-15-risco-de-incendio-pela-formula-de-monte-alegre_files/figure-html/unnamed-chunk-9-1.svg&#34; width=&#34;960&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Olhando para a frequência de risco dentro dos meses, fica claro o maior risco próximo do mês de agosto, como sugeriram os gráficos de frequências de chuva e umidade relativa.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;dados_fma  %&amp;gt;% 
  filter(!is.na(risco)) %&amp;gt;% 
  group_by(mes = month(data), risco) %&amp;gt;% 
  tally() %&amp;gt;% 
  ggplot(aes(mes, n, fill = risco)) +
  geom_col(position = &amp;quot;fill&amp;quot;, alpha = 0.8) +
  labs(x = &amp;quot;Mês do ano&amp;quot;, y = &amp;quot;Frequência&amp;quot;, fill = &amp;quot;Risco&amp;quot;) +
  scale_x_continuous(breaks = 1:12, labels = format(ISOdate(2000, 1:12, 1), &amp;quot;%b&amp;quot;)) +
  scale_y_continuous(labels = scales::percent) +
  scale_fill_brewer(palette = &amp;quot;Spectral&amp;quot;, direction = -1) +
  theme_bw()&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2018-07-15-risco-de-incendio-pela-formula-de-monte-alegre_files/figure-html/unnamed-chunk-10-1.svg&#34; width=&#34;960&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Bom, de maneira geral os gráficos não mostraram muita coisa nova. Todo mundo sabe que nos meses mais secos do ano o risco de incêndio é maior. De fato, o índice apenas dá um respaldo quantitativo para o senso comum. Uma vez calculado o índice, é possível confrontar com dados reais de incêndios e propor novos valores para as classes de risco com o objetivo de deixá-lo mais assertivo para uma certa região.&lt;/p&gt;
&lt;p&gt;Caso tenha alguma dúvida ou sugestão sobre o post, fique à vontade para fazer um comentário ou me contatar por E-mail.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;sessioninfo::session_info(c(&amp;quot;readr&amp;quot;, &amp;quot;dplyr&amp;quot;, &amp;quot;ggplot2&amp;quot;, &amp;quot;tidyr&amp;quot;, &amp;quot;forcats&amp;quot;, &amp;quot;lubridate&amp;quot;, &amp;quot;ggridges&amp;quot;))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## - Session info ----------------------------------------------------------
##  setting  value                       
##  version  R version 3.5.1 (2018-07-02)
##  os       Windows 10 x64              
##  system   x86_64, mingw32             
##  ui       RTerm                       
##  language (EN)                        
##  collate  Portuguese_Brazil.1252      
##  ctype    Portuguese_Brazil.1252      
##  tz       America/Sao_Paulo           
##  date     2018-12-31                  
## 
## - Packages --------------------------------------------------------------
##  package      * version  date       lib source        
##  assertthat     0.2.0    2017-04-11 [1] CRAN (R 3.5.1)
##  BH             1.66.0-1 2018-02-13 [1] CRAN (R 3.5.0)
##  bindr          0.1.1    2018-03-13 [1] CRAN (R 3.5.1)
##  bindrcpp     * 0.2.2    2018-03-29 [1] CRAN (R 3.5.1)
##  cli            1.0.1    2018-09-25 [1] CRAN (R 3.5.1)
##  clipr          0.4.1    2018-06-23 [1] CRAN (R 3.5.1)
##  colorspace     1.3-2    2016-12-14 [1] CRAN (R 3.5.1)
##  crayon         1.3.4    2017-09-16 [1] CRAN (R 3.5.1)
##  digest         0.6.18   2018-10-10 [1] CRAN (R 3.5.1)
##  dplyr        * 0.7.8    2018-11-10 [1] CRAN (R 3.5.1)
##  fansi          0.4.0    2018-10-05 [1] CRAN (R 3.5.1)
##  forcats      * 0.3.0    2018-02-19 [1] CRAN (R 3.5.1)
##  ggplot2      * 3.1.0    2018-10-25 [1] CRAN (R 3.5.1)
##  ggridges     * 0.5.1    2018-09-27 [1] CRAN (R 3.5.2)
##  glue           1.3.0    2018-07-17 [1] CRAN (R 3.5.1)
##  gtable         0.2.0    2016-02-26 [1] CRAN (R 3.5.1)
##  hms            0.4.2    2018-03-10 [1] CRAN (R 3.5.1)
##  labeling       0.3      2014-08-23 [1] CRAN (R 3.5.0)
##  lattice        0.20-35  2017-03-25 [2] CRAN (R 3.5.1)
##  lazyeval       0.2.1    2017-10-29 [1] CRAN (R 3.5.1)
##  lubridate    * 1.7.4    2018-04-11 [1] CRAN (R 3.5.1)
##  magrittr       1.5      2014-11-22 [1] CRAN (R 3.5.1)
##  MASS           7.3-50   2018-04-30 [2] CRAN (R 3.5.1)
##  Matrix         1.2-14   2018-04-13 [2] CRAN (R 3.5.1)
##  mgcv           1.8-24   2018-06-23 [2] CRAN (R 3.5.1)
##  munsell        0.5.0    2018-06-12 [1] CRAN (R 3.5.1)
##  nlme           3.1-137  2018-04-07 [2] CRAN (R 3.5.1)
##  pillar         1.3.1    2018-12-15 [1] CRAN (R 3.5.2)
##  pkgconfig      2.0.2    2018-08-16 [1] CRAN (R 3.5.1)
##  plogr          0.2.0    2018-03-25 [1] CRAN (R 3.5.1)
##  plyr           1.8.4    2016-06-08 [1] CRAN (R 3.5.1)
##  purrr          0.2.5    2018-05-29 [1] CRAN (R 3.5.1)
##  R6             2.3.0    2018-10-04 [1] CRAN (R 3.5.1)
##  RColorBrewer   1.1-2    2014-12-07 [1] CRAN (R 3.5.0)
##  Rcpp           1.0.0    2018-11-07 [1] CRAN (R 3.5.1)
##  readr        * 1.3.1    2018-12-21 [1] CRAN (R 3.5.2)
##  reshape2       1.4.3    2017-12-11 [1] CRAN (R 3.5.1)
##  rlang          0.3.0.1  2018-10-25 [1] CRAN (R 3.5.1)
##  scales         1.0.0    2018-08-09 [1] CRAN (R 3.5.1)
##  stringi        1.2.4    2018-07-20 [1] CRAN (R 3.5.1)
##  stringr        1.3.1    2018-05-10 [1] CRAN (R 3.5.1)
##  tibble         1.4.2    2018-01-22 [1] CRAN (R 3.5.1)
##  tidyr        * 0.8.2    2018-10-28 [1] CRAN (R 3.5.1)
##  tidyselect     0.2.5    2018-10-11 [1] CRAN (R 3.5.1)
##  utf8           1.1.4    2018-05-24 [1] CRAN (R 3.5.1)
##  viridisLite    0.3.0    2018-02-01 [1] CRAN (R 3.5.1)
##  withr          2.1.2    2018-03-15 [1] CRAN (R 3.5.1)
## 
## [1] C:/Users/Italo/Documents/R/win-library/3.5
## [2] C:/Program Files/R/R-3.5.1/library&lt;/code&gt;&lt;/pre&gt;
&lt;div id=&#34;referencias&#34; class=&#34;section level1 unnumbered&#34;&gt;
&lt;h1&gt;Referências&lt;/h1&gt;
&lt;div id=&#34;refs&#34; class=&#34;references&#34;&gt;
&lt;div id=&#34;ref-alvares2014&#34;&gt;
&lt;p&gt;Alvares, Clayton Alcarde, Italo Ramos Cegatta, Lucas Augusto Abra Vieira, Rafaela de Freitas Pavani, Eduardo Moré Mattos, Paulo Cesar Sentelhas, José Luiz Stape, and Ronaldo Viana Soares. 2014. “Perigo de Incêndio Florestal: Aplicação Da Fórmula de Monte Alegre E Avaliação Do Histórico Para Piracicaba, Sp.” &lt;em&gt;Scientia Forestalis, Piracicaba&lt;/em&gt; 42 (104): 511–22.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;ref-soares1972&#34;&gt;
&lt;p&gt;Soares, Ronaldo Viana. 1972. “Determinação de Um índice de Perigo de Incêndio Para a Região Centro Paranaense, Brasil. Turrialba, Costa Rica, Catie/Iica,. 72 P.” PhD thesis, Tese de Mestrado.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

      </content:encoded>
    </item>
    
    <item>
      <title>Qual Estado tem mais pau-rodado?</title>
      <link>/qual-estado-tem-mais-pau-rodado/</link>
      <pubDate>Sat, 24 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>/qual-estado-tem-mais-pau-rodado/</guid>
      <description>Em Cuiabá, cidade que nasci e cresci, pau-rodado é um substantivo que define pessoas que nasceram em outro Estado mas moram em Cuiabá e ali construíram suas vidas. Aliás, Cuiabá sempre foi conhecida por ser uma Cidade super acolhedora e talvez por isso todos encaram o dito pau-rodado de uma forma engraçada e sem qualquer sentido pejorativo.
Muito bem, meu interesse com este post é analisar o comportamento dos fluxos migratórios entre Estados e assim encontrar os Estados que tem mais e menos pau-rodado em sua população residente.</description>
      <content:encoded>
        


&lt;p&gt;Em Cuiabá, cidade que nasci e cresci, &lt;em&gt;pau-rodado&lt;/em&gt; é um substantivo que define pessoas que nasceram em outro Estado mas moram em Cuiabá e ali construíram suas vidas. Aliás, Cuiabá sempre foi conhecida por ser uma Cidade super acolhedora e talvez por isso todos encaram o dito &lt;em&gt;pau-rodado&lt;/em&gt; de uma forma engraçada e sem qualquer sentido pejorativo.&lt;/p&gt;
&lt;p&gt;Muito bem, meu interesse com este post é analisar o comportamento dos fluxos migratórios entre Estados e assim encontrar os Estados que tem mais e menos &lt;em&gt;pau-rodado&lt;/em&gt; em sua população residente. Serei breve e não vamos abordar todos os Estados, mas se você tiver curiosidade poderá aproveitar o código para uma análise mais ampla.&lt;/p&gt;
&lt;p&gt;A motivação partiu de uma matéria do &lt;a href=&#34;https://www.nexojornal.com.br/grafico/2017/12/01/Fluxos-migrat%C3%B3rios-a-distribui%C3%A7%C3%A3o-da-popula%C3%A7%C3%A3o-de-cada-estado-pelo-pa%C3%ADs&#34;&gt;Nexo Jornal&lt;/a&gt; sobre este tema, porém ao nível estadual. Depois de algumas horas tentando decifrar o site do IBGE, cheguei na &lt;a href=&#34;https://sidra.ibge.gov.br/tabela/1852&#34;&gt;página&lt;/a&gt; que informa a população residente, por lugar de nascimento e unidade da federação.&lt;/p&gt;
&lt;p&gt;Então vamos começar a análise carregando os pacotes do R necessários para este post.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;if (!require(&amp;quot;pacman&amp;quot;)) install.packages(&amp;quot;pacman&amp;quot;)
pacman::p_load(readr, dplyr, tidyr, forcats, sf, geosphere, brmap, ggplot2, ggrepel, geofacet)
pacman::p_load_gh(&amp;quot;italocegatta/brmap&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Os dados originais estão disponíveis neste &lt;a href=&#34;https://sidra.ibge.gov.br/tabela/1852&#34;&gt;link&lt;/a&gt;, fiz apenas adequações porque o IBGE insiste em mesclar células nas tabelas disponibilizadas. Já nesta tabela você consegue olhar para o Estado que você mora e analisar quanto dos residentes nasceram em outros Estados. Mas o objetivo é enxergar isso de forma gráfica para ampliar a percepção dos dados.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;base &amp;lt;- read_csv2(&amp;quot;https://raw.githubusercontent.com/italocegatta/italocegatta.github.io_source/master/content/dados/pnad_2015_migracao.csv&amp;quot;)

base&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 27 x 28
##    Estado Rondônia  Acre Amazonas Roraima  Pará Amapá Tocantins Maranhão
##    &amp;lt;chr&amp;gt;     &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt;    &amp;lt;dbl&amp;gt;   &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt;     &amp;lt;dbl&amp;gt;    &amp;lt;dbl&amp;gt;
##  1 Rondô~    57.4   1.84     1.9     0.08  0.7  NA        0.02      1.02
##  2 Acre       1.54 87.9      3.89    0.02  0.17 NA        0.02      0.11
##  3 Amazo~     0.46  1.6     87.6     0.23  5.36  0.13     0.06      0.87
##  4 Rorai~     0.65  0.24     5.16   55.6   6.54  0.04     0.570    19.0 
##  5 Pará       0.03  0.02     0.49    0.02 84.6   0.19     1.07      6.89
##  6 Amapá      0.1   0.03     0.2     0.17 20.8  72.7      0.1       3.65
##  7 Tocan~     0.07  0.07     0.02   NA     2.83  0.02    69.5       8.58
##  8 Maran~     0.03  0.01     0.05   NA     1.11  0.01     0.32     92.4 
##  9 Piauí      0.04  0.02     0.04    0.05  0.28 NA        0.11      3.97
## 10 Ceará      0.03  0.04     0.11   NA     0.22  0.01     0.03      0.35
## # ... with 17 more rows, and 19 more variables: Piauí &amp;lt;dbl&amp;gt;, Ceará &amp;lt;dbl&amp;gt;,
## #   `Rio Grande do Norte` &amp;lt;dbl&amp;gt;, Paraíba &amp;lt;dbl&amp;gt;, Pernambuco &amp;lt;dbl&amp;gt;,
## #   Alagoas &amp;lt;dbl&amp;gt;, Sergipe &amp;lt;dbl&amp;gt;, Bahia &amp;lt;dbl&amp;gt;, `Minas Gerais` &amp;lt;dbl&amp;gt;,
## #   `Espírito Santo` &amp;lt;dbl&amp;gt;, `Rio de Janeiro` &amp;lt;dbl&amp;gt;, `São Paulo` &amp;lt;dbl&amp;gt;,
## #   Paraná &amp;lt;dbl&amp;gt;, `Santa Catarina` &amp;lt;dbl&amp;gt;, `Rio Grande do Sul` &amp;lt;dbl&amp;gt;, `Mato
## #   Grosso do Sul` &amp;lt;dbl&amp;gt;, `Mato Grosso` &amp;lt;dbl&amp;gt;, Goiás &amp;lt;dbl&amp;gt;, `Distrito
## #   Federal` &amp;lt;dbl&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Dados longitudinais como estes ajudam humanos a enxergar os valores de forma mais fácil, mas do ponto de vista de processamento de dados, não dá pra fazer muita coisa com os dados assim. Vamos organizá-los seguindo a filosofia do &lt;a href=&#34;https://italocegatta.github.io/o-conceito-tidy-data&#34;&gt;Tidy data&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;A nova tabela nos informa a porcentagem da população residente (coluna ‘valor’) para cada Estado, subdividindo os valores por local de nascimento. E agora vai a primeira simplificação: foram selecionados apenas os 6 Estados de nascimento mais representativos para cada Estado de residência.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;df &amp;lt;- base %&amp;gt;% 
  gather(reside, valor, -Estado) %&amp;gt;%
  select(nasce = Estado, reside, valor) %&amp;gt;% 
  replace_na(list(valor = 0)) %&amp;gt;% 
  group_by(nasce) %&amp;gt;% 
  filter(row_number(-valor) &amp;lt;= 6) %&amp;gt;% 
  ungroup()

df&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 162 x 3
##    nasce    reside   valor
##    &amp;lt;chr&amp;gt;    &amp;lt;chr&amp;gt;    &amp;lt;dbl&amp;gt;
##  1 Rondônia Rondônia 57.4 
##  2 Acre     Rondônia  1.54
##  3 Amazonas Rondônia  0.46
##  4 Acre     Acre     87.9 
##  5 Amazonas Acre      1.6 
##  6 Acre     Amazonas  3.89
##  7 Amazonas Amazonas 87.6 
##  8 Roraima  Amazonas  5.16
##  9 Roraima  Roraima  55.6 
## 10 Amazonas Pará      5.36
## # ... with 152 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Vamos nos preparar para a segunda simplificação: selecionar os extremos em termos de população que nasceu e reside no mesmo Estado. Então, RS, CE e PE são os Estados que mais tem moradores nascidos dentro do próprio Estado, enquanto RO, RR e DF tem uma parcela maior de residentes nascidos em outros Estados.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;estados_interesse &amp;lt;- df %&amp;gt;%
  filter(reside == nasce) %&amp;gt;%
  filter(row_number(-valor) &amp;lt;= 3 | row_number(valor) &amp;lt;= 3) %&amp;gt;% 
  arrange(-valor) %&amp;gt;%
  pull(nasce)

estados_interesse&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;Rio Grande do Sul&amp;quot; &amp;quot;Ceará&amp;quot;             &amp;quot;Pernambuco&amp;quot;       
## [4] &amp;quot;Rondônia&amp;quot;          &amp;quot;Roraima&amp;quot;           &amp;quot;Distrito Federal&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Preparando para o mapa, vamos pegar as coordenadas dos centroides de cada Estado.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;estado_cent &amp;lt;- brmap_estado %&amp;gt;% 
  st_centroid() %&amp;gt;% 
  cbind(., st_coordinates(.)) %&amp;gt;% 
  st_set_geometry(NULL) %&amp;gt;% 
  select(estado = estado_nome, lon = X, lat = Y)

estado_cent&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##                 estado       lon        lat
## 1             Rondônia -62.84197 -10.913218
## 2                 Acre -70.47328  -9.212886
## 3             Amazonas -64.65314  -4.154177
## 4              Roraima -61.39928   2.084226
## 5                 Pará -53.06424  -3.974791
## 6                Amapá -51.95592   1.443319
## 7            Tocantins -48.32923 -10.150316
## 8             Maranhão -45.27922  -5.061285
## 9                Piauí -42.96862  -7.387530
## 10               Ceará -39.61569  -5.093345
## 11 Rio Grande do Norte -36.67348  -5.839677
## 12             Paraíba -36.83262  -7.121055
## 13          Pernambuco -37.99843  -8.326066
## 14             Alagoas -36.62494  -9.513863
## 15             Sergipe -37.44390 -10.584475
## 16               Bahia -41.72094 -12.475023
## 17        Minas Gerais -44.67343 -18.456187
## 18      Espírito Santo -40.67106 -19.575176
## 19      Rio de Janeiro -42.65238 -22.188741
## 20           São Paulo -48.73391 -22.263472
## 21              Paraná -51.61668 -24.635899
## 22      Santa Catarina -50.47480 -27.247356
## 23   Rio Grande do Sul -53.32029 -29.705681
## 24  Mato Grosso do Sul -54.84563 -20.327310
## 25         Mato Grosso -55.91215 -12.948967
## 26               Goiás -49.62361 -16.042227
## 27    Distrito Federal -47.79736 -15.780692&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;E agora, o pulo do gato. Vamos criar as linhas que ligam os Estados entre si e em seguida adicionar à tabela que informa as relações de fluxo. Portanto, para cada relação entre Estado de nascimento/residência temos uma feição de linha e o valor que representa a porcentagem de residentes.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;coord &amp;lt;- df %&amp;gt;% 
  left_join(estado_cent, by = c(&amp;quot;nasce&amp;quot; = &amp;quot;estado&amp;quot;)) %&amp;gt;% 
  left_join(estado_cent, by = c(&amp;quot;reside&amp;quot; = &amp;quot;estado&amp;quot;)) %&amp;gt;%
  filter(nasce %in% estados_interesse)

linhas &amp;lt;- gcIntermediate(
  select(coord, lon.x, lat.x), 
  select(coord, lon.y, lat.y), 
  sp = TRUE, addStartEnd = TRUE
  ) %&amp;gt;% 
  st_as_sf()

fluxo_linha &amp;lt;- coord %&amp;gt;% 
  select(nasce, reside, valor) %&amp;gt;% 
  bind_cols(linhas) %&amp;gt;% 
  left_join(estado_cent, by = c(&amp;quot;reside&amp;quot; = &amp;quot;estado&amp;quot;)) %&amp;gt;% 
  mutate(nasce = fct_relevel(nasce, estados_interesse)) %&amp;gt;% 
  st_as_sf()

fluxo_linha&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Simple feature collection with 36 features and 5 fields
## geometry type:  LINESTRING
## dimension:      XY
## bbox:           xmin: -64.65314 ymin: -29.70568 xmax: -36.62494 ymax: 2.084226
## epsg (SRID):    4326
## proj4string:    +proj=longlat +ellps=WGS84 +no_defs
## # A tibble: 36 x 6
##    nasce    reside  valor   lon    lat                             geometry
##    &amp;lt;fct&amp;gt;    &amp;lt;chr&amp;gt;   &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt;                    &amp;lt;LINESTRING [Â°]&amp;gt;
##  1 Rondônia Rondôn~ 57.4  -62.8 -10.9  (-62.84197 -10.91322, -62.84197 -10~
##  2 Roraima  Amazon~  5.16 -64.7  -4.15 (-61.39928 2.084226, -61.46308 1.96~
##  3 Roraima  Roraima 55.6  -61.4   2.08 (-61.39928 2.084226, -61.39928 2.08~
##  4 Roraima  Pará     6.54 -53.1  -3.97 (-61.39928 2.084226, -61.23584 1.96~
##  5 Roraima  Maranh~ 19.0  -45.3  -5.06 (-61.39928 2.084226, -61.08344 1.94~
##  6 Distrit~ Maranh~  4.42 -45.3  -5.06 (-47.79736 -15.78069, -47.74601 -15~
##  7 Ceará    Piauí    0.39 -43.0  -7.39 (-39.61569 -5.093345, -39.68117 -5.~
##  8 Distrit~ Piauí    5.08 -43.0  -7.39 (-47.79736 -15.78069, -47.69952 -15~
##  9 Roraima  Ceará    2.76 -39.6  -5.09 (-61.39928 2.084226, -60.97249 1.94~
## 10 Ceará    Ceará   95.8  -39.6  -5.09 (-39.61569 -5.093345, -39.61569 -5.~
## # ... with 26 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Para deixar o gráfico um pouco mais bonito, vamos dar cor ao valor que estamos estudando. Mas agora a feição será o polígono que representa o Estado de residentes.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;fluxo_poligono &amp;lt;- brmap_estado %&amp;gt;% 
  left_join(df, by =  c(&amp;quot;estado_nome&amp;quot; = &amp;quot;reside&amp;quot;)) %&amp;gt;% 
  rename(reside = estado_nome) %&amp;gt;% 
  filter(nasce %in% estados_interesse) %&amp;gt;% 
  mutate(nasce = fct_relevel(nasce, estados_interesse)) %&amp;gt;% 
  select(nasce, reside, valor)

fluxo_poligono&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Simple feature collection with 36 features and 3 fields
## geometry type:  POLYGON
## dimension:      XY
## bbox:           xmin: -73.80156 ymin: -33.75118 xmax: -34.79288 ymax: 5.271841
## epsg (SRID):    4674
## proj4string:    +proj=longlat +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +no_defs
## # A tibble: 36 x 4
##    nasce       reside  valor                                       geometry
##    &amp;lt;fct&amp;gt;       &amp;lt;chr&amp;gt;   &amp;lt;dbl&amp;gt;                                 &amp;lt;POLYGON [Â°]&amp;gt;
##  1 Rondônia    Rondôn~ 57.4  ((-62.86662 -7.975868, -62.86017 -7.982323, -~
##  2 Roraima     Amazon~  5.16 ((-67.32609 2.029714, -67.31682 2.00125, -67.~
##  3 Roraima     Roraima 55.6  ((-60.20051 5.264343, -60.19828 5.260453, -60~
##  4 Roraima     Pará     6.54 ((-54.95431 2.583692, -54.93542 2.518585, -54~
##  5 Roraima     Maranh~ 19.0  ((-45.84073 -1.045485, -45.84099 -1.046971, -~
##  6 Distrito F~ Maranh~  4.42 ((-45.84073 -1.045485, -45.84099 -1.046971, -~
##  7 Ceará       Piauí    0.39 ((-41.74605 -2.803497, -41.74241 -2.805697, -~
##  8 Distrito F~ Piauí    5.08 ((-41.74605 -2.803497, -41.74241 -2.805697, -~
##  9 Roraima     Ceará    2.76 ((-40.49717 -2.784509, -40.49173 -2.788106, -~
## 10 Ceará       Ceará   95.8  ((-40.49717 -2.784509, -40.49173 -2.788106, -~
## # ... with 26 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Pronto, já temos todos os dados que fazer o gráfico de interesse. Lembrando que optamos por dar destaque a 6 Estados e para cada um deles, os 6 Estados de nascimento que mais representam a população de residentes. Sim, é um tanto complexo. Eu fiquei algumas horas para poder criar o código e entender o que estava processando.&lt;/p&gt;
&lt;p&gt;Como exemplo vamos interpretar as informações de Roraima: do total de residentes, 55.6% nasceram no próprio Estado de Roraima; 5.2%, 6.5% e 19% nasceram no Amazonas, Pará e Maranhão, respectivamente.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggplot() +
  geom_sf(data = brmap_estado, color = &amp;quot;white&amp;quot;, fill = &amp;quot;grey80&amp;quot;, size = 0.3) +
  geom_sf(data = fluxo_poligono, aes(fill = valor), color = &amp;quot;white&amp;quot;, size = 0.3) +
  geom_sf(data = fluxo_linha, color = &amp;quot;cyan&amp;quot;, size = 0.3) +
  geom_label_repel(
    data = fluxo_linha,
    aes(lon, lat, label = round(valor, 1)),
    size = 3, segment.colour = NA
  ) +
  facet_wrap(~nasce) +
  labs(
    title = &amp;quot;População residente (% do total geral)&amp;quot;,
    subtitle = &amp;quot;PNAD/IBGE, 2015&amp;quot;,
    x = NULL, y = NULL
  ) +
  scale_fill_viridis_c(guide = FALSE) +
  coord_sf(datum = NA) +
  theme_void(16)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2018-03-24-qual-estado-tem-mais-pau-rodado_files/figure-html/unnamed-chunk-9-1.svg&#34; width=&#34;960&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Pontos interessantes:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Rondônia e Roraima retém uma proporção parecida da população dentro do próprio Estado, entretanto o pessoal que mora em Rondônia veio do Sul e Sudeste; ao passo que os moradores de Roraima vêm do AM, PA e MA.&lt;/li&gt;
&lt;li&gt;O Distrito Federal não me surpreendeu, grande parte de pessoas nasceram em GO, MG e BA.&lt;/li&gt;
&lt;li&gt;Um número expressivo de pessoas que nasceram em São Paulo e hoje moram no CE e PE… parece que o jogo virou, não é mesmo?&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Caso tenha alguma dúvida ou sugestão sobre o post, fique à vontade para fazer um comentário ou me contatar por E-mail.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;sessioninfo::session_info(c(&amp;quot;readr&amp;quot;, &amp;quot;dplyr&amp;quot;, &amp;quot;ggplot2&amp;quot;, &amp;quot;tidyr&amp;quot;, &amp;quot;forcats&amp;quot;, &amp;quot;sf&amp;quot;, &amp;quot;geosphere&amp;quot;, &amp;quot;ggrepel&amp;quot;, &amp;quot;geofacet&amp;quot;, &amp;quot;brmap&amp;quot;))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## - Session info ----------------------------------------------------------
##  setting  value                       
##  version  R version 3.5.1 (2018-07-02)
##  os       Windows 10 x64              
##  system   x86_64, mingw32             
##  ui       RTerm                       
##  language (EN)                        
##  collate  Portuguese_Brazil.1252      
##  ctype    Portuguese_Brazil.1252      
##  tz       America/Sao_Paulo           
##  date     2018-12-31                  
## 
## - Packages --------------------------------------------------------------
##  package       * version     date       lib
##  assertthat      0.2.0       2017-04-11 [1]
##  BH              1.66.0-1    2018-02-13 [1]
##  bindr           0.1.1       2018-03-13 [1]
##  bindrcpp      * 0.2.2       2018-03-29 [1]
##  brmap         * 0.0.5       2018-09-16 [1]
##  class           7.3-14      2015-08-30 [2]
##  classInt        0.3-1       2018-12-18 [1]
##  cli             1.0.1       2018-09-25 [1]
##  clipr           0.4.1       2018-06-23 [1]
##  colorspace      1.3-2       2016-12-14 [1]
##  crayon          1.3.4       2017-09-16 [1]
##  curl            3.2         2018-03-28 [1]
##  DBI             1.0.0       2018-05-02 [1]
##  digest          0.6.18      2018-10-10 [1]
##  dplyr         * 0.7.8       2018-11-10 [1]
##  e1071           1.7-0       2018-07-28 [1]
##  fansi           0.4.0       2018-10-05 [1]
##  forcats       * 0.3.0       2018-02-19 [1]
##  geofacet      * 0.1.9       2018-03-29 [1]
##  geogrid         0.1.1       2018-12-11 [1]
##  geosphere     * 1.5-7       2017-11-05 [1]
##  ggplot2       * 3.1.0       2018-10-25 [1]
##  ggrepel       * 0.8.0       2018-05-09 [1]
##  glue            1.3.0       2018-07-17 [1]
##  gridExtra       2.3         2017-09-09 [1]
##  gtable          0.2.0       2016-02-26 [1]
##  hms             0.4.2       2018-03-10 [1]
##  httr            1.4.0       2018-12-11 [1]
##  imguR           1.0.3       2016-03-29 [1]
##  jpeg            0.1-8       2014-01-23 [1]
##  jsonlite        1.6         2018-12-07 [1]
##  labeling        0.3         2014-08-23 [1]
##  lattice         0.20-35     2017-03-25 [2]
##  lazyeval        0.2.1       2017-10-29 [1]
##  magrittr        1.5         2014-11-22 [1]
##  MASS            7.3-50      2018-04-30 [2]
##  Matrix          1.2-14      2018-04-13 [2]
##  mgcv            1.8-24      2018-06-23 [2]
##  mime            0.6         2018-10-05 [1]
##  munsell         0.5.0       2018-06-12 [1]
##  nlme            3.1-137     2018-04-07 [2]
##  openssl         1.1         2018-11-15 [1]
##  pillar          1.3.1       2018-12-15 [1]
##  pkgconfig       2.0.2       2018-08-16 [1]
##  plogr           0.2.0       2018-03-25 [1]
##  plyr            1.8.4       2016-06-08 [1]
##  png             0.1-7       2013-12-03 [1]
##  purrr           0.2.5       2018-05-29 [1]
##  R6              2.3.0       2018-10-04 [1]
##  RColorBrewer    1.1-2       2014-12-07 [1]
##  Rcpp            1.0.0       2018-11-07 [1]
##  RcppArmadillo   0.9.200.5.0 2018-11-28 [1]
##  readr         * 1.3.1       2018-12-21 [1]
##  reshape2        1.4.3       2017-12-11 [1]
##  rgeos           0.4-2       2018-11-08 [1]
##  rlang           0.3.0.1     2018-10-25 [1]
##  rnaturalearth   0.1.0       2017-03-21 [1]
##  scales          1.0.0       2018-08-09 [1]
##  sf            * 0.7-2       2018-12-20 [1]
##  sp              1.3-1       2018-06-05 [1]
##  stringi         1.2.4       2018-07-20 [1]
##  stringr         1.3.1       2018-05-10 [1]
##  tibble          1.4.2       2018-01-22 [1]
##  tidyr         * 0.8.2       2018-10-28 [1]
##  tidyselect      0.2.5       2018-10-11 [1]
##  units           0.6-2       2018-12-05 [1]
##  utf8            1.1.4       2018-05-24 [1]
##  viridisLite     0.3.0       2018-02-01 [1]
##  withr           2.1.2       2018-03-15 [1]
##  source                             
##  CRAN (R 3.5.1)                     
##  CRAN (R 3.5.0)                     
##  CRAN (R 3.5.1)                     
##  CRAN (R 3.5.1)                     
##  Github (italocegatta/brmap@181fc73)
##  CRAN (R 3.5.1)                     
##  CRAN (R 3.5.2)                     
##  CRAN (R 3.5.1)                     
##  CRAN (R 3.5.1)                     
##  CRAN (R 3.5.1)                     
##  CRAN (R 3.5.1)                     
##  CRAN (R 3.5.1)                     
##  CRAN (R 3.5.1)                     
##  CRAN (R 3.5.1)                     
##  CRAN (R 3.5.1)                     
##  CRAN (R 3.5.1)                     
##  CRAN (R 3.5.1)                     
##  CRAN (R 3.5.1)                     
##  CRAN (R 3.5.2)                     
##  CRAN (R 3.5.2)                     
##  CRAN (R 3.5.2)                     
##  CRAN (R 3.5.1)                     
##  CRAN (R 3.5.1)                     
##  CRAN (R 3.5.1)                     
##  CRAN (R 3.5.1)                     
##  CRAN (R 3.5.1)                     
##  CRAN (R 3.5.1)                     
##  CRAN (R 3.5.2)                     
##  CRAN (R 3.5.1)                     
##  CRAN (R 3.5.0)                     
##  CRAN (R 3.5.2)                     
##  CRAN (R 3.5.0)                     
##  CRAN (R 3.5.1)                     
##  CRAN (R 3.5.1)                     
##  CRAN (R 3.5.1)                     
##  CRAN (R 3.5.1)                     
##  CRAN (R 3.5.1)                     
##  CRAN (R 3.5.1)                     
##  CRAN (R 3.5.1)                     
##  CRAN (R 3.5.1)                     
##  CRAN (R 3.5.1)                     
##  CRAN (R 3.5.1)                     
##  CRAN (R 3.5.2)                     
##  CRAN (R 3.5.1)                     
##  CRAN (R 3.5.1)                     
##  CRAN (R 3.5.1)                     
##  CRAN (R 3.5.0)                     
##  CRAN (R 3.5.1)                     
##  CRAN (R 3.5.1)                     
##  CRAN (R 3.5.0)                     
##  CRAN (R 3.5.1)                     
##  CRAN (R 3.5.2)                     
##  CRAN (R 3.5.2)                     
##  CRAN (R 3.5.1)                     
##  CRAN (R 3.5.1)                     
##  CRAN (R 3.5.1)                     
##  CRAN (R 3.5.1)                     
##  CRAN (R 3.5.1)                     
##  CRAN (R 3.5.2)                     
##  CRAN (R 3.5.1)                     
##  CRAN (R 3.5.1)                     
##  CRAN (R 3.5.1)                     
##  CRAN (R 3.5.1)                     
##  CRAN (R 3.5.1)                     
##  CRAN (R 3.5.1)                     
##  CRAN (R 3.5.2)                     
##  CRAN (R 3.5.1)                     
##  CRAN (R 3.5.1)                     
##  CRAN (R 3.5.1)                     
## 
## [1] C:/Users/Italo/Documents/R/win-library/3.5
## [2] C:/Program Files/R/R-3.5.1/library&lt;/code&gt;&lt;/pre&gt;

      </content:encoded>
    </item>
    
    <item>
      <title>Índice de uniformidade (PV50)</title>
      <link>/indice-de-uniformidade-pv50/</link>
      <pubDate>Sun, 09 Oct 2016 00:00:00 +0000</pubDate>
      
      <guid>/indice-de-uniformidade-pv50/</guid>
      <description>O PV50 é hoje o índice mais utilizado quando queremos expressar a uniformidade de um plantio florestal. Hakamada (2012) apresentou um estudo detalhado sobre diversos índices e concluiu que o PV50 é o índice mais indicado para explicar a relação entre uniformidade, qualidade silvicultural e produtividade em plantios homogêneos de Eucalyptus.
O objetivo deste post é mostrar, passo a passo, como calcular este índice no R e fazer uma breve análise de seus resultados.</description>
      <content:encoded>
        


&lt;p&gt;O PV50 é hoje o índice mais utilizado quando queremos expressar a uniformidade de um plantio florestal. &lt;span class=&#34;citation&#34;&gt;Hakamada (&lt;a href=&#34;#ref-Hakamada2012&#34;&gt;2012&lt;/a&gt;)&lt;/span&gt; apresentou um estudo detalhado sobre diversos índices e concluiu que o PV50 é o índice mais indicado para explicar a relação entre uniformidade, qualidade silvicultural e produtividade em plantios homogêneos de &lt;em&gt;Eucalyptus&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;O objetivo deste post é mostrar, passo a passo, como calcular este índice no R e fazer uma breve análise de seus resultados.&lt;/p&gt;
&lt;p&gt;O PV50 é a porcentagem de volume acumulado das 50% menores árvores do seu conjunto de dados, considerando as falhas de plantio e árvores mortas &lt;span class=&#34;citation&#34;&gt;(Hakamada et al. &lt;a href=&#34;#ref-Hakamada2015&#34;&gt;2015&lt;/a&gt;)&lt;/span&gt;. A expressão do índice é dada da seguinte forma:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.sciweavers.org/tex2img.php?eq=PV50%20%3D%20%5Cfrac%7B%5Csum_%7Bk%3D1%7D%5E%7B%5Cfrac%7Bn%7D%7B2%7D%7DV_%7Bij%7D%7D%7B%5Csum_%7Bk%3D1%7D%5E%7Bn%7DV_%7Bij%7D%7D&amp;bc=White&amp;fc=Black&amp;im=jpg&amp;fs=12&amp;ff=arev&amp;edit=0&#34; align=&#34;center&#34; border=&#34;0&#34; alt=&#34;PV50 = \frac{\sum_{k=1}^{\frac{n}{2}}V_{ij}}{\sum_{k=1}^{n}V_{ij}}&#34; width=&#34;139&#34; height=&#34;62&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Onde: PV50 = porcentagem acumulada do volume das 50% menores árvores plantadas; V = volume da árvore i; n = número de árvores plantadas ordenadas (da menor para a maior).&lt;/p&gt;
&lt;p&gt;Primeiro vamos entender os cálculos do índice, considerando apenas 10 árvores hipotéticas com 0,1 metros cúbicos de volume.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# carrega os pacotes necessários
if (!require(&amp;quot;pacman&amp;quot;)) install.packages(&amp;quot;pacman&amp;quot;)
pacman::p_load(readr, dplyr, ggplot2, forcats)&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# exemplo com número par
arv10 &amp;lt;- rep(0.1, 10)
str(arv10)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  num [1:10] 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Este é o referencial teórico de uniformidade, todas as árvores do mesmo tamanho. Sem precisar fazer conta, sabemos que o volume das 50% menores árvores é igual a 50% do volume total, o que equivale a um PV50 = 50.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# identifica a metade do numero de árvores
metade &amp;lt;- length(arv10)/2
metade&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 5&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# soma todas as árvores
soma_todas &amp;lt;- sum(arv10, na.rm = TRUE)
soma_todas&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 1&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# soma o valor de metade das árvores em ordem crescente
soma_metade &amp;lt;- sum(sort(arv10)[1:metade], na.rm = TRUE)
soma_metade&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 0.5&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# calcula o PV50
PV50 &amp;lt;- soma_metade / soma_todas * 100
PV50&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 50&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Agora vamos simular 11 árvores com o mesmo volume, veja o que acontece.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# exemplo com número impar
arv11 &amp;lt;- rep(0.1, 11)
str(arv11)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  num [1:11] 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 ...&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# metade do numero de árvores
metade &amp;lt;- length(arv11)/2
metade&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 5.5&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# soma todas as árvores
soma_todas &amp;lt;- sum(arv11, na.rm = TRUE)
soma_todas&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 1.1&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# soma o valor de metade das árvores em ordem crescente
soma_metade &amp;lt;- sum(sort(arv11)[1:metade], na.rm = TRUE)
soma_metade&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 0.5&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# calcula o PV50
PV50 &amp;lt;- soma_metade / soma_todas * 100
PV50&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 45.45455&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;O resultado deveria ser 50, mas como o número de árvores é ímpar, o R arredonda a posição 5,5 para 5 e pega até a quinta árvore no momento em que queremos somar as 50% menores. Para contornar isso, vamos calcular a soma das 50% menores árvores de uma forma diferente. Primeiro calculamos a soma acumulada e depois extraímos a média (semelhante ao modo de se calcular uma mediana).&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# vetor de soma acumulada
soma_acumulada &amp;lt;- cumsum(sort(arv11))
soma_acumulada&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  [1] 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0 1.1&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# soma a metade do vetor de soma acumulada
soma_metade &amp;lt;- mean(soma_acumulada[metade + 0L:1L], na.rm = TRUE)
soma_metade&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 0.55&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# calcula o PV50
PV50 &amp;lt;- soma_metade / soma_todas * 100
PV50&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 50&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Agora que a questão do número de árvores foi superada, podemos incluir árvores mortas, o que equivale a elementos do tipo &lt;code&gt;NA&lt;/code&gt; no R. Veja que o resultado não está consistente pois a &lt;code&gt;soma_acumulada&lt;/code&gt; ignorou as árvores mortas.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# exemplo com valores perdidos
arv11_na &amp;lt;- rep(0.1, 11)
arv11_na[c(3,4)] &amp;lt;- NA
str(arv11_na)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  num [1:11] 0.1 0.1 NA NA 0.1 0.1 0.1 0.1 0.1 0.1 ...&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# metade do numero de árvores
metade &amp;lt;- length(arv11_na)/2
metade&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 5.5&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# soma todas as árvores
soma_todas &amp;lt;- sum(arv11_na, na.rm = TRUE)
soma_todas&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 0.9&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# vetor de soma acumulada
soma_acumulada &amp;lt;- cumsum(sort(arv11_na))
soma_acumulada&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# soma a metade do vetor de soma acumulada
soma_metade &amp;lt;- mean(soma_acumulada[metade + 0L:1L], na.rm = TRUE)
soma_metade&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 0.55&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# calcula o PV50
PV50 &amp;lt;- soma_metade / soma_todas * 100
PV50&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 61.11111&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Para corrigir este o erro, temos de incluir manualmente as árvores mortas na sequência. Veja que agora o resultado está de acordo com o esperado.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# vetor de valores perdidos
mortas &amp;lt;- arv11_na[is.na(arv11_na)]
mortas&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] NA NA&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# metade do numero de árvores
metade &amp;lt;- length(arv11_na)/2
metade&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 5.5&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# soma todas as árvores
soma_todas &amp;lt;- sum(arv11_na, na.rm = TRUE)
soma_todas&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 0.9&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# vetor de soma acumulada com valores perdidos
soma_acumulada &amp;lt;- c(mortas, cumsum(sort(arv11_na)))
soma_acumulada&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  [1]  NA  NA 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# soma a metade do vetor de soma acumulada
soma_metade &amp;lt;- mean(soma_acumulada[metade + 0L:1L], na.rm = TRUE)
soma_metade&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 0.35&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# calcula o PV50
PV50 &amp;lt;- soma_metade / soma_todas * 100
PV50&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 38.88889&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Agora eu vou dar aquele passo mágico dos livros de matemática e física, em que o autor diz “é fácil notar que o resultado leva a …” e apresentar uma função que lida com as questões que mostramos acima e retorna o PV50 do nosso conjunto de dados de forma correta.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;pv50 &amp;lt;- function(x) {
  
  mortas &amp;lt;- x[is.na(x)]
  
  metade &amp;lt;- length(x)/2
  
  soma_todas &amp;lt;- sum(x, na.rm = TRUE)
  
  soma_acumulada &amp;lt;- c(mortas, cumsum(sort(x)))
  
  if (metade%%2L == 1L)
    soma_metade &amp;lt;- mean(soma_acumulada[metade], na.rm = TRUE)
  else
    soma_metade &amp;lt;- mean(soma_acumulada[metade + 0L:1L], na.rm = TRUE)
  
  z &amp;lt;- soma_metade / soma_todas * 100
  
  return(z)
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Podemos rapidamente verificar se os resultados estão consistentes fazendo alguns testes.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;a &amp;lt;- rep(10, 10)
str(a)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  num [1:10] 10 10 10 10 10 10 10 10 10 10&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;pv50(a) # Ok!&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 50&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;a1 &amp;lt;- rep(10 ,11)
str(a1)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  num [1:11] 10 10 10 10 10 10 10 10 10 10 ...&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;pv50(a1) # Ok!&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 50&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;b &amp;lt;- a
b[c(3, 7)] &amp;lt;- NA
str(b)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  num [1:10] 10 10 NA 10 10 10 NA 10 10 10&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;pv50(b) # Ok!&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 37.5&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;b1 &amp;lt;- a1
b1[c(3, 7)] &amp;lt;- NA
str(b1)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  num [1:11] 10 10 NA 10 10 10 NA 10 10 10 ...&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;pv50(b1) # Ok!&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 38.88889&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Boa, já temos uma função para calcular o PV50 e podemos aplicá-la em um conjunto de dados para podermos interpretar. Utilizaremos mais uma vez os dados do &lt;a href=&#34;www.projetotume.com&#34;&gt;Projeto TUME&lt;/a&gt;, referente ao &lt;a href=&#34;http://www.projetotume.com/tume134&#34;&gt;TUME 134&lt;/a&gt; plantado em Piracicaba-SP. O volume individual foi calculado arbitrariamente utilizando o fator de forma 0,5.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# importa o arquivo tume_55.csv
dados &amp;lt;- read_csv2(
  &amp;quot;https://github.com/italocegatta/italocegatta.github.io_source/raw/master/content/dados/tume_55.csv&amp;quot;
)

glimpse(dados)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Observations: 1,222
## Variables: 7
## $ Esp     &amp;lt;chr&amp;gt; &amp;quot;E_camaldulensis&amp;quot;, &amp;quot;E_camaldulensis&amp;quot;, &amp;quot;E_camaldulensis...
## $ I_meses &amp;lt;dbl&amp;gt; 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34...
## $ Parc_m2 &amp;lt;dbl&amp;gt; 288, 288, 288, 288, 288, 288, 288, 288, 288, 288, 288,...
## $ N_arv   &amp;lt;dbl&amp;gt; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16,...
## $ DAP_cm  &amp;lt;dbl&amp;gt; 5.411268, 12.254931, 3.978874, 6.429860, 9.676621, 5.6...
## $ H_m     &amp;lt;dbl&amp;gt; 7.651490, 11.424046, 5.909205, 8.572873, 10.498957, 7....
## $ Vol     &amp;lt;dbl&amp;gt; 0.008798406, 0.067375427, 0.003673747, 0.013918399, 0....&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Iremos calcular o PV50 e o volume por hectare para cada fator &lt;code&gt;Esp&lt;/code&gt; e &lt;code&gt;I_meses&lt;/code&gt; e em seguida ordenar as espécies pelo PV50.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# agrupa os dados em função de espécie e idade para 
# calcular o pv50 e o volume
dados_pv50 &amp;lt;- dados %&amp;gt;% 
  group_by(Esp, I_meses) %&amp;gt;% 
  summarise(
    Parc_m2 = mean( Parc_m2),
    PV50 = pv50(Vol),
    Vol_ha = sum(Vol, na.rm = TRUE) * (10000/Parc_m2)
  ) %&amp;gt;%
  ungroup() %&amp;gt;% 
  # ordena o fator de espécies de forma decrescente em função do pv50
  mutate(Esp = fct_reorder(Esp, -PV50))

dados_pv50&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 20 x 5
##    Esp                 I_meses Parc_m2  PV50 Vol_ha
##    &amp;lt;fct&amp;gt;                 &amp;lt;dbl&amp;gt;   &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt;
##  1 E_camaldulensis          34     288  21.4   47.5
##  2 E_camaldulensis          46     288  14.3   79.1
##  3 E_camaldulensis          60     600  13.2  110. 
##  4 E_camaldulensis          85     288  12.7  204. 
##  5 E_citriodora             34     288  17.8   46.6
##  6 E_citriodora             46     288  16.4   85.0
##  7 E_citriodora             60     600  12.5   97.0
##  8 E_citriodora             85     288  12.7  205. 
##  9 E_dunnii                 34     288  28.6  103. 
## 10 E_dunnii                 46     288  29.2  161. 
## 11 E_dunnii                 60     600  27.5  198. 
## 12 E_dunnii                 85     288  26.4  350. 
## 13 E_paniculata             34     288  27.4   46.4
## 14 E_paniculata             46     288  24.1   84.4
## 15 E_paniculata             60     600  19.6  115. 
## 16 E_paniculata             85     288  18.2  195. 
## 17 E_urophylla_grandis      34     288  26.3   85.7
## 18 E_urophylla_grandis      46     288  24.2  157. 
## 19 E_urophylla_grandis      60     600  20.3  217. 
## 20 E_urophylla_grandis      85     288  17.9  277.&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Para entendermos os dados, vamos primeiro ver o crescimento em volume de cada espécies em função do tempo (Figura &lt;a href=&#34;#fig:12-vol-idade&#34;&gt;1&lt;/a&gt;). Note que &lt;em&gt;E. dunnii&lt;/em&gt; e &lt;em&gt;E. urophylla&lt;/em&gt; x &lt;em&gt;E. grandis&lt;/em&gt; tinham crescimento muito parecido até os 60 meses de idade.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggplot(dados_pv50, aes(I_meses, Vol_ha, color = Esp)) +
  geom_point() +
  geom_line() +
  labs(
    color = &amp;quot;Espécies&amp;quot;,
    x = &amp;quot;Idade (meses)&amp;quot;,
    y = Volume~m^3~ha^-1
  ) +
  scale_color_brewer(palette = &amp;quot;Set1&amp;quot;) +
  theme_bw(16) +
  theme(legend.justification = &amp;quot;top&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;figure&#34;&gt;&lt;span id=&#34;fig:12-vol-idade&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;/post/2016-10-09-indice-de-uniformidade-pv50_files/figure-html/12-vol-idade-1.svg&#34; alt=&#34;Crescimento em volume por hectare em função da idade.&#34; width=&#34;960&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figura  1: Crescimento em volume por hectare em função da idade.
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Agora podemos construir um gráfico que relaciona o PV50 e a idade (Figura &lt;a href=&#34;#fig:12-pv50-idade&#34;&gt;2&lt;/a&gt;). A interpretação do índice é simples, o PV50 representa a porcentagem em volume que as 50% menores árvores contribuem para o volume total. Em nossos dados, &lt;em&gt;E. dunnii&lt;/em&gt;, aos 85 meses de idade, tem um PV50 de aproximadamente 26. Isso quer dizer que aos 7 anos, as 50% menores árvores da parcela de &lt;em&gt;E. dunnii&lt;/em&gt; representam apenas 26% do volume total. Ou seja, 50% das árvores contribuem muito pouco para o volume total da parcela e isso tem um impacto direto na produtividade.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggplot(dados_pv50, aes(I_meses, PV50, color = Esp)) +
  geom_point() +
  geom_line() +
  labs(color = &amp;quot;Espécies&amp;quot;, x = &amp;quot;Idade (meses)&amp;quot;, y = &amp;quot;PV50&amp;quot;) +
  scale_color_brewer(palette = &amp;quot;Set1&amp;quot;) +
  scale_y_continuous(breaks = seq(10, 30, 2)) +
  theme_bw(16) +
  theme(legend.justification = &amp;quot;top&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;figure&#34;&gt;&lt;span id=&#34;fig:12-pv50-idade&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;/post/2016-10-09-indice-de-uniformidade-pv50_files/figure-html/12-pv50-idade-1.svg&#34; alt=&#34;Variação do PV50 por espécies em função da idade.&#34; width=&#34;960&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figura  2: Variação do PV50 por espécies em função da idade.
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;A Figura &lt;a href=&#34;#fig:12-pv50-vol&#34;&gt;3&lt;/a&gt; mostra claramente a relação direta que há entre produção de madeira e a uniformidade ao longo do crescimento da floresta. Note também que na medida em que a idade avança, a uniformidade diminui, uma vez que a dominância das árvores maiores sobre as menores fica cada vez mais forte.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggplot(dados_pv50, aes(Vol_ha, PV50)) +
  geom_point(aes(color = factor(I_meses))) +
  geom_smooth(method = &amp;quot;lm&amp;quot;, formula = y ~x, se = FALSE) +
  facet_wrap(~Esp, dir = &amp;quot;v&amp;quot;) +
  labs(color = &amp;quot;Idade (meses)&amp;quot;, x = Volume~m^3~ha^-1, y = &amp;quot;PV50&amp;quot;) +
  scale_color_brewer(palette = &amp;quot;Dark2&amp;quot;) +
  theme_bw(16) +
  theme(legend.justification = &amp;quot;top&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;figure&#34;&gt;&lt;span id=&#34;fig:12-pv50-vol&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;/post/2016-10-09-indice-de-uniformidade-pv50_files/figure-html/12-pv50-vol-1.svg&#34; alt=&#34;Relação entre o PV50 e volume por hectare em função da idade.&#34; width=&#34;960&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figura  3: Relação entre o PV50 e volume por hectare em função da idade.
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Por fim, para colocar tudo em um só gráfico, podemos adicionar ao gráfico de crescimento em volume a informação do PV50 para evidenciar que as espécies mais produtivas tem PV50 elevado e que este índice consegue explicar muito bem essa relação (Figura &lt;a href=&#34;#fig:12-vol-pv50-idade&#34;&gt;4&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;Um comentário interessante é que dentre as espécies que estamos estudando, todas são de origem seminal, com exceção do &lt;em&gt;E. dunnii&lt;/em&gt;, que é um clone. Este fator explica sua produtividade e alta homogeneidade, principalmente frente ao hibrido de &lt;em&gt;E. urophylla&lt;/em&gt; x &lt;em&gt;E. grandis&lt;/em&gt;, que é seu concorrente direto. Quando estivermos analisando dados de plantios clonais, o PV50 vai expressar a qualidade silvicultural do plantio, uma vez que a base genética é a mesma em todas as plantas.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggplot(dados_pv50, aes(I_meses, Vol_ha, color = Esp)) +
  geom_point(aes(size = PV50), alpha = 0.4) +
  geom_line() +
  labs(
    color = &amp;quot;Espécies&amp;quot;,
    x = &amp;quot;Idade (meses)&amp;quot;,
    y = Volume~m^3~ha^-1
  ) +
  scale_color_brewer(palette = &amp;quot;Set1&amp;quot;) +
  theme_bw(16) +
  theme(legend.justification = &amp;quot;top&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;figure&#34;&gt;&lt;span id=&#34;fig:12-vol-pv50-idade&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;/post/2016-10-09-indice-de-uniformidade-pv50_files/figure-html/12-vol-pv50-idade-1.svg&#34; alt=&#34;Crescimento do volume em função da idade, com informação do PV50 no tamanho do ponto.&#34; width=&#34;960&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figura  4: Crescimento do volume em função da idade, com informação do PV50 no tamanho do ponto.
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Caso tenha alguma dúvida ou sugestão sobre o post, fique à vontade para fazer um comentário ou me contatar por E-mail.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;sessioninfo::session_info(c(&amp;quot;readr&amp;quot;, &amp;quot;dplyr&amp;quot;, &amp;quot;ggplot2&amp;quot;, &amp;quot;forcats&amp;quot;))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## - Session info ----------------------------------------------------------
##  setting  value                       
##  version  R version 3.5.1 (2018-07-02)
##  os       Windows 10 x64              
##  system   x86_64, mingw32             
##  ui       RTerm                       
##  language (EN)                        
##  collate  Portuguese_Brazil.1252      
##  ctype    Portuguese_Brazil.1252      
##  tz       America/Sao_Paulo           
##  date     2018-12-31                  
## 
## - Packages --------------------------------------------------------------
##  package      * version  date       lib source        
##  assertthat     0.2.0    2017-04-11 [1] CRAN (R 3.5.1)
##  BH             1.66.0-1 2018-02-13 [1] CRAN (R 3.5.0)
##  bindr          0.1.1    2018-03-13 [1] CRAN (R 3.5.1)
##  bindrcpp     * 0.2.2    2018-03-29 [1] CRAN (R 3.5.1)
##  cli            1.0.1    2018-09-25 [1] CRAN (R 3.5.1)
##  clipr          0.4.1    2018-06-23 [1] CRAN (R 3.5.1)
##  colorspace     1.3-2    2016-12-14 [1] CRAN (R 3.5.1)
##  crayon         1.3.4    2017-09-16 [1] CRAN (R 3.5.1)
##  digest         0.6.18   2018-10-10 [1] CRAN (R 3.5.1)
##  dplyr        * 0.7.8    2018-11-10 [1] CRAN (R 3.5.1)
##  fansi          0.4.0    2018-10-05 [1] CRAN (R 3.5.1)
##  forcats      * 0.3.0    2018-02-19 [1] CRAN (R 3.5.1)
##  ggplot2      * 3.1.0    2018-10-25 [1] CRAN (R 3.5.1)
##  glue           1.3.0    2018-07-17 [1] CRAN (R 3.5.1)
##  gtable         0.2.0    2016-02-26 [1] CRAN (R 3.5.1)
##  hms            0.4.2    2018-03-10 [1] CRAN (R 3.5.1)
##  labeling       0.3      2014-08-23 [1] CRAN (R 3.5.0)
##  lattice        0.20-35  2017-03-25 [2] CRAN (R 3.5.1)
##  lazyeval       0.2.1    2017-10-29 [1] CRAN (R 3.5.1)
##  magrittr       1.5      2014-11-22 [1] CRAN (R 3.5.1)
##  MASS           7.3-50   2018-04-30 [2] CRAN (R 3.5.1)
##  Matrix         1.2-14   2018-04-13 [2] CRAN (R 3.5.1)
##  mgcv           1.8-24   2018-06-23 [2] CRAN (R 3.5.1)
##  munsell        0.5.0    2018-06-12 [1] CRAN (R 3.5.1)
##  nlme           3.1-137  2018-04-07 [2] CRAN (R 3.5.1)
##  pillar         1.3.1    2018-12-15 [1] CRAN (R 3.5.2)
##  pkgconfig      2.0.2    2018-08-16 [1] CRAN (R 3.5.1)
##  plogr          0.2.0    2018-03-25 [1] CRAN (R 3.5.1)
##  plyr           1.8.4    2016-06-08 [1] CRAN (R 3.5.1)
##  purrr          0.2.5    2018-05-29 [1] CRAN (R 3.5.1)
##  R6             2.3.0    2018-10-04 [1] CRAN (R 3.5.1)
##  RColorBrewer   1.1-2    2014-12-07 [1] CRAN (R 3.5.0)
##  Rcpp           1.0.0    2018-11-07 [1] CRAN (R 3.5.1)
##  readr        * 1.2.1    2018-11-22 [1] CRAN (R 3.5.1)
##  reshape2       1.4.3    2017-12-11 [1] CRAN (R 3.5.1)
##  rlang          0.3.0.1  2018-10-25 [1] CRAN (R 3.5.1)
##  scales         1.0.0    2018-08-09 [1] CRAN (R 3.5.1)
##  stringi        1.2.4    2018-07-20 [1] CRAN (R 3.5.1)
##  stringr        1.3.1    2018-05-10 [1] CRAN (R 3.5.1)
##  tibble         1.4.2    2018-01-22 [1] CRAN (R 3.5.1)
##  tidyselect     0.2.5    2018-10-11 [1] CRAN (R 3.5.1)
##  utf8           1.1.4    2018-05-24 [1] CRAN (R 3.5.1)
##  viridisLite    0.3.0    2018-02-01 [1] CRAN (R 3.5.1)
##  withr          2.1.2    2018-03-15 [1] CRAN (R 3.5.1)
## 
## [1] C:/Users/Italo/Documents/R/win-library/3.5
## [2] C:/Program Files/R/R-3.5.1/library&lt;/code&gt;&lt;/pre&gt;
&lt;div id=&#34;referencias&#34; class=&#34;section level1 unnumbered&#34;&gt;
&lt;h1&gt;Referências&lt;/h1&gt;
&lt;div id=&#34;refs&#34; class=&#34;references&#34;&gt;
&lt;div id=&#34;ref-Hakamada2012&#34;&gt;
&lt;p&gt;Hakamada, Rodrigo Eiji. 2012. “Uso do inventário florestal como ferramenta de monitoramento da qualidade silvicultura em povoamentos clonais de Eucalyptus.” PhD thesis, Piracicaba: Universidade de São Paulo; Biblioteca Digital de Teses e Dissertações da Universidade de São Paulo. doi:&lt;a href=&#34;https://doi.org/10.11606/D.11.2012.tde-05072012-100431&#34;&gt;10.11606/D.11.2012.tde-05072012-100431&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;ref-Hakamada2015&#34;&gt;
&lt;p&gt;Hakamada, Rodrigo Eiji, José Luiz Stape, Cristiane Camargo Zani de Lemos, Adriano Emanuel Amaral Almeida, and Luis Fernando Silva. 2015. “Uniformidade entre árvores durante uma rotação e sua relação com a produtividade em Eucalyptus clonais.” &lt;em&gt;CERNE&lt;/em&gt; 21 (3). Universidade Federal de Lavras: 465–72. doi:&lt;a href=&#34;https://doi.org/10.1590/01047760201521031716&#34;&gt;10.1590/01047760201521031716&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

      </content:encoded>
    </item>
    
    <item>
      <title>ANOVA e teste de Tukey</title>
      <link>/anova-e-teste-de-tukey/</link>
      <pubDate>Thu, 08 Sep 2016 00:00:00 +0000</pubDate>
      
      <guid>/anova-e-teste-de-tukey/</guid>
      <description>Análise de variância (ANOVA) e testes de médias são métodos comuns em artigos científicos. Você com certeza já viu aquelas letrinhas indicando a diferença entre tratamentos em algum estudo publicado. Por mais que este método esteja entrando em desuso - há uma tendência em abandonar esse tipo de abordagem estatística - penso que ainda o veremos por muitos anos no meio científico.
Como contexto, temos um teste de 5 progênies de eucalipto e queremos avaliar se volume por hectare (nossa variável resposta), difere entre os tratamentos.</description>
      <content:encoded>
        


&lt;p&gt;Análise de variância (ANOVA) e testes de médias são métodos comuns em artigos científicos. Você com certeza já viu aquelas letrinhas indicando a diferença entre tratamentos em algum estudo publicado. Por mais que este método esteja entrando em desuso - há uma tendência em abandonar esse tipo de abordagem estatística - penso que ainda o veremos por muitos anos no meio científico.&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;Como contexto, temos um teste de 5 progênies de eucalipto e queremos avaliar se volume por hectare (nossa variável resposta), difere entre os tratamentos.&lt;/p&gt;
&lt;p&gt;Pois bem, para percebermos a dimensão dos dados e qual a variabilidade de cada tratamento, vamos criar um boxplot (Figura &lt;a href=&#34;#fig:10-boxplot&#34;&gt;1&lt;/a&gt;). Caso você queira saber um pouco mais sobre este tipo de gráfico, veja o &lt;a href=&#34;https://italocegatta.github.io/os-graficos-que-explicam-nossos-dados-boxplot&#34;&gt;post sobre ele&lt;/a&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;if (!require(&amp;quot;pacman&amp;quot;)) install.packages(&amp;quot;pacman&amp;quot;)
pacman::p_load(readr, dplyr, tibble, ggplot2, car, agricolae)&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;dados &amp;lt;- read_csv2(
  &amp;quot;https://github.com/italocegatta/italocegatta.github.io_source/raw/master/content/dados/base_progenie.csv&amp;quot;
)

dados&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 30 x 3
##    repeticao progenie volume
##        &amp;lt;dbl&amp;gt; &amp;lt;chr&amp;gt;     &amp;lt;dbl&amp;gt;
##  1         1 A           212
##  2         2 A           206
##  3         3 A           224
##  4         4 A           289
##  5         5 A           324
##  6         6 A           219
##  7         1 B           108
##  8         2 B           194
##  9         3 B           163
## 10         4 B           111
## # ... with 20 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggplot(dados, aes(progenie, volume)) +
  geom_boxplot(fill = &amp;quot;grey60&amp;quot;, alpha = 0.8) +
  theme_bw(16)&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;figure&#34;&gt;&lt;span id=&#34;fig:10-boxplot&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;/post/2016-09-08-anova-e-teste-de-tukey_files/figure-html/10-boxplot-1.svg&#34; alt=&#34;Variabilidade do volume por hectare de cada tratamento.&#34; width=&#34;960&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figura  1: Variabilidade do volume por hectare de cada tratamento.
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;A ANOVA é um método bastante consolidado no meio acadêmico. Basicamente, este método informa se existe um tratamento discrepante dentre os demais. Entretanto, ele exige que algumas premissas sejam atendidas, como: distribuição normal dos resíduos e homogeneidade de variância.&lt;/p&gt;
&lt;p&gt;Primeiro, vamos utilizar o teste de Levene para verificar se há homogeneidade de variância, ou homocedasticidade. Como o p-valor é maior que 5% não temos evidência significativa para rejeitar a hipótese nula de homogeneidade, ou seja, nossos dados tem homogeneidade de variância.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;leveneTest(volume ~ factor(progenie), data=dados)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Levene&amp;#39;s Test for Homogeneity of Variance (center = median)
##       Df F value  Pr(&amp;gt;F)  
## group  4  2.4677 0.07086 .
##       25                  
## ---
## Signif. codes:  0 &amp;#39;***&amp;#39; 0.001 &amp;#39;**&amp;#39; 0.01 &amp;#39;*&amp;#39; 0.05 &amp;#39;.&amp;#39; 0.1 &amp;#39; &amp;#39; 1&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;O segundo pressuposto é a normalidade dos resíduos. Utilizaremos o teste de Shapiro-Wilk cuja hipótese nula é a de que os dados seguem uma distribuição normal. Como o p-valor é superior ao limite de 5%, podemos aceitar a hipótese nula e considerar nossos dados normais.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;anova &amp;lt;-  aov(volume ~ progenie, data=dados)

shapiro.test(resid(anova))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 
##  Shapiro-Wilk normality test
## 
## data:  resid(anova)
## W = 0.96097, p-value = 0.3279&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Uma vez que os pressupostos foram atendidos, seguiremos para a ANOVA. Note que, caso os testes de Levene e Shapiro-Wilk resultassem em um p-valor significante, ou seja, menor que 5%, teríamos que utilizar outro método estatístico para analisar nossos dados. Nesse caso, uma alternativa é utilizar testes não-paramétricos, uma vez que eles não exigem os pressupostos que acabamos de testar.&lt;/p&gt;
&lt;p&gt;Nossa ANOVA resultou em um p-valor menor que 5%, portanto, temos evidências de que ao menos um tratamento se diferencia dos demais. Isso já é uma resposta, mas pouco acrescenta à nossa pesquisa pois queremos saber quem é este tratamento discrepante. Ou melhor, queremos poder comparar os tratamentos entre si e verificar quais são estatisticamente iguais ou diferentes.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;summary(anova)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##             Df Sum Sq Mean Sq F value   Pr(&amp;gt;F)    
## progenie     4  86726   21681    8.89 0.000131 ***
## Residuals   25  60974    2439                     
## ---
## Signif. codes:  0 &amp;#39;***&amp;#39; 0.001 &amp;#39;**&amp;#39; 0.01 &amp;#39;*&amp;#39; 0.05 &amp;#39;.&amp;#39; 0.1 &amp;#39; &amp;#39; 1&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Para esta abordagem existem alguns testes de médias e cada um tem uma particularidade, mas de longe o mais utilizado é o de Tukey.&lt;/p&gt;
&lt;p&gt;A interpretação do teste de Tukey é simples. Após determinarmos a diferença mínima significativa (ou Honest Significant Difference - HSD), podemos julgar se as médias são iguais ou não. Em termos práticos, esse valor nos dá uma margem de igualdade, pois se a diferença entre dois tratamentos for maior do que isso, os médias são diferentes.&lt;/p&gt;
&lt;p&gt;A análise começa sempre pela maior média, no nosso caso a progênie A (245, 66). Com uma continha rápida, a média do tratamento A menos a diferença mínima significativa &lt;code&gt;245,66 - 83,73 = 161,93&lt;/code&gt;, aceitaremos que um tratamento é igual ao A se a média dele for maior que 161,93. O tratamento subsequente (o segundo do ranking) é a progênie D e como sua média é maior que 161,93 podemos dizer que ela é estatisticamente igual a progênie A.&lt;/p&gt;
&lt;p&gt;As próximas comparações seguem a mesma lógica. Quando registramos que duas médias são iguais, nós as rotulamos com a mesma letra para facilitar a identificação. Veja no fim do output as letras evidenciando a igualdade entre os tratamentos.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;tukey &amp;lt;- HSD.test(anova, &amp;quot;progenie&amp;quot;)

tukey&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## $statistics
##    MSerror Df     Mean       CV      MSD
##   2438.953 25 165.7667 29.79233 83.73866
## 
## $parameters
##    test   name.t ntr StudentizedRange alpha
##   Tukey progenie   5         4.153363  0.05
## 
## $means
##     volume      std r Min Max    Q25   Q50    Q75
## A 245.6667 48.78798 6 206 324 213.75 221.5 272.75
## B 159.6667 49.47996 6 108 236 119.75 154.5 186.25
## C  80.5000 15.60449 6  63 100  70.00  76.5  93.50
## D 190.1667 75.37484 6 100 267 121.75 207.0 251.75
## E 152.8333 37.96534 6 106 210 133.75 141.5 175.50
## 
## $comparison
## NULL
## 
## $groups
##     volume groups
## A 245.6667      a
## D 190.1667     ab
## B 159.6667     bc
## E 152.8333     bc
## C  80.5000      c
## 
## attr(,&amp;quot;class&amp;quot;)
## [1] &amp;quot;group&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Para deixar mais visual ainda, podemos construir um gráfico de barras com a média de cada tratamento e adicionar a sua letra correspondente ao teste de Tukey (Figura &lt;a href=&#34;#fig:10-barras-tukey&#34;&gt;2&lt;/a&gt;).&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;tukey$groups %&amp;gt;% 
  rownames_to_column(var = &amp;quot;trt&amp;quot;) %&amp;gt;% 
  mutate(trt = reorder(trt, -volume, mean)) %&amp;gt;% 
  ggplot(aes(trt, volume)) +
    geom_col(alpha = 0.8, color = &amp;quot;black&amp;quot;) +
    geom_text(aes(label = groups), vjust = 1.8, size = 9, color = &amp;quot;white&amp;quot;) +
    labs(x = &amp;quot;Progênies&amp;quot;, y = &amp;quot;Médias&amp;quot;) +
    theme_bw(16)&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;figure&#34;&gt;&lt;span id=&#34;fig:10-barras-tukey&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;/post/2016-09-08-anova-e-teste-de-tukey_files/figure-html/10-barras-tukey-1.svg&#34; alt=&#34;Médias dos tratamentos. As letras indicam médias estatisticamente iguais pelo teste de Tukey a 5% de significância.&#34; width=&#34;960&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figura  2: Médias dos tratamentos. As letras indicam médias estatisticamente iguais pelo teste de Tukey a 5% de significância.
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Caso tenha alguma dúvida ou sugestão sobre o post, fique à vontade para fazer um comentário ou me contatar por E-mail.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;sessioninfo::session_info(c(&amp;quot;readr&amp;quot;, &amp;quot;dplyr&amp;quot;, &amp;quot;tibble&amp;quot;, &amp;quot;ggplot2&amp;quot;, &amp;quot;car&amp;quot;, &amp;quot;agricolae&amp;quot;))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## - Session info ----------------------------------------------------------
##  setting  value                       
##  version  R version 3.5.1 (2018-07-02)
##  os       Windows 10 x64              
##  system   x86_64, mingw32             
##  ui       RTerm                       
##  language (EN)                        
##  collate  Portuguese_Brazil.1252      
##  ctype    Portuguese_Brazil.1252      
##  tz       America/Sao_Paulo           
##  date     2018-12-31                  
## 
## - Packages --------------------------------------------------------------
##  package      * version   date       lib source        
##  abind          1.4-5     2016-07-21 [1] CRAN (R 3.5.0)
##  agricolae    * 1.2-8     2017-09-12 [1] CRAN (R 3.5.2)
##  AlgDesign      1.1-7.3   2014-10-15 [1] CRAN (R 3.5.2)
##  assertthat     0.2.0     2017-04-11 [1] CRAN (R 3.5.1)
##  BH             1.66.0-1  2018-02-13 [1] CRAN (R 3.5.0)
##  bindr          0.1.1     2018-03-13 [1] CRAN (R 3.5.1)
##  bindrcpp     * 0.2.2     2018-03-29 [1] CRAN (R 3.5.1)
##  boot           1.3-20    2017-08-06 [2] CRAN (R 3.5.1)
##  car          * 3.0-2     2018-08-23 [1] CRAN (R 3.5.2)
##  carData      * 3.0-2     2018-09-30 [1] CRAN (R 3.5.2)
##  cellranger     1.1.0     2016-07-27 [1] CRAN (R 3.5.1)
##  class          7.3-14    2015-08-30 [2] CRAN (R 3.5.1)
##  classInt       0.2-3     2018-04-16 [1] CRAN (R 3.5.1)
##  cli            1.0.1     2018-09-25 [1] CRAN (R 3.5.1)
##  clipr          0.4.1     2018-06-23 [1] CRAN (R 3.5.1)
##  cluster        2.0.7-1   2018-04-13 [2] CRAN (R 3.5.1)
##  coda           0.19-2    2018-10-08 [1] CRAN (R 3.5.2)
##  colorspace     1.3-2     2016-12-14 [1] CRAN (R 3.5.1)
##  combinat       0.0-8     2012-10-29 [1] CRAN (R 3.5.2)
##  crayon         1.3.4     2017-09-16 [1] CRAN (R 3.5.1)
##  curl           3.2       2018-03-28 [1] CRAN (R 3.5.1)
##  data.table     1.11.8    2018-09-30 [1] CRAN (R 3.5.1)
##  deldir         0.1-15    2018-04-01 [1] CRAN (R 3.5.2)
##  digest         0.6.18    2018-10-10 [1] CRAN (R 3.5.1)
##  dplyr        * 0.7.8     2018-11-10 [1] CRAN (R 3.5.1)
##  e1071          1.7-0     2018-07-28 [1] CRAN (R 3.5.1)
##  expm           0.999-3   2018-09-22 [1] CRAN (R 3.5.2)
##  fansi          0.4.0     2018-10-05 [1] CRAN (R 3.5.1)
##  forcats        0.3.0     2018-02-19 [1] CRAN (R 3.5.1)
##  foreign        0.8-70    2017-11-28 [2] CRAN (R 3.5.1)
##  gdata          2.18.0    2017-06-06 [1] CRAN (R 3.5.2)
##  ggplot2      * 3.1.0     2018-10-25 [1] CRAN (R 3.5.1)
##  glue           1.3.0     2018-07-17 [1] CRAN (R 3.5.1)
##  gmodels        2.18.1    2018-06-25 [1] CRAN (R 3.5.2)
##  gtable         0.2.0     2016-02-26 [1] CRAN (R 3.5.1)
##  gtools         3.8.1     2018-06-26 [1] CRAN (R 3.5.2)
##  haven          2.0.0     2018-11-22 [1] CRAN (R 3.5.1)
##  highr          0.7       2018-06-09 [1] CRAN (R 3.5.1)
##  hms            0.4.2     2018-03-10 [1] CRAN (R 3.5.1)
##  htmltools      0.3.6     2017-04-28 [1] CRAN (R 3.5.1)
##  httpuv         1.4.5     2018-07-19 [1] CRAN (R 3.5.1)
##  jsonlite       1.6       2018-12-07 [1] CRAN (R 3.5.2)
##  klaR           0.6-14    2018-03-19 [1] CRAN (R 3.5.2)
##  labeling       0.3       2014-08-23 [1] CRAN (R 3.5.0)
##  labelled       2.0.1     2018-11-25 [1] CRAN (R 3.5.2)
##  later          0.7.5     2018-09-18 [1] CRAN (R 3.5.1)
##  lattice        0.20-35   2017-03-25 [2] CRAN (R 3.5.1)
##  lazyeval       0.2.1     2017-10-29 [1] CRAN (R 3.5.1)
##  LearnBayes     2.15.1    2018-03-18 [1] CRAN (R 3.5.2)
##  lme4           1.1-19    2018-11-10 [1] CRAN (R 3.5.1)
##  magrittr       1.5       2014-11-22 [1] CRAN (R 3.5.1)
##  maptools       0.9-4     2018-09-19 [1] CRAN (R 3.5.1)
##  MASS           7.3-50    2018-04-30 [2] CRAN (R 3.5.1)
##  Matrix         1.2-14    2018-04-13 [2] CRAN (R 3.5.1)
##  MatrixModels   0.4-1     2015-08-22 [1] CRAN (R 3.5.2)
##  mgcv           1.8-24    2018-06-23 [2] CRAN (R 3.5.1)
##  mime           0.6       2018-10-05 [1] CRAN (R 3.5.1)
##  miniUI         0.1.1.1   2018-05-18 [1] CRAN (R 3.5.2)
##  minqa          1.2.4     2014-10-09 [1] CRAN (R 3.5.1)
##  munsell        0.5.0     2018-06-12 [1] CRAN (R 3.5.1)
##  nlme           3.1-137   2018-04-07 [2] CRAN (R 3.5.1)
##  nloptr         1.2.1     2018-10-03 [1] CRAN (R 3.5.1)
##  nnet           7.3-12    2016-02-02 [2] CRAN (R 3.5.1)
##  openxlsx       4.1.0     2018-05-26 [1] CRAN (R 3.5.2)
##  pbkrtest       0.4-7     2017-03-15 [1] CRAN (R 3.5.2)
##  pillar         1.3.1     2018-12-15 [1] CRAN (R 3.5.2)
##  pkgconfig      2.0.2     2018-08-16 [1] CRAN (R 3.5.1)
##  plogr          0.2.0     2018-03-25 [1] CRAN (R 3.5.1)
##  plyr           1.8.4     2016-06-08 [1] CRAN (R 3.5.1)
##  promises       1.0.1     2018-04-13 [1] CRAN (R 3.5.1)
##  purrr          0.2.5     2018-05-29 [1] CRAN (R 3.5.1)
##  quantreg       5.38      2018-12-18 [1] CRAN (R 3.5.2)
##  questionr      0.7.0     2018-11-26 [1] CRAN (R 3.5.2)
##  R6             2.3.0     2018-10-04 [1] CRAN (R 3.5.1)
##  RColorBrewer   1.1-2     2014-12-07 [1] CRAN (R 3.5.0)
##  Rcpp           1.0.0     2018-11-07 [1] CRAN (R 3.5.1)
##  RcppEigen      0.3.3.5.0 2018-11-24 [1] CRAN (R 3.5.1)
##  readr        * 1.2.1     2018-11-22 [1] CRAN (R 3.5.1)
##  readxl         1.1.0     2018-04-20 [1] CRAN (R 3.5.1)
##  rematch        1.0.1     2016-04-21 [1] CRAN (R 3.5.1)
##  reshape2       1.4.3     2017-12-11 [1] CRAN (R 3.5.1)
##  rio            0.5.16    2018-11-26 [1] CRAN (R 3.5.2)
##  rlang          0.3.0.1   2018-10-25 [1] CRAN (R 3.5.1)
##  rstudioapi     0.8       2018-10-02 [1] CRAN (R 3.5.1)
##  scales         1.0.0     2018-08-09 [1] CRAN (R 3.5.1)
##  shiny          1.2.0     2018-11-02 [1] CRAN (R 3.5.1)
##  sourcetools    0.1.7     2018-04-25 [1] CRAN (R 3.5.1)
##  sp             1.3-1     2018-06-05 [1] CRAN (R 3.5.1)
##  SparseM        1.77      2017-04-23 [1] CRAN (R 3.5.2)
##  spData         0.2.9.4   2018-09-15 [1] CRAN (R 3.5.1)
##  spdep          0.8-1     2018-11-21 [1] CRAN (R 3.5.2)
##  stringi        1.2.4     2018-07-20 [1] CRAN (R 3.5.1)
##  stringr        1.3.1     2018-05-10 [1] CRAN (R 3.5.1)
##  tibble       * 1.4.2     2018-01-22 [1] CRAN (R 3.5.1)
##  tidyselect     0.2.5     2018-10-11 [1] CRAN (R 3.5.1)
##  utf8           1.1.4     2018-05-24 [1] CRAN (R 3.5.1)
##  viridisLite    0.3.0     2018-02-01 [1] CRAN (R 3.5.1)
##  withr          2.1.2     2018-03-15 [1] CRAN (R 3.5.1)
##  xtable         1.8-3     2018-08-29 [1] CRAN (R 3.5.1)
##  zip            1.0.0     2017-04-25 [1] CRAN (R 3.5.2)
## 
## [1] C:/Users/Italo/Documents/R/win-library/3.5
## [2] C:/Program Files/R/R-3.5.1/library&lt;/code&gt;&lt;/pre&gt;

      </content:encoded>
    </item>
    
    <item>
      <title>Ajuste de um modelo linear para vários fatores</title>
      <link>/ajuste-de-um-modelo-linear-para-varios-fatores/</link>
      <pubDate>Sat, 27 Aug 2016 00:00:00 +0000</pubDate>
      
      <guid>/ajuste-de-um-modelo-linear-para-varios-fatores/</guid>
      <description>Ajustar um modelo linear ou não linear é algo relativamente simples no R. Mas em muitos casos precisamos ajustá-lo para vários fatores e dependendo da quantidade isso se torna uma tarefa chata. Se você, assim como eu, já precisou fazer isso no Excel, sabe o que é perder mais que uma tarde copiando e colando informações entres abas e planilhas.
Mas felizmente existe uma máxima muito interessante entre programadores que é:</description>
      <content:encoded>
        


&lt;p&gt;Ajustar um modelo linear ou não linear é algo relativamente simples no R. Mas em muitos casos precisamos ajustá-lo para vários fatores e dependendo da quantidade isso se torna uma tarefa chata. Se você, assim como eu, já precisou fazer isso no Excel, sabe o que é perder mais que uma tarde copiando e colando informações entres abas e planilhas.&lt;br /&gt;
&lt;!-- more --&gt;&lt;/p&gt;
&lt;p&gt;Mas felizmente existe uma máxima muito interessante entre programadores que é:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Don’t Repeat Yourself (DRY)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Depois que eu percebi o quanto a repetição humana gera erros, abracei totalmente o conceito DRY. Acreditem, vocês serão muito mais felizes e eficientes deixando o computador fazer as tarefas repetitivas e chatas.&lt;/p&gt;
&lt;p&gt;Para exemplificar, vamos fazer algo muito comum nas ciências florestais, que é predizer as alturas das árvores. Medir a altura da árvore é uma atividade laboriosa, e há muito tempo se sabe que a altura total das árvores possui alta correlação com o seu diâmetro.&lt;/p&gt;
&lt;p&gt;Utilizaremos mais uma vez os dados do &lt;a href=&#34;www.projetotume.com&#34;&gt;Projeto TUME&lt;/a&gt;, referente a medição de 24 meses do TUME 55 plantado no Mato Grosso do Sul.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;if (!require(&amp;quot;pacman&amp;quot;)) install.packages(&amp;quot;pacman&amp;quot;)
pacman::p_load(readr, dplyr, tidyr, broom, purrr, ggplot2)&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;dados &amp;lt;- read_csv2(
  &amp;quot;https://github.com/italocegatta/italocegatta.github.io_source/raw/master/content/dados/tume_55_24.csv&amp;quot;
)

dados&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 1,881 x 9
##    N_tume I_meses Esp          Parc_m2 N_arv DAP_cm   H_m   Cod  Cod2
##     &amp;lt;dbl&amp;gt;   &amp;lt;dbl&amp;gt; &amp;lt;chr&amp;gt;          &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt;
##  1     55      24 E_botryoides     600     1    4.1   6.5    NA    NA
##  2     55      24 E_botryoides     600     2    9.7   8      NA    NA
##  3     55      24 E_botryoides     600     3   NA    NA       5    NA
##  4     55      24 E_botryoides     600     4    7.6   7.5     2    NA
##  5     55      24 E_botryoides     600     5    3.8   5      NA    NA
##  6     55      24 E_botryoides     600     6   NA    NA       1    NA
##  7     55      24 E_botryoides     600     7   12.6   9       6    NA
##  8     55      24 E_botryoides     600     8   NA    NA       1    NA
##  9     55      24 E_botryoides     600     9    7     8      NA    NA
## 10     55      24 E_botryoides     600    10    7.5   7.5    NA    NA
## # ... with 1,871 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Nosso objetivo é simples: ajustar um modelo hipsométrico para cada espécie e em seguida predizer as alturas das árvores. A Figura &lt;a href=&#34;#fig:9-dap-h&#34;&gt;1&lt;/a&gt; mostra a relação que teríamos se fosse ajustado apenas um modelo para todas as espécies.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggplot(dados, aes(DAP_cm, H_m)) +
  geom_point(alpha=0.4) +
  geom_smooth(method=&amp;quot;lm&amp;quot;) +
  theme_bw(16)&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;figure&#34;&gt;&lt;span id=&#34;fig:9-dap-h&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;/post/2016-08-27-ajuste-de-um-modelo-linear-para-varios-fatores_files/figure-html/9-dap-h-1.svg&#34; alt=&#34;Relação entre o diâmetro e a altura sem distinção de espécie.&#34; width=&#34;960&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figura  1: Relação entre o diâmetro e a altura sem distinção de espécie.
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Mas na prática, a relação diâmetro-altura é diferente entre espécie, como pode ser notado na Figura &lt;a href=&#34;#fig:9-dap-h-spp&#34;&gt;2&lt;/a&gt;. Talvez fique mais evidente a diferença observando os coeficientes dos modelos que serão ajustados a seguir.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggplot(dados, aes(DAP_cm, H_m)) +
  geom_point(alpha=0.4) +
  geom_smooth(method=&amp;quot;lm&amp;quot;) +
  facet_wrap(~Esp) +
  theme_bw(16)&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;figure&#34;&gt;&lt;span id=&#34;fig:9-dap-h-spp&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;/post/2016-08-27-ajuste-de-um-modelo-linear-para-varios-fatores_files/figure-html/9-dap-h-spp-1.svg&#34; alt=&#34;Relação entre o diâmetro e a altura por espécie.&#34; width=&#34;960&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figura  2: Relação entre o diâmetro e a altura por espécie.
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;A primeira etapa é entender que um data.frame pode conter vários tipos de elementos, como números, caracteres, listas e também outros data.frames. Para isso utilizaremos a função &lt;code&gt;nest()&lt;/code&gt; do pacote &lt;code&gt;tidyr&lt;/code&gt; e aninharemos os dados em função das espécies.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;dados %&amp;gt;%
  group_by(Esp) %&amp;gt;% 
  nest()&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 24 x 2
##    Esp                     data             
##    &amp;lt;chr&amp;gt;                   &amp;lt;list&amp;gt;           
##  1 E_botryoides            &amp;lt;tibble [80 x 8]&amp;gt;
##  2 E_brassiana             &amp;lt;tibble [80 x 8]&amp;gt;
##  3 E_camaldulensis         &amp;lt;tibble [80 x 8]&amp;gt;
##  4 E_citriodora            &amp;lt;tibble [80 x 8]&amp;gt;
##  5 E_cloeziana             &amp;lt;tibble [51 x 8]&amp;gt;
##  6 E_dunnii_urophylla      &amp;lt;tibble [80 x 8]&amp;gt;
##  7 E_exserta               &amp;lt;tibble [80 x 8]&amp;gt;
##  8 E_grandis_AT            &amp;lt;tibble [80 x 8]&amp;gt;
##  9 E_grandis_camaldulensis &amp;lt;tibble [80 x 8]&amp;gt;
## 10 E_grandis_CH            &amp;lt;tibble [80 x 8]&amp;gt;
## # ... with 14 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Agora podemos ajustar um modelo de regressão para cada espécie utilizando a função &lt;code&gt;map&lt;/code&gt;,do pacote &lt;code&gt;purrr&lt;/code&gt;. Podemos ainda extrair as informações desses modelos com as funções &lt;code&gt;glance&lt;/code&gt;, &lt;code&gt;tidy&lt;/code&gt; e &lt;code&gt;augment&lt;/code&gt;, do pacote &lt;code&gt;broom&lt;/code&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;dados_modl &amp;lt;- dados %&amp;gt;%
  group_by(Esp) %&amp;gt;% 
  nest() %&amp;gt;% 
  mutate(
    ajuste = data %&amp;gt;% map(~ lm(log(H_m) ~ I(1/DAP_cm), data = .)),
    resumo = map(ajuste, glance),
    coef = map(ajuste, tidy),
    resid = map(ajuste, augment)
  )

dados_modl&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 24 x 6
##    Esp             data         ajuste   resumo      coef       resid      
##    &amp;lt;chr&amp;gt;           &amp;lt;list&amp;gt;       &amp;lt;list&amp;gt;   &amp;lt;list&amp;gt;      &amp;lt;list&amp;gt;     &amp;lt;list&amp;gt;     
##  1 E_botryoides    &amp;lt;tibble [80~ &amp;lt;S3: lm&amp;gt; &amp;lt;tibble [1~ &amp;lt;tibble [~ &amp;lt;tibble [6~
##  2 E_brassiana     &amp;lt;tibble [80~ &amp;lt;S3: lm&amp;gt; &amp;lt;tibble [1~ &amp;lt;tibble [~ &amp;lt;tibble [6~
##  3 E_camaldulensis &amp;lt;tibble [80~ &amp;lt;S3: lm&amp;gt; &amp;lt;tibble [1~ &amp;lt;tibble [~ &amp;lt;tibble [7~
##  4 E_citriodora    &amp;lt;tibble [80~ &amp;lt;S3: lm&amp;gt; &amp;lt;tibble [1~ &amp;lt;tibble [~ &amp;lt;tibble [6~
##  5 E_cloeziana     &amp;lt;tibble [51~ &amp;lt;S3: lm&amp;gt; &amp;lt;tibble [1~ &amp;lt;tibble [~ &amp;lt;tibble [3~
##  6 E_dunnii_uroph~ &amp;lt;tibble [80~ &amp;lt;S3: lm&amp;gt; &amp;lt;tibble [1~ &amp;lt;tibble [~ &amp;lt;tibble [7~
##  7 E_exserta       &amp;lt;tibble [80~ &amp;lt;S3: lm&amp;gt; &amp;lt;tibble [1~ &amp;lt;tibble [~ &amp;lt;tibble [7~
##  8 E_grandis_AT    &amp;lt;tibble [80~ &amp;lt;S3: lm&amp;gt; &amp;lt;tibble [1~ &amp;lt;tibble [~ &amp;lt;tibble [7~
##  9 E_grandis_cama~ &amp;lt;tibble [80~ &amp;lt;S3: lm&amp;gt; &amp;lt;tibble [1~ &amp;lt;tibble [~ &amp;lt;tibble [6~
## 10 E_grandis_CH    &amp;lt;tibble [80~ &amp;lt;S3: lm&amp;gt; &amp;lt;tibble [1~ &amp;lt;tibble [~ &amp;lt;tibble [6~
## # ... with 14 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Da mesma forma que aninhamos os dados por espécie, podemos retorná-los para o formato original, mas agora mostrando apenas as informações que realmente interessam.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;dados_modl %&amp;gt;%
  select(Esp, resumo) %&amp;gt;% 
  unnest(resumo)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 24 x 12
##    Esp   r.squared adj.r.squared  sigma statistic  p.value    df logLik
##    &amp;lt;chr&amp;gt;     &amp;lt;dbl&amp;gt;         &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt;     &amp;lt;dbl&amp;gt;    &amp;lt;dbl&amp;gt; &amp;lt;int&amp;gt;  &amp;lt;dbl&amp;gt;
##  1 E_bo~     0.787         0.783 0.136      236.  3.85e-23     2   38.9
##  2 E_br~     0.703         0.698 0.160      140.  3.26e-17     2   26.2
##  3 E_ca~     0.719         0.716 0.128      195.  1.14e-22     2   50.8
##  4 E_ci~     0.602         0.596 0.102      101.  4.98e-15     2   60.4
##  5 E_cl~     0.260         0.234 0.167       10.2 3.42e- 3     2   12.5
##  6 E_du~     0.720         0.716 0.161      180.  5.03e-21     2   30.3
##  7 E_ex~     0.590         0.584 0.196       99.2 5.52e-15     2   16.1
##  8 E_gr~     0.747         0.744 0.0772     225.  2.12e-24     2   90.1
##  9 E_gr~     0.829         0.827 0.161      325.  2.11e-27     2   29.2
## 10 E_gr~     0.776         0.773 0.105      233.  1.75e-23     2   58.8
## # ... with 14 more rows, and 4 more variables: AIC &amp;lt;dbl&amp;gt;, BIC &amp;lt;dbl&amp;gt;,
## #   deviance &amp;lt;dbl&amp;gt;, df.residual &amp;lt;int&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;dados_modl %&amp;gt;%
  select(Esp, coef ) %&amp;gt;% 
  unnest(coef)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 48 x 6
##    Esp             term        estimate std.error statistic  p.value
##    &amp;lt;chr&amp;gt;           &amp;lt;chr&amp;gt;          &amp;lt;dbl&amp;gt;     &amp;lt;dbl&amp;gt;     &amp;lt;dbl&amp;gt;    &amp;lt;dbl&amp;gt;
##  1 E_botryoides    (Intercept)     2.63    0.0422     62.3  5.04e-59
##  2 E_botryoides    I(1/DAP_cm)    -4.13    0.269     -15.4  3.85e-23
##  3 E_brassiana     (Intercept)     2.01    0.0511     39.4  4.39e-44
##  4 E_brassiana     I(1/DAP_cm)    -2.37    0.201     -11.8  3.26e-17
##  5 E_camaldulensis (Intercept)     2.73    0.0461     59.2  2.33e-65
##  6 E_camaldulensis I(1/DAP_cm)    -4.79    0.343     -14.0  1.14e-22
##  7 E_citriodora    (Intercept)     2.55    0.0551     46.3  1.31e-52
##  8 E_citriodora    I(1/DAP_cm)    -3.80    0.378     -10.1  4.98e-15
##  9 E_cloeziana     (Intercept)     2.32    0.116      20.1  1.50e-18
## 10 E_cloeziana     I(1/DAP_cm)    -2.84    0.892      -3.19 3.42e- 3
## # ... with 38 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;dados_modl %&amp;gt;%
  select(Esp, resid) %&amp;gt;% 
  unnest(resid)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 1,633 x 11
##    Esp   .rownames log.H_m. I.1.DAP_cm. .fitted .se.fit   .resid   .hat
##    &amp;lt;chr&amp;gt; &amp;lt;chr&amp;gt;        &amp;lt;dbl&amp;gt;       &amp;lt;dbl&amp;gt;   &amp;lt;dbl&amp;gt;   &amp;lt;dbl&amp;gt;    &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt;
##  1 E_bo~ 1             1.87      0.244     1.63  0.0317  0.246   0.0539
##  2 E_bo~ 2             2.08      0.103     2.21  0.0201 -0.128   0.0217
##  3 E_bo~ 4             2.01      0.132     2.09  0.0171 -0.0751  0.0158
##  4 E_bo~ 5             1.61      0.263     1.55  0.0361  0.0628  0.0702
##  5 E_bo~ 7             2.20      0.0794    2.31  0.0242 -0.108   0.0315
##  6 E_bo~ 9             2.08      0.143     2.04  0.0168  0.0360  0.0152
##  7 E_bo~ 10            2.01      0.133     2.08  0.0170 -0.0678  0.0156
##  8 E_bo~ 13            1.61      0.167     1.95  0.0178 -0.336   0.0171
##  9 E_bo~ 14            2.30      0.0980    2.23  0.0209  0.0741  0.0234
## 10 E_bo~ 15            2.14      0.120     2.14  0.0180  0.00425 0.0173
## # ... with 1,623 more rows, and 3 more variables: .sigma &amp;lt;dbl&amp;gt;,
## #   .cooksd &amp;lt;dbl&amp;gt;, .std.resid &amp;lt;dbl&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Após o ajuste do modelo, temos de predizer as alturas. O único adendo para esse comando é que precisamos fazer em duas etapas, uma utilizando a função &lt;code&gt;predict&lt;/code&gt; e outra para trazer o valor predito para a escala natural, pois o modelo foi ajustado na escala logarítmica.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;dados_pred &amp;lt;- dados_modl %&amp;gt;% 
  mutate(
    hpred = map2(ajuste, data, predict),
    hpred = map(hpred, exp)
  ) %&amp;gt;%
  select(Esp, data, hpred)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Por fim, temos de volta um data.frame com as alturas preditas. Por mais que o ajuste tenha ficado razoável, na prática a construção de modelos de relação hipsométrica envolvem outras etapas e um maior rigor em termos estatísticos.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;dados_compl &amp;lt;- dados_pred %&amp;gt;%
  unnest(hpred, data)

dados_compl&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 1,881 x 10
##    Esp          hpred N_tume I_meses Parc_m2 N_arv DAP_cm   H_m   Cod  Cod2
##    &amp;lt;chr&amp;gt;        &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt;   &amp;lt;dbl&amp;gt;   &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt;
##  1 E_botryoides  5.08     55      24     600     1    4.1   6.5    NA    NA
##  2 E_botryoides  9.09     55      24     600     2    9.7   8      NA    NA
##  3 E_botryoides NA        55      24     600     3   NA    NA       5    NA
##  4 E_botryoides  8.08     55      24     600     4    7.6   7.5     2    NA
##  5 E_botryoides  4.70     55      24     600     5    3.8   5      NA    NA
##  6 E_botryoides NA        55      24     600     6   NA    NA       1    NA
##  7 E_botryoides 10.0      55      24     600     7   12.6   9       6    NA
##  8 E_botryoides NA        55      24     600     8   NA    NA       1    NA
##  9 E_botryoides  7.72     55      24     600     9    7     8      NA    NA
## 10 E_botryoides  8.03     55      24     600    10    7.5   7.5    NA    NA
## # ... with 1,871 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Caso tenha alguma dúvida ou sugestão sobre o post, fique à vontade para fazer um comentário ou me contatar por E-mail.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;sessioninfo::session_info(c(&amp;quot;readr&amp;quot;, &amp;quot;dplyr&amp;quot;, &amp;quot;ggplot2&amp;quot;, &amp;quot;tidyr&amp;quot;, &amp;quot;broom&amp;quot;, &amp;quot;purrr&amp;quot;))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## - Session info ----------------------------------------------------------
##  setting  value                       
##  version  R version 3.5.1 (2018-07-02)
##  os       Windows 10 x64              
##  system   x86_64, mingw32             
##  ui       RTerm                       
##  language (EN)                        
##  collate  Portuguese_Brazil.1252      
##  ctype    Portuguese_Brazil.1252      
##  tz       America/Sao_Paulo           
##  date     2018-12-31                  
## 
## - Packages --------------------------------------------------------------
##  package      * version  date       lib source        
##  assertthat     0.2.0    2017-04-11 [1] CRAN (R 3.5.1)
##  backports      1.1.2    2017-12-13 [1] CRAN (R 3.5.0)
##  BH             1.66.0-1 2018-02-13 [1] CRAN (R 3.5.0)
##  bindr          0.1.1    2018-03-13 [1] CRAN (R 3.5.1)
##  bindrcpp     * 0.2.2    2018-03-29 [1] CRAN (R 3.5.1)
##  broom        * 0.5.0    2018-07-17 [1] CRAN (R 3.5.1)
##  cli            1.0.1    2018-09-25 [1] CRAN (R 3.5.1)
##  clipr          0.4.1    2018-06-23 [1] CRAN (R 3.5.1)
##  colorspace     1.3-2    2016-12-14 [1] CRAN (R 3.5.1)
##  crayon         1.3.4    2017-09-16 [1] CRAN (R 3.5.1)
##  digest         0.6.18   2018-10-10 [1] CRAN (R 3.5.1)
##  dplyr        * 0.7.8    2018-11-10 [1] CRAN (R 3.5.1)
##  fansi          0.4.0    2018-10-05 [1] CRAN (R 3.5.1)
##  ggplot2      * 3.1.0    2018-10-25 [1] CRAN (R 3.5.1)
##  glue           1.3.0    2018-07-17 [1] CRAN (R 3.5.1)
##  gtable         0.2.0    2016-02-26 [1] CRAN (R 3.5.1)
##  hms            0.4.2    2018-03-10 [1] CRAN (R 3.5.1)
##  labeling       0.3      2014-08-23 [1] CRAN (R 3.5.0)
##  lattice        0.20-35  2017-03-25 [2] CRAN (R 3.5.1)
##  lazyeval       0.2.1    2017-10-29 [1] CRAN (R 3.5.1)
##  magrittr       1.5      2014-11-22 [1] CRAN (R 3.5.1)
##  MASS           7.3-50   2018-04-30 [2] CRAN (R 3.5.1)
##  Matrix         1.2-14   2018-04-13 [2] CRAN (R 3.5.1)
##  mgcv           1.8-24   2018-06-23 [2] CRAN (R 3.5.1)
##  munsell        0.5.0    2018-06-12 [1] CRAN (R 3.5.1)
##  nlme           3.1-137  2018-04-07 [2] CRAN (R 3.5.1)
##  pillar         1.3.1    2018-12-15 [1] CRAN (R 3.5.2)
##  pkgconfig      2.0.2    2018-08-16 [1] CRAN (R 3.5.1)
##  plogr          0.2.0    2018-03-25 [1] CRAN (R 3.5.1)
##  plyr           1.8.4    2016-06-08 [1] CRAN (R 3.5.1)
##  purrr        * 0.2.5    2018-05-29 [1] CRAN (R 3.5.1)
##  R6             2.3.0    2018-10-04 [1] CRAN (R 3.5.1)
##  RColorBrewer   1.1-2    2014-12-07 [1] CRAN (R 3.5.0)
##  Rcpp           1.0.0    2018-11-07 [1] CRAN (R 3.5.1)
##  readr        * 1.2.1    2018-11-22 [1] CRAN (R 3.5.1)
##  reshape2       1.4.3    2017-12-11 [1] CRAN (R 3.5.1)
##  rlang          0.3.0.1  2018-10-25 [1] CRAN (R 3.5.1)
##  scales         1.0.0    2018-08-09 [1] CRAN (R 3.5.1)
##  stringi        1.2.4    2018-07-20 [1] CRAN (R 3.5.1)
##  stringr        1.3.1    2018-05-10 [1] CRAN (R 3.5.1)
##  tibble         1.4.2    2018-01-22 [1] CRAN (R 3.5.1)
##  tidyr        * 0.8.2    2018-10-28 [1] CRAN (R 3.5.1)
##  tidyselect     0.2.5    2018-10-11 [1] CRAN (R 3.5.1)
##  utf8           1.1.4    2018-05-24 [1] CRAN (R 3.5.1)
##  viridisLite    0.3.0    2018-02-01 [1] CRAN (R 3.5.1)
##  withr          2.1.2    2018-03-15 [1] CRAN (R 3.5.1)
## 
## [1] C:/Users/Italo/Documents/R/win-library/3.5
## [2] C:/Program Files/R/R-3.5.1/library&lt;/code&gt;&lt;/pre&gt;

      </content:encoded>
    </item>
    
    <item>
      <title>Análise de componentes principais</title>
      <link>/analise-de-componentes-principais/</link>
      <pubDate>Mon, 01 Aug 2016 00:00:00 +0000</pubDate>
      
      <guid>/analise-de-componentes-principais/</guid>
      <description>Quando temos dados multivariados, a análise de componentes principais (PCA) é um recurso muito interessante e relativamente simples, em termos de conceito teórico e interpretação prática. Para exemplificar, vamos trabalhar com os dados climáticos de algumas cidades brasileiras. Os dados climáticos foram compilados a partir de estações automáticas do INMET.
No R, temos a facilidade de poder fazer o cálculo dos componentes principais e logo em seguida poder apresentá-los em gráficos elegantes e de fácil entendimento.</description>
      <content:encoded>
        


&lt;p&gt;Quando temos dados multivariados, a análise de componentes principais (PCA) é um recurso muito interessante e relativamente simples, em termos de conceito teórico e interpretação prática. Para exemplificar, vamos trabalhar com os dados climáticos de algumas cidades brasileiras. Os dados climáticos foram compilados a partir de estações automáticas do &lt;a href=&#34;http://www.inmet.gov.br/portal/index.php?r=estacoes/estacoesautomaticas&#34;&gt;INMET&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;No R, temos a facilidade de poder fazer o cálculo dos componentes principais e logo em seguida poder apresentá-los em gráficos elegantes e de fácil entendimento. O Objetivo deste post é apresentar uma rápida demonstração de como rodar um PCA e gerar os gráficos derivados.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;if (!require(&amp;quot;pacman&amp;quot;)) install.packages(&amp;quot;pacman&amp;quot;)
pacman::p_load(readr, dplyr, ggplot2, ggrepel)
pacman::p_load_gh(&amp;quot;vqv/ggbiplot&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;dados &amp;lt;- read_csv2(
  &amp;quot;https://github.com/italocegatta/italocegatta.github.io_source/raw/master/content/dados/base_clima.csv&amp;quot;
)

print(dados, n=31)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 31 x 6
##    Cidade             Koppen  Tmed   PPT   ETP   DEF
##    &amp;lt;chr&amp;gt;              &amp;lt;chr&amp;gt;  &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt;
##  1 Bom Despacho       Cwa     22.6  802. 1112. 238. 
##  2 Niquelandia        Aw      24.6  562. 1372. 656. 
##  3 Arapoti            Cfb     18.5 1367   670.  25.4
##  4 Rio Verde          Aw      23.3 1245. 1196. 425. 
##  5 Belo Oriente       Aw      22.6 1054. 1105. 125. 
##  6 Guanhaes           Cwa     20.6  818.  866  188. 
##  7 Eldorado do Sul    Cfa     20.6 1787.  859.  10.7
##  8 Sao Gabriel        Cfa     20.2 1783.  927.   2.8
##  9 Inhambupe          As      24.2  715. 1318. 607. 
## 10 Botucatu           Cfb     21.9 1013. 1030  184. 
## 11 Estrela do Sul     Cwa     23.4 1134. 1208. 206. 
## 12 Buri               Cfa     20.0 1404.  805    3.6
## 13 Inocencia          Am      24.5 1020. 1375. 389. 
## 14 Chapadao do Sul    Am      22.6 1027. 1098. 326. 
## 15 Aracruz            Aw      23.9  849. 1277. 336. 
## 16 Tres Lagoas        Aw      25.2  944. 1502. 538. 
## 17 Tres Marias        Aw      22.2  811. 1052. 405. 
## 18 Peixe              Aw      26.3 1208. 1630. 674. 
## 19 Mogi Guacu         Cwa     22.4  924. 1100. 210. 
## 20 Brejinho de Nazare Aw      25.9 1507. 1563. 496. 
## 21 Monte Dourado      Am      27.4 2529. 1821. 530. 
## 22 Otacilio Costa     Cfb     16.9 2092.  548.   0  
## 23 Telemaco Borba     Cfa     18.5 1367   670.  28  
## 24 Borebi             Cfa     22.1  948. 1058. 201. 
## 25 Coracao de Jesus   As      23.9  413. 1275. 744. 
## 26 Antonio Olinto     Cfb     17.7 1740.  616.   0  
## 27 Tres Barras        Cfb     17.3 1123.  581   16.5
## 28 Urbano Santos      Aw      27.0 1438. 1750. 935  
## 29 Eunapolis          Am      22.9 1419. 1128.  31.2
## 30 Itagimirim         Aw      25.2  491. 1460. 870. 
## 31 Bocaiuva           Aw      23.9  413. 1276. 642.&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A análise de componentes principais nos mostra o quanto cada grupo de variáveis explicam a variabilidade total dados. No nosso caso, o primeiro componente responde por 72% da variabilidade e tem efeito quase que igual da temperatura (Tmed), evapotranspiração (ETP) e déficit hídrico (DEF). O segundo componente é majoritariamente o efeito da chuva (PPT). Juntos, os dois componentes explicam 95% dos dados.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;pca &amp;lt;- select(dados, Tmed:DEF) %&amp;gt;%
  princomp(cor = T)

summary(pca); loadings(pca)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Importance of components:
##                           Comp.1    Comp.2     Comp.3       Comp.4
## Standard deviation     1.7007490 0.9709348 0.40137904 0.0602784852
## Proportion of Variance 0.7231368 0.2356786 0.04027628 0.0009083739
## Cumulative Proportion  0.7231368 0.9588153 0.99909163 1.0000000000&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 
## Loadings:
##      Comp.1 Comp.2 Comp.3 Comp.4
## Tmed  0.567  0.201  0.437  0.668
## PPT  -0.241  0.933 -0.251       
## ETP   0.561  0.284  0.261 -0.732
## DEF   0.553        -0.823       
## 
##                Comp.1 Comp.2 Comp.3 Comp.4
## SS loadings      1.00   1.00   1.00   1.00
## Proportion Var   0.25   0.25   0.25   0.25
## Cumulative Var   0.25   0.50   0.75   1.00&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A Figura &lt;a href=&#34;#fig:8-pca&#34;&gt;1&lt;/a&gt; ajuda-nos a visualizar a disposição das cidades em função dos dois principais componentes. Se analisarmos por quadrantes, podemos agrupar as cidades de clima semelhante e ainda verificar a relação com as variáveis de clima. As setas indicam o efeito positivo ou negativo da variável. Por exemplo, o quadrante Q4 é caracterizado por valores altos de chuva e praticamente nenhum deficit hídrico. No oposto, temos o Q2 com baixa precipitação e alto déficit hídrico.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggbiplot(pca) +
  geom_point() +
  geom_vline(xintercept = 0, size = 1.2, linetype = 6) +
  geom_hline(yintercept = 0, size = 1.2, linetype = 6) +
  geom_label_repel(aes(label = dados$Cidade), size = 3, nudge_x = .2) +
  annotate(
    &amp;quot;text&amp;quot;,
    x = c(-2, 2, 2, -2),
    y = c(2, 2, -2, -2), 
    label = paste0(&amp;quot;Q&amp;quot;, 1:4), size = 6
  ) +
  lims(x = c(-2,2), y = c(-2,2)) +
  theme_bw()&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;figure&#34;&gt;&lt;span id=&#34;fig:8-pca&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;/post/2016-08-01-analise-de-componentes-principais_files/figure-html/8-pca-1.svg&#34; alt=&#34;Representação gráfica dos componentes principais.&#34; width=&#34;768&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figura  1: Representação gráfica dos componentes principais.
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Como também temos a informação do clima Koppen, podemos colorir o gráfico em função deste atributo (Figura &lt;a href=&#34;#fig:8-pca-koppen&#34;&gt;2&lt;/a&gt;).&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggbiplot(pca) +
  geom_point(aes(color = dados$Koppen)) +
  geom_vline(xintercept = 0, size = 1.2, linetype = 6) +
  geom_hline(yintercept = 0, size = 1.2, linetype = 6) +
  geom_label_repel(
    aes(color = dados$Koppen, label = dados$Cidade),
    size = 3, nudge_x = .2, show.legend = F
  ) +
  lims(x = c(-2,2), y = c(-2,2)) +
  scale_color_brewer(&amp;quot;Clima Koppen&amp;quot;, palette = &amp;quot;Dark2&amp;quot;) +
  theme_bw()+
  theme(legend.position = &amp;quot;top&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;figure&#34;&gt;&lt;span id=&#34;fig:8-pca-koppen&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;/post/2016-08-01-analise-de-componentes-principais_files/figure-html/8-pca-koppen-1.svg&#34; alt=&#34;Representação gráfica dos componentes principais com classificação Koppen.&#34; width=&#34;768&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figura  2: Representação gráfica dos componentes principais com classificação Koppen.
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Caso tenha alguma dúvida ou sugestão sobre o post, fique à vontade para fazer um comentário ou me contatar por E-mail.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;sessioninfo::session_info(c(&amp;quot;readr&amp;quot;, &amp;quot;dplyr&amp;quot;, &amp;quot;ggplot2&amp;quot;, &amp;quot;ggrepel&amp;quot;, &amp;quot;ggbiplot&amp;quot;))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## - Session info ----------------------------------------------------------
##  setting  value                       
##  version  R version 3.5.1 (2018-07-02)
##  os       Windows 10 x64              
##  system   x86_64, mingw32             
##  ui       RTerm                       
##  language (EN)                        
##  collate  Portuguese_Brazil.1252      
##  ctype    Portuguese_Brazil.1252      
##  tz       America/Sao_Paulo           
##  date     2018-12-31                  
## 
## - Packages --------------------------------------------------------------
##  package      * version  date       lib source                       
##  assertthat     0.2.0    2017-04-11 [1] CRAN (R 3.5.1)               
##  BH             1.66.0-1 2018-02-13 [1] CRAN (R 3.5.0)               
##  bindr          0.1.1    2018-03-13 [1] CRAN (R 3.5.1)               
##  bindrcpp       0.2.2    2018-03-29 [1] CRAN (R 3.5.1)               
##  cli            1.0.1    2018-09-25 [1] CRAN (R 3.5.1)               
##  clipr          0.4.1    2018-06-23 [1] CRAN (R 3.5.1)               
##  colorspace     1.3-2    2016-12-14 [1] CRAN (R 3.5.1)               
##  crayon         1.3.4    2017-09-16 [1] CRAN (R 3.5.1)               
##  digest         0.6.18   2018-10-10 [1] CRAN (R 3.5.1)               
##  dplyr        * 0.7.8    2018-11-10 [1] CRAN (R 3.5.1)               
##  fansi          0.4.0    2018-10-05 [1] CRAN (R 3.5.1)               
##  ggbiplot     * 0.55     2018-12-31 [1] Github (vqv/ggbiplot@7325e88)
##  ggplot2      * 3.1.0    2018-10-25 [1] CRAN (R 3.5.1)               
##  ggrepel      * 0.8.0    2018-05-09 [1] CRAN (R 3.5.1)               
##  glue           1.3.0    2018-07-17 [1] CRAN (R 3.5.1)               
##  gtable         0.2.0    2016-02-26 [1] CRAN (R 3.5.1)               
##  hms            0.4.2    2018-03-10 [1] CRAN (R 3.5.1)               
##  labeling       0.3      2014-08-23 [1] CRAN (R 3.5.0)               
##  lattice        0.20-35  2017-03-25 [2] CRAN (R 3.5.1)               
##  lazyeval       0.2.1    2017-10-29 [1] CRAN (R 3.5.1)               
##  magrittr       1.5      2014-11-22 [1] CRAN (R 3.5.1)               
##  MASS           7.3-50   2018-04-30 [2] CRAN (R 3.5.1)               
##  Matrix         1.2-14   2018-04-13 [2] CRAN (R 3.5.1)               
##  mgcv           1.8-24   2018-06-23 [2] CRAN (R 3.5.1)               
##  munsell        0.5.0    2018-06-12 [1] CRAN (R 3.5.1)               
##  nlme           3.1-137  2018-04-07 [2] CRAN (R 3.5.1)               
##  pillar         1.3.1    2018-12-15 [1] CRAN (R 3.5.2)               
##  pkgconfig      2.0.2    2018-08-16 [1] CRAN (R 3.5.1)               
##  plogr          0.2.0    2018-03-25 [1] CRAN (R 3.5.1)               
##  plyr         * 1.8.4    2016-06-08 [1] CRAN (R 3.5.1)               
##  purrr          0.2.5    2018-05-29 [1] CRAN (R 3.5.1)               
##  R6             2.3.0    2018-10-04 [1] CRAN (R 3.5.1)               
##  RColorBrewer   1.1-2    2014-12-07 [1] CRAN (R 3.5.0)               
##  Rcpp           1.0.0    2018-11-07 [1] CRAN (R 3.5.1)               
##  readr        * 1.2.1    2018-11-22 [1] CRAN (R 3.5.1)               
##  reshape2       1.4.3    2017-12-11 [1] CRAN (R 3.5.1)               
##  rlang          0.3.0.1  2018-10-25 [1] CRAN (R 3.5.1)               
##  scales       * 1.0.0    2018-08-09 [1] CRAN (R 3.5.1)               
##  stringi        1.2.4    2018-07-20 [1] CRAN (R 3.5.1)               
##  stringr        1.3.1    2018-05-10 [1] CRAN (R 3.5.1)               
##  tibble         1.4.2    2018-01-22 [1] CRAN (R 3.5.1)               
##  tidyselect     0.2.5    2018-10-11 [1] CRAN (R 3.5.1)               
##  utf8           1.1.4    2018-05-24 [1] CRAN (R 3.5.1)               
##  viridisLite    0.3.0    2018-02-01 [1] CRAN (R 3.5.1)               
##  withr          2.1.2    2018-03-15 [1] CRAN (R 3.5.1)               
## 
## [1] C:/Users/Italo/Documents/R/win-library/3.5
## [2] C:/Program Files/R/R-3.5.1/library&lt;/code&gt;&lt;/pre&gt;

      </content:encoded>
    </item>
    
  </channel>
</rss>
