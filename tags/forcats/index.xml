<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Forcats on Ítalo Cegatta</title>
    <link>/tags/forcats/</link>
    <description>Recent content in Forcats on Ítalo Cegatta</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>pt-br</language>
    <lastBuildDate>Sun, 15 Jul 2018 00:00:00 +0000</lastBuildDate>
    
        <atom:link href="/tags/forcats/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Risco de incêndio pela Fórmula de Monte Alegre</title>
      <link>/risco-de-incendio-pela-formula-de-monte-alegre/</link>
      <pubDate>Sun, 15 Jul 2018 00:00:00 +0000</pubDate>
      
      <guid>/risco-de-incendio-pela-formula-de-monte-alegre/</guid>
      <description>No setor florestal o fogo é uma questão recorrente e preocupante. Utilizar um índice de risco ou perigo de incêndio ajuda, no mínimo, no planejamento e no alerta para quem mora no entorno de maciços florestais como parques, hortos e plantios florestais.
A Fórmula de Monte Alegre (FMA) é um índice bastante simples, foi proposta em 1972 por Soares (1972) e utiliza apenas a umidade relativa do ar às 13h e a precipitação para calcular o risco de incêndio.</description>
      <content:encoded>
        


&lt;p&gt;No setor florestal o fogo é uma questão recorrente e preocupante. Utilizar um índice de risco ou perigo de incêndio ajuda, no mínimo, no planejamento e no alerta para quem mora no entorno de maciços florestais como parques, hortos e plantios florestais.&lt;/p&gt;
&lt;p&gt;A Fórmula de Monte Alegre (FMA) é um índice bastante simples, foi proposta em 1972 por &lt;span class=&#34;citation&#34;&gt;Soares (1972)&lt;/span&gt; e utiliza apenas a umidade relativa do ar às 13h e a precipitação para calcular o risco de incêndio. É um índice que possui 5 classes de risco e é cumulativo, portanto precisa ser calculado todos os dias.&lt;/p&gt;
&lt;p&gt;O objetivo deste post é implementar a FMA utilizando dados de 1988 à 2017 da estação meteorológica convencional da &lt;a href=&#34;http://www.esalq.usp.br/departamentos/leb/postocon.html&#34;&gt;ESALQ em Piracicaba&lt;/a&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;if (!require(&amp;quot;pacman&amp;quot;)) install.packages(&amp;quot;pacman&amp;quot;)
pacman::p_load(readr, dplyr, tidyr, forcats, lubridate, ggplot2, ggridges)&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;base &amp;lt;- read_csv2(
  &amp;quot;https://raw.githubusercontent.com/italocegatta/italocegatta.github.io_source/master/content/dados/posto_esalq_dia.csv&amp;quot;,
  col_types = cols(.default = col_number(), data = col_character())
)

base&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 10,961 x 3
##    data         ppt ur_med
##    &amp;lt;chr&amp;gt;      &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt;
##  1 01/01/1988   0       62
##  2 02/01/1988   0       65
##  3 03/01/1988   0       65
##  4 04/01/1988   0       69
##  5 05/01/1988  33.9     74
##  6 06/01/1988  66       90
##  7 07/01/1988   0       78
##  8 08/01/1988   0.5     88
##  9 09/01/1988  17.1     83
## 10 10/01/1988   7.8     83
## # ... with 10,951 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;O primeiro passo é estimar a umidade relativa às 13h, uma vez que é este valor que a FMA considera para o cálculo. Utilizaremos a equação ajustada por &lt;span class=&#34;citation&#34;&gt;Alvares et al. (2014)&lt;/span&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;base_fma &amp;lt;- base %&amp;gt;%
  mutate(
    data = dmy(data),
    ur13 = (8.77 * exp(0.024 * ur_med)) - 2.943
  ) %&amp;gt;% 
  select(data, ppt, ur13)

base_fma&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 10,961 x 3
##    data         ppt  ur13
##    &amp;lt;date&amp;gt;     &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt;
##  1 1988-01-01   0    35.9
##  2 1988-01-02   0    38.8
##  3 1988-01-03   0    38.8
##  4 1988-01-04   0    43.0
##  5 1988-01-05  33.9  48.9
##  6 1988-01-06  66    73.1
##  7 1988-01-07   0    54.1
##  8 1988-01-08   0.5  69.5
##  9 1988-01-09  17.1  61.3
## 10 1988-01-10   7.8  61.3
## # ... with 10,951 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Agora vamos fazer uma breve análise dos dados brutos. Começando pela chuva, podemos calcular o número médio de dias de chuva forte e fraca neste período. Entre julho e agosto há poucas chuvas em Piracicaba e isso já sugere que neste período o risco de incêndio deve ser alto.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;base_fma %&amp;gt;%
  mutate(ano = year(data), mes = month(data)) %&amp;gt;% 
  mutate(
    d_1 = ifelse(ppt &amp;gt; 1 &amp;amp; ppt &amp;lt;= 5, 1, 0),
    d_5 = ifelse(ppt &amp;gt; 5 , 1, 0)
  ) %&amp;gt;% 
  group_by(ano, mes) %&amp;gt;% 
  summarise_at(vars(d_1, d_5), sum, na.rm = TRUE) %&amp;gt;% 
  group_by(mes) %&amp;gt;% 
  summarise_at(vars(d_1, d_5), ~round(mean(.))) %&amp;gt;% 
  ungroup() %&amp;gt;% 
  rename(`&amp;lt;5` = d_1, `&amp;gt;5` = d_5) %&amp;gt;% 
  gather(nivel, d_chuva, `&amp;lt;5`:`&amp;gt;5`) %&amp;gt;% 
  mutate(
    d_chuva = ifelse(d_chuva == 0, NA, d_chuva),
    nivel = fct_relevel(nivel, &amp;quot;&amp;lt;5&amp;quot; , &amp;quot;&amp;gt;5&amp;quot;)
  ) %&amp;gt;% 
  ggplot(aes(mes, d_chuva, fill = nivel)) +
    geom_col(alpha = 0.8) +
    labs(
      x = &amp;quot;Mês do ano&amp;quot;,
      y = &amp;quot;Nº de dias de chuva (#)&amp;quot;,
      fill = NULL
    ) +
    scale_x_continuous(breaks = 1:12, labels = format(ISOdate(2000, 1:12, 1), &amp;quot;%b&amp;quot;)) +
    scale_y_continuous(breaks = seq(0, 30, 2), expand = expand_scale(mult = c(0.01, .1))) +
    scale_fill_manual(
      values = c(&amp;quot;#4292c6&amp;quot;, &amp;quot;#084594&amp;quot;),
      labels = c(&amp;quot;Chuva fraca (&amp;lt;5 mm)&amp;quot;,&amp;quot;Chuva forte (&amp;gt;5 mm)&amp;quot;)
    ) +
    theme_bw() +
    theme(legend.position = &amp;quot;top&amp;quot;, panel.grid.minor.x = element_blank())&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2018-07-15-risco-de-incendio-pela-formula-de-monte-alegre_files/figure-html/unnamed-chunk-4-1.svg&#34; width=&#34;960&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Olhando para a distribuição da umidade relativa em cada mês, podemos ver que em junho a mediana ainda está próximo dos 50% de umidade. E só em julho que os dias mais secos começam a ter mais frequência e essa tendência aumenta até setembro, depois retorna gradativamente até a mediana de 57% de umidade em dezembro.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;base_fma %&amp;gt;% 
  filter(!is.na(ur13)) %&amp;gt;% 
  mutate(mes = factor(month(data))) %&amp;gt;% 
  ggplot(aes(ur13, mes)) +
    geom_density_ridges(quantile_lines = TRUE, quantiles = 2, fill = &amp;quot;#016c59&amp;quot;, alpha = 0.9) +
    labs(x = &amp;quot;Umidade Relativa às 13h (%)&amp;quot;, y = &amp;quot;Mês do ano&amp;quot;) +
    scale_x_continuous(breaks = seq(10, 100, 10)) +
    scale_y_discrete(labels = format(ISOdate(2000, 1:12, 1), &amp;quot;%b&amp;quot;)) +
    theme_bw()&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2018-07-15-risco-de-incendio-pela-formula-de-monte-alegre_files/figure-html/unnamed-chunk-5-1.svg&#34; width=&#34;960&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Sobre a Fórmula de Monte Alegre, o contexto que motivou seu desenvolvimento foi bastante trágico. Em 1963 um grande incêndio atingiu o estado do Paraná, com centenas de mortes e cerca de 2 milhões de hectares de florestas queimadas. Em 1972 o Professor Ronaldo Soares, da UFPR, defendeu sua tese de mestrado propondo a Fórmula de Monte Alegre com base em registros de incêndios florestais coletados a partir de 1965 na fazenda Monte Alegre (Klabin), em Telêmaco Borba-PR.&lt;/p&gt;
&lt;p&gt;A cálculo do índice é bastante simples, basta calcular o valor FMA do dia corrente e somar com o valor do dia anterior. O FMA é calculado através da seguinte expressão:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.sciweavers.org/tex2img.php?eq=FMA%20%3D%20%20%5Csum_%7Bi%3D1%7D%5En%20%20%5Cfrac%7B100%7D%7BURi_%7B13h%7D%7D%20&amp;bc=White&amp;fc=Black&amp;im=jpg&amp;fs=12&amp;ff=arev&amp;edit=0&#34; align=&#34;center&#34; border=&#34;0&#34; alt=&#34;FMA =  \sum_{i=1}^n  \frac{100}{URi_{13h}} &#34; width=&#34;139&#34; height=&#34;62&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Entretanto é preciso aplicar restrições ao valor FMA de acordo com a chuva do dia, seguindo estes parâmetros:&lt;/p&gt;
&lt;table&gt;
&lt;colgroup&gt;
&lt;col width=&#34;14%&#34; /&gt;
&lt;col width=&#34;85%&#34; /&gt;
&lt;/colgroup&gt;
&lt;thead&gt;
&lt;tr class=&#34;header&#34;&gt;
&lt;th&gt;Precipitação&lt;/th&gt;
&lt;th&gt;Restrição&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td&gt;&amp;lt; 2,5&lt;/td&gt;
&lt;td&gt;Nenhuma&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td&gt;2,5 - 4,9&lt;/td&gt;
&lt;td&gt;0,7 * FMAi-1 + FMAi&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td&gt;5,0 - 9,9&lt;/td&gt;
&lt;td&gt;0,4 * FMAi-1 + FMAi&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td&gt;10,0 - 12,9&lt;/td&gt;
&lt;td&gt;0,2 * FMAi-1 + FMAi&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td&gt;&amp;gt; 12,9&lt;/td&gt;
&lt;td&gt;Interromper o cálculo anterior (FMAi = 0) e começar novo cálculo no dia seguinte&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;O resultado do índice é apresentado com frequência na forma de classes de risco, obedecendo estes limites:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr class=&#34;header&#34;&gt;
&lt;th&gt;FMA&lt;/th&gt;
&lt;th&gt;Grau de perigo&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td&gt;0 - 1,0&lt;/td&gt;
&lt;td&gt;Nulo&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td&gt;1,1 - 3,0&lt;/td&gt;
&lt;td&gt;Pequeno&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td&gt;3,1 - 8,0&lt;/td&gt;
&lt;td&gt;Médio&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td&gt;8,1 – 20,0&lt;/td&gt;
&lt;td&gt;Alto&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td&gt;&amp;gt; 20,0&lt;/td&gt;
&lt;td&gt;Muito alto&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Vamos agora declara as funções que vão calcular o FMA e atribuir as classes de risco aos nossos dados.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;fma &amp;lt;- function(data, ur, ppt) {
  
  # testa se os dados estão ordenados
  if (any(data != sort(data))) {
    stop(&amp;quot;data precisa estar em ordem crescente&amp;quot;)
  }

  # cria o vetor de resultado  
  n &amp;lt;- length(ur)
  fma_vec &amp;lt;- rep(NA_real_, n)
  
  for (i in seq_len(n)) {
    
    # primeiro valor eh 0   
    if (i == 1) {
      fma_vec[i] &amp;lt;- 0
      next()
    }
    
    # se dia anterior nao tem informacao, valor eh 0
    if (is.na(ur[i - 1])) {
      fma_vec[i] &amp;lt;- 0
      next()
    }
    
    # aplica restricoes da chuva
    fma_vec[i] &amp;lt;- case_when(
      ppt[i] &amp;lt; 2.5 ~ (100 / ur[i]) + fma_vec[i - 1] * 1 ,
      ppt[i] &amp;gt;= 2.5 &amp;amp; ppt[i] &amp;lt; 5  ~ (100 / ur[i]) + fma_vec[i - 1] * 0.7,
      ppt[i] &amp;gt;= 5   &amp;amp; ppt[i] &amp;lt; 10 ~ (100 / ur[i]) + fma_vec[i - 1] * 0.4,
      ppt[i] &amp;gt;= 10  &amp;amp; ppt[i] &amp;lt; 13 ~ (100 / ur[i]) + fma_vec[i - 1] * 0.2,
      ppt[i] &amp;gt;= 13 ~ 0
    )
  }
  
  fma_vec
}

fma_classe &amp;lt;- function(fma, limites = c(1, 3, 8, 20)) {
  
  classe &amp;lt;- case_when(
    fma &amp;lt;= 1 ~ &amp;quot;Nulo&amp;quot;,
    fma &amp;gt; 1 &amp;amp; fma &amp;lt;= 3 ~&amp;quot;Pequeno&amp;quot;,
    fma &amp;gt; 3 &amp;amp; fma &amp;lt;= 8 ~ &amp;quot;Médio&amp;quot;,
    fma &amp;gt; 8 &amp;amp; fma &amp;lt;= 20 ~ &amp;quot;Alto&amp;quot;,
    fma &amp;gt; 20 ~ &amp;quot;Muito Alto&amp;quot;
  )
  
  factor(classe, levels = c(&amp;quot;Nulo&amp;quot;, &amp;quot;Pequeno&amp;quot;, &amp;quot;Médio&amp;quot;, &amp;quot;Alto&amp;quot;, &amp;quot;Muito Alto&amp;quot;))
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Seguindo para o cálculo do índice, vamos criar um novo data frame com o valor FMA e as classes de riscos utilizando as funções que acabamos de criar.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;dados_fma &amp;lt;- base_fma %&amp;gt;% 
  mutate(
    fma = fma(data, ur13, ppt),
    risco = fma_classe(fma)
  )

dados_fma&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 10,961 x 5
##    data         ppt  ur13   fma risco  
##    &amp;lt;date&amp;gt;     &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;fct&amp;gt;  
##  1 1988-01-01   0    35.9  0    Nulo   
##  2 1988-01-02   0    38.8  2.58 Pequeno
##  3 1988-01-03   0    38.8  5.16 Médio  
##  4 1988-01-04   0    43.0  7.48 Médio  
##  5 1988-01-05  33.9  48.9  0    Nulo   
##  6 1988-01-06  66    73.1  0    Nulo   
##  7 1988-01-07   0    54.1  1.85 Pequeno
##  8 1988-01-08   0.5  69.5  3.29 Médio  
##  9 1988-01-09  17.1  61.3  0    Nulo   
## 10 1988-01-10   7.8  61.3  1.63 Pequeno
## # ... with 10,951 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A primeira abordagem que quero mostrar é a evolução do valor FMA ao longo do ano. Considerando o dia do ano ou dia juliano, podemos ver a evolução do valor FMA devido á ausência de chuvas fortes. O máximo dessa “corrida” de risco vai até próximo do dia 290, que corresponde ao meio de outubro.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;dados_fma %&amp;gt;% 
  mutate(
    ano = year(data),
    dia_ano = yday(data)
  ) %&amp;gt;% 
  ggplot(aes(dia_ano, factor(ano), fill = fma)) +
  geom_tile() +
  labs(x = &amp;quot;Dia do ano&amp;quot;, y = &amp;quot;Ano&amp;quot;, fill = &amp;quot;FMA&amp;quot;) +
  scale_fill_viridis_c(option = &amp;quot;viridis&amp;quot;) +
  scale_x_continuous(breaks = seq(20, 360, 20), expand = c(0, 0)) +
  theme_bw()&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2018-07-15-risco-de-incendio-pela-formula-de-monte-alegre_files/figure-html/unnamed-chunk-8-1.png&#34; width=&#34;960&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Calculando a frequência das classes dentro de cada ano, podemos ver que predomina o risco Muito Alto, seguido do risco Alto. O risco nulo, ocorre em aproximadamente 10% dos dias do ano.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;dados_fma  %&amp;gt;% 
  filter(!is.na(risco)) %&amp;gt;% 
  group_by(ano = year(data), risco) %&amp;gt;% 
  tally() %&amp;gt;% 
  ggplot(aes(ano, n, fill = risco)) +
  geom_col(position = &amp;quot;fill&amp;quot;, alpha = 0.8) +
  labs(x = &amp;quot;Ano&amp;quot;, y = &amp;quot;Frequência&amp;quot;, fill = &amp;quot;Risco&amp;quot;) +
  scale_y_continuous(breaks = seq(0.1, 1, 0.1), labels = scales::percent) +
  scale_fill_brewer(palette = &amp;quot;Spectral&amp;quot;, direction = -1) +
  theme_bw()&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2018-07-15-risco-de-incendio-pela-formula-de-monte-alegre_files/figure-html/unnamed-chunk-9-1.svg&#34; width=&#34;960&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Olhando para a frequência de risco dentro dos meses, fica claro o maior risco próximo do mês de agosto, como sugeriram os gráficos de frequências de chuva e umidade relativa.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;dados_fma  %&amp;gt;% 
  filter(!is.na(risco)) %&amp;gt;% 
  group_by(mes = month(data), risco) %&amp;gt;% 
  tally() %&amp;gt;% 
  ggplot(aes(mes, n, fill = risco)) +
  geom_col(position = &amp;quot;fill&amp;quot;, alpha = 0.8) +
  labs(x = &amp;quot;Mês do ano&amp;quot;, y = &amp;quot;Frequência&amp;quot;, fill = &amp;quot;Risco&amp;quot;) +
  scale_x_continuous(breaks = 1:12, labels = format(ISOdate(2000, 1:12, 1), &amp;quot;%b&amp;quot;)) +
  scale_y_continuous(labels = scales::percent) +
  scale_fill_brewer(palette = &amp;quot;Spectral&amp;quot;, direction = -1) +
  theme_bw()&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2018-07-15-risco-de-incendio-pela-formula-de-monte-alegre_files/figure-html/unnamed-chunk-10-1.svg&#34; width=&#34;960&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Bom, de maneira geral os gráficos não mostraram muita coisa nova. Todo mundo sabe que nos meses mais secos do ano o risco de incêndio é maior. De fato, o índice apenas dá um respaldo quantitativo para o senso comum. Uma vez calculado o índice, é possível confrontar com dados reais de incêndios e propor novos valores para as classes de risco com o objetivo de deixá-lo mais assertivo para uma certa região.&lt;/p&gt;
&lt;p&gt;Caso tenha alguma dúvida ou sugestão sobre o post, fique à vontade para fazer um comentário ou me contatar por E-mail.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;sessioninfo::session_info(c(&amp;quot;readr&amp;quot;, &amp;quot;dplyr&amp;quot;, &amp;quot;ggplot2&amp;quot;, &amp;quot;tidyr&amp;quot;, &amp;quot;forcats&amp;quot;, &amp;quot;lubridate&amp;quot;, &amp;quot;ggridges&amp;quot;))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## - Session info ----------------------------------------------------------
##  setting  value                       
##  version  R version 3.5.1 (2018-07-02)
##  os       Windows 10 x64              
##  system   x86_64, mingw32             
##  ui       RTerm                       
##  language (EN)                        
##  collate  Portuguese_Brazil.1252      
##  ctype    Portuguese_Brazil.1252      
##  tz       America/Sao_Paulo           
##  date     2018-12-31                  
## 
## - Packages --------------------------------------------------------------
##  package      * version  date       lib source        
##  assertthat     0.2.0    2017-04-11 [1] CRAN (R 3.5.1)
##  BH             1.66.0-1 2018-02-13 [1] CRAN (R 3.5.0)
##  bindr          0.1.1    2018-03-13 [1] CRAN (R 3.5.1)
##  bindrcpp     * 0.2.2    2018-03-29 [1] CRAN (R 3.5.1)
##  cli            1.0.1    2018-09-25 [1] CRAN (R 3.5.1)
##  clipr          0.4.1    2018-06-23 [1] CRAN (R 3.5.1)
##  colorspace     1.3-2    2016-12-14 [1] CRAN (R 3.5.1)
##  crayon         1.3.4    2017-09-16 [1] CRAN (R 3.5.1)
##  digest         0.6.18   2018-10-10 [1] CRAN (R 3.5.1)
##  dplyr        * 0.7.8    2018-11-10 [1] CRAN (R 3.5.1)
##  fansi          0.4.0    2018-10-05 [1] CRAN (R 3.5.1)
##  forcats      * 0.3.0    2018-02-19 [1] CRAN (R 3.5.1)
##  ggplot2      * 3.1.0    2018-10-25 [1] CRAN (R 3.5.1)
##  ggridges     * 0.5.1    2018-09-27 [1] CRAN (R 3.5.2)
##  glue           1.3.0    2018-07-17 [1] CRAN (R 3.5.1)
##  gtable         0.2.0    2016-02-26 [1] CRAN (R 3.5.1)
##  hms            0.4.2    2018-03-10 [1] CRAN (R 3.5.1)
##  labeling       0.3      2014-08-23 [1] CRAN (R 3.5.0)
##  lattice        0.20-35  2017-03-25 [2] CRAN (R 3.5.1)
##  lazyeval       0.2.1    2017-10-29 [1] CRAN (R 3.5.1)
##  lubridate    * 1.7.4    2018-04-11 [1] CRAN (R 3.5.1)
##  magrittr       1.5      2014-11-22 [1] CRAN (R 3.5.1)
##  MASS           7.3-50   2018-04-30 [2] CRAN (R 3.5.1)
##  Matrix         1.2-14   2018-04-13 [2] CRAN (R 3.5.1)
##  mgcv           1.8-24   2018-06-23 [2] CRAN (R 3.5.1)
##  munsell        0.5.0    2018-06-12 [1] CRAN (R 3.5.1)
##  nlme           3.1-137  2018-04-07 [2] CRAN (R 3.5.1)
##  pillar         1.3.1    2018-12-15 [1] CRAN (R 3.5.2)
##  pkgconfig      2.0.2    2018-08-16 [1] CRAN (R 3.5.1)
##  plogr          0.2.0    2018-03-25 [1] CRAN (R 3.5.1)
##  plyr           1.8.4    2016-06-08 [1] CRAN (R 3.5.1)
##  purrr          0.2.5    2018-05-29 [1] CRAN (R 3.5.1)
##  R6             2.3.0    2018-10-04 [1] CRAN (R 3.5.1)
##  RColorBrewer   1.1-2    2014-12-07 [1] CRAN (R 3.5.0)
##  Rcpp           1.0.0    2018-11-07 [1] CRAN (R 3.5.1)
##  readr        * 1.3.1    2018-12-21 [1] CRAN (R 3.5.2)
##  reshape2       1.4.3    2017-12-11 [1] CRAN (R 3.5.1)
##  rlang          0.3.0.1  2018-10-25 [1] CRAN (R 3.5.1)
##  scales         1.0.0    2018-08-09 [1] CRAN (R 3.5.1)
##  stringi        1.2.4    2018-07-20 [1] CRAN (R 3.5.1)
##  stringr        1.3.1    2018-05-10 [1] CRAN (R 3.5.1)
##  tibble         1.4.2    2018-01-22 [1] CRAN (R 3.5.1)
##  tidyr        * 0.8.2    2018-10-28 [1] CRAN (R 3.5.1)
##  tidyselect     0.2.5    2018-10-11 [1] CRAN (R 3.5.1)
##  utf8           1.1.4    2018-05-24 [1] CRAN (R 3.5.1)
##  viridisLite    0.3.0    2018-02-01 [1] CRAN (R 3.5.1)
##  withr          2.1.2    2018-03-15 [1] CRAN (R 3.5.1)
## 
## [1] C:/Users/Italo/Documents/R/win-library/3.5
## [2] C:/Program Files/R/R-3.5.1/library&lt;/code&gt;&lt;/pre&gt;
&lt;div id=&#34;referencias&#34; class=&#34;section level1 unnumbered&#34;&gt;
&lt;h1&gt;Referências&lt;/h1&gt;
&lt;div id=&#34;refs&#34; class=&#34;references&#34;&gt;
&lt;div id=&#34;ref-alvares2014&#34;&gt;
&lt;p&gt;Alvares, Clayton Alcarde, Italo Ramos Cegatta, Lucas Augusto Abra Vieira, Rafaela de Freitas Pavani, Eduardo Moré Mattos, Paulo Cesar Sentelhas, José Luiz Stape, and Ronaldo Viana Soares. 2014. “Perigo de Incêndio Florestal: Aplicação Da Fórmula de Monte Alegre E Avaliação Do Histórico Para Piracicaba, Sp.” &lt;em&gt;Scientia Forestalis, Piracicaba&lt;/em&gt; 42 (104): 511–22.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;ref-soares1972&#34;&gt;
&lt;p&gt;Soares, Ronaldo Viana. 1972. “Determinação de Um índice de Perigo de Incêndio Para a Região Centro Paranaense, Brasil. Turrialba, Costa Rica, Catie/Iica,. 72 P.” PhD thesis, Tese de Mestrado.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

      </content:encoded>
    </item>
    
    <item>
      <title>Qual Estado tem mais pau-rodado?</title>
      <link>/qual-estado-tem-mais-pau-rodado/</link>
      <pubDate>Sat, 24 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>/qual-estado-tem-mais-pau-rodado/</guid>
      <description>Em Cuiabá, cidade que nasci e cresci, pau-rodado é um substantivo que define pessoas que nasceram em outro Estado mas moram em Cuiabá e ali construíram suas vidas. Aliás, Cuiabá sempre foi conhecida por ser uma Cidade super acolhedora e talvez por isso todos encaram o dito pau-rodado de uma forma engraçada e sem qualquer sentido pejorativo.
Muito bem, meu interesse com este post é analisar o comportamento dos fluxos migratórios entre Estados e assim encontrar os Estados que tem mais e menos pau-rodado em sua população residente.</description>
      <content:encoded>
        


&lt;p&gt;Em Cuiabá, cidade que nasci e cresci, &lt;em&gt;pau-rodado&lt;/em&gt; é um substantivo que define pessoas que nasceram em outro Estado mas moram em Cuiabá e ali construíram suas vidas. Aliás, Cuiabá sempre foi conhecida por ser uma Cidade super acolhedora e talvez por isso todos encaram o dito &lt;em&gt;pau-rodado&lt;/em&gt; de uma forma engraçada e sem qualquer sentido pejorativo.&lt;/p&gt;
&lt;p&gt;Muito bem, meu interesse com este post é analisar o comportamento dos fluxos migratórios entre Estados e assim encontrar os Estados que tem mais e menos &lt;em&gt;pau-rodado&lt;/em&gt; em sua população residente. Serei breve e não vamos abordar todos os Estados, mas se você tiver curiosidade poderá aproveitar o código para uma análise mais ampla.&lt;/p&gt;
&lt;p&gt;A motivação partiu de uma matéria do &lt;a href=&#34;https://www.nexojornal.com.br/grafico/2017/12/01/Fluxos-migrat%C3%B3rios-a-distribui%C3%A7%C3%A3o-da-popula%C3%A7%C3%A3o-de-cada-estado-pelo-pa%C3%ADs&#34;&gt;Nexo Jornal&lt;/a&gt; sobre este tema, porém ao nível estadual. Depois de algumas horas tentando decifrar o site do IBGE, cheguei na &lt;a href=&#34;https://sidra.ibge.gov.br/tabela/1852&#34;&gt;página&lt;/a&gt; que informa a população residente, por lugar de nascimento e unidade da federação.&lt;/p&gt;
&lt;p&gt;Então vamos começar a análise carregando os pacotes do R necessários para este post.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;if (!require(&amp;quot;pacman&amp;quot;)) install.packages(&amp;quot;pacman&amp;quot;)
pacman::p_load(readr, dplyr, tidyr, forcats, sf, geosphere, brmap, ggplot2, ggrepel, geofacet)
pacman::p_load_gh(&amp;quot;italocegatta/brmap&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Os dados originais estão disponíveis neste &lt;a href=&#34;https://sidra.ibge.gov.br/tabela/1852&#34;&gt;link&lt;/a&gt;, fiz apenas adequações porque o IBGE insiste em mesclar células nas tabelas disponibilizadas. Já nesta tabela você consegue olhar para o Estado que você mora e analisar quanto dos residentes nasceram em outros Estados. Mas o objetivo é enxergar isso de forma gráfica para ampliar a percepção dos dados.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;base &amp;lt;- read_csv2(&amp;quot;https://raw.githubusercontent.com/italocegatta/italocegatta.github.io_source/master/content/dados/pnad_2015_migracao.csv&amp;quot;)

base&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 27 x 28
##    Estado Rondônia  Acre Amazonas Roraima  Pará Amapá Tocantins Maranhão
##    &amp;lt;chr&amp;gt;     &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt;    &amp;lt;dbl&amp;gt;   &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt;     &amp;lt;dbl&amp;gt;    &amp;lt;dbl&amp;gt;
##  1 Rondô~    57.4   1.84     1.9     0.08  0.7  NA        0.02      1.02
##  2 Acre       1.54 87.9      3.89    0.02  0.17 NA        0.02      0.11
##  3 Amazo~     0.46  1.6     87.6     0.23  5.36  0.13     0.06      0.87
##  4 Rorai~     0.65  0.24     5.16   55.6   6.54  0.04     0.570    19.0 
##  5 Pará       0.03  0.02     0.49    0.02 84.6   0.19     1.07      6.89
##  6 Amapá      0.1   0.03     0.2     0.17 20.8  72.7      0.1       3.65
##  7 Tocan~     0.07  0.07     0.02   NA     2.83  0.02    69.5       8.58
##  8 Maran~     0.03  0.01     0.05   NA     1.11  0.01     0.32     92.4 
##  9 Piauí      0.04  0.02     0.04    0.05  0.28 NA        0.11      3.97
## 10 Ceará      0.03  0.04     0.11   NA     0.22  0.01     0.03      0.35
## # ... with 17 more rows, and 19 more variables: Piauí &amp;lt;dbl&amp;gt;, Ceará &amp;lt;dbl&amp;gt;,
## #   `Rio Grande do Norte` &amp;lt;dbl&amp;gt;, Paraíba &amp;lt;dbl&amp;gt;, Pernambuco &amp;lt;dbl&amp;gt;,
## #   Alagoas &amp;lt;dbl&amp;gt;, Sergipe &amp;lt;dbl&amp;gt;, Bahia &amp;lt;dbl&amp;gt;, `Minas Gerais` &amp;lt;dbl&amp;gt;,
## #   `Espírito Santo` &amp;lt;dbl&amp;gt;, `Rio de Janeiro` &amp;lt;dbl&amp;gt;, `São Paulo` &amp;lt;dbl&amp;gt;,
## #   Paraná &amp;lt;dbl&amp;gt;, `Santa Catarina` &amp;lt;dbl&amp;gt;, `Rio Grande do Sul` &amp;lt;dbl&amp;gt;, `Mato
## #   Grosso do Sul` &amp;lt;dbl&amp;gt;, `Mato Grosso` &amp;lt;dbl&amp;gt;, Goiás &amp;lt;dbl&amp;gt;, `Distrito
## #   Federal` &amp;lt;dbl&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Dados longitudinais como estes ajudam humanos a enxergar os valores de forma mais fácil, mas do ponto de vista de processamento de dados, não dá pra fazer muita coisa com os dados assim. Vamos organizá-los seguindo a filosofia do &lt;a href=&#34;https://italocegatta.github.io/o-conceito-tidy-data&#34;&gt;Tidy data&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;A nova tabela nos informa a porcentagem da população residente (coluna ‘valor’) para cada Estado, subdividindo os valores por local de nascimento. E agora vai a primeira simplificação: foram selecionados apenas os 6 Estados de nascimento mais representativos para cada Estado de residência.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;df &amp;lt;- base %&amp;gt;% 
  gather(reside, valor, -Estado) %&amp;gt;%
  select(nasce = Estado, reside, valor) %&amp;gt;% 
  replace_na(list(valor = 0)) %&amp;gt;% 
  group_by(nasce) %&amp;gt;% 
  filter(row_number(-valor) &amp;lt;= 6) %&amp;gt;% 
  ungroup()

df&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 162 x 3
##    nasce    reside   valor
##    &amp;lt;chr&amp;gt;    &amp;lt;chr&amp;gt;    &amp;lt;dbl&amp;gt;
##  1 Rondônia Rondônia 57.4 
##  2 Acre     Rondônia  1.54
##  3 Amazonas Rondônia  0.46
##  4 Acre     Acre     87.9 
##  5 Amazonas Acre      1.6 
##  6 Acre     Amazonas  3.89
##  7 Amazonas Amazonas 87.6 
##  8 Roraima  Amazonas  5.16
##  9 Roraima  Roraima  55.6 
## 10 Amazonas Pará      5.36
## # ... with 152 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Vamos nos preparar para a segunda simplificação: selecionar os extremos em termos de população que nasceu e reside no mesmo Estado. Então, RS, CE e PE são os Estados que mais tem moradores nascidos dentro do próprio Estado, enquanto RO, RR e DF tem uma parcela maior de residentes nascidos em outros Estados.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;estados_interesse &amp;lt;- df %&amp;gt;%
  filter(reside == nasce) %&amp;gt;%
  filter(row_number(-valor) &amp;lt;= 3 | row_number(valor) &amp;lt;= 3) %&amp;gt;% 
  arrange(-valor) %&amp;gt;%
  pull(nasce)

estados_interesse&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;Rio Grande do Sul&amp;quot; &amp;quot;Ceará&amp;quot;             &amp;quot;Pernambuco&amp;quot;       
## [4] &amp;quot;Rondônia&amp;quot;          &amp;quot;Roraima&amp;quot;           &amp;quot;Distrito Federal&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Preparando para o mapa, vamos pegar as coordenadas dos centroides de cada Estado.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;estado_cent &amp;lt;- brmap_estado %&amp;gt;% 
  st_centroid() %&amp;gt;% 
  cbind(., st_coordinates(.)) %&amp;gt;% 
  st_set_geometry(NULL) %&amp;gt;% 
  select(estado = estado_nome, lon = X, lat = Y)

estado_cent&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##                 estado       lon        lat
## 1             Rondônia -62.84197 -10.913218
## 2                 Acre -70.47328  -9.212886
## 3             Amazonas -64.65314  -4.154177
## 4              Roraima -61.39928   2.084226
## 5                 Pará -53.06424  -3.974791
## 6                Amapá -51.95592   1.443319
## 7            Tocantins -48.32923 -10.150316
## 8             Maranhão -45.27922  -5.061285
## 9                Piauí -42.96862  -7.387530
## 10               Ceará -39.61569  -5.093345
## 11 Rio Grande do Norte -36.67348  -5.839677
## 12             Paraíba -36.83262  -7.121055
## 13          Pernambuco -37.99843  -8.326066
## 14             Alagoas -36.62494  -9.513863
## 15             Sergipe -37.44390 -10.584475
## 16               Bahia -41.72094 -12.475023
## 17        Minas Gerais -44.67343 -18.456187
## 18      Espírito Santo -40.67106 -19.575176
## 19      Rio de Janeiro -42.65238 -22.188741
## 20           São Paulo -48.73391 -22.263472
## 21              Paraná -51.61668 -24.635899
## 22      Santa Catarina -50.47480 -27.247356
## 23   Rio Grande do Sul -53.32029 -29.705681
## 24  Mato Grosso do Sul -54.84563 -20.327310
## 25         Mato Grosso -55.91215 -12.948967
## 26               Goiás -49.62361 -16.042227
## 27    Distrito Federal -47.79736 -15.780692&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;E agora, o pulo do gato. Vamos criar as linhas que ligam os Estados entre si e em seguida adicionar à tabela que informa as relações de fluxo. Portanto, para cada relação entre Estado de nascimento/residência temos uma feição de linha e o valor que representa a porcentagem de residentes.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;coord &amp;lt;- df %&amp;gt;% 
  left_join(estado_cent, by = c(&amp;quot;nasce&amp;quot; = &amp;quot;estado&amp;quot;)) %&amp;gt;% 
  left_join(estado_cent, by = c(&amp;quot;reside&amp;quot; = &amp;quot;estado&amp;quot;)) %&amp;gt;%
  filter(nasce %in% estados_interesse)

linhas &amp;lt;- gcIntermediate(
  select(coord, lon.x, lat.x), 
  select(coord, lon.y, lat.y), 
  sp = TRUE, addStartEnd = TRUE
  ) %&amp;gt;% 
  st_as_sf()

fluxo_linha &amp;lt;- coord %&amp;gt;% 
  select(nasce, reside, valor) %&amp;gt;% 
  bind_cols(linhas) %&amp;gt;% 
  left_join(estado_cent, by = c(&amp;quot;reside&amp;quot; = &amp;quot;estado&amp;quot;)) %&amp;gt;% 
  mutate(nasce = fct_relevel(nasce, estados_interesse)) %&amp;gt;% 
  st_as_sf()

fluxo_linha&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Simple feature collection with 36 features and 5 fields
## geometry type:  LINESTRING
## dimension:      XY
## bbox:           xmin: -64.65314 ymin: -29.70568 xmax: -36.62494 ymax: 2.084226
## epsg (SRID):    4326
## proj4string:    +proj=longlat +ellps=WGS84 +no_defs
## # A tibble: 36 x 6
##    nasce    reside  valor   lon    lat                             geometry
##    &amp;lt;fct&amp;gt;    &amp;lt;chr&amp;gt;   &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt;                    &amp;lt;LINESTRING [Â°]&amp;gt;
##  1 Rondônia Rondôn~ 57.4  -62.8 -10.9  (-62.84197 -10.91322, -62.84197 -10~
##  2 Roraima  Amazon~  5.16 -64.7  -4.15 (-61.39928 2.084226, -61.46308 1.96~
##  3 Roraima  Roraima 55.6  -61.4   2.08 (-61.39928 2.084226, -61.39928 2.08~
##  4 Roraima  Pará     6.54 -53.1  -3.97 (-61.39928 2.084226, -61.23584 1.96~
##  5 Roraima  Maranh~ 19.0  -45.3  -5.06 (-61.39928 2.084226, -61.08344 1.94~
##  6 Distrit~ Maranh~  4.42 -45.3  -5.06 (-47.79736 -15.78069, -47.74601 -15~
##  7 Ceará    Piauí    0.39 -43.0  -7.39 (-39.61569 -5.093345, -39.68117 -5.~
##  8 Distrit~ Piauí    5.08 -43.0  -7.39 (-47.79736 -15.78069, -47.69952 -15~
##  9 Roraima  Ceará    2.76 -39.6  -5.09 (-61.39928 2.084226, -60.97249 1.94~
## 10 Ceará    Ceará   95.8  -39.6  -5.09 (-39.61569 -5.093345, -39.61569 -5.~
## # ... with 26 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Para deixar o gráfico um pouco mais bonito, vamos dar cor ao valor que estamos estudando. Mas agora a feição será o polígono que representa o Estado de residentes.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;fluxo_poligono &amp;lt;- brmap_estado %&amp;gt;% 
  left_join(df, by =  c(&amp;quot;estado_nome&amp;quot; = &amp;quot;reside&amp;quot;)) %&amp;gt;% 
  rename(reside = estado_nome) %&amp;gt;% 
  filter(nasce %in% estados_interesse) %&amp;gt;% 
  mutate(nasce = fct_relevel(nasce, estados_interesse)) %&amp;gt;% 
  select(nasce, reside, valor)

fluxo_poligono&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Simple feature collection with 36 features and 3 fields
## geometry type:  POLYGON
## dimension:      XY
## bbox:           xmin: -73.80156 ymin: -33.75118 xmax: -34.79288 ymax: 5.271841
## epsg (SRID):    4674
## proj4string:    +proj=longlat +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +no_defs
## # A tibble: 36 x 4
##    nasce       reside  valor                                       geometry
##    &amp;lt;fct&amp;gt;       &amp;lt;chr&amp;gt;   &amp;lt;dbl&amp;gt;                                 &amp;lt;POLYGON [Â°]&amp;gt;
##  1 Rondônia    Rondôn~ 57.4  ((-62.86662 -7.975868, -62.86017 -7.982323, -~
##  2 Roraima     Amazon~  5.16 ((-67.32609 2.029714, -67.31682 2.00125, -67.~
##  3 Roraima     Roraima 55.6  ((-60.20051 5.264343, -60.19828 5.260453, -60~
##  4 Roraima     Pará     6.54 ((-54.95431 2.583692, -54.93542 2.518585, -54~
##  5 Roraima     Maranh~ 19.0  ((-45.84073 -1.045485, -45.84099 -1.046971, -~
##  6 Distrito F~ Maranh~  4.42 ((-45.84073 -1.045485, -45.84099 -1.046971, -~
##  7 Ceará       Piauí    0.39 ((-41.74605 -2.803497, -41.74241 -2.805697, -~
##  8 Distrito F~ Piauí    5.08 ((-41.74605 -2.803497, -41.74241 -2.805697, -~
##  9 Roraima     Ceará    2.76 ((-40.49717 -2.784509, -40.49173 -2.788106, -~
## 10 Ceará       Ceará   95.8  ((-40.49717 -2.784509, -40.49173 -2.788106, -~
## # ... with 26 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Pronto, já temos todos os dados que fazer o gráfico de interesse. Lembrando que optamos por dar destaque a 6 Estados e para cada um deles, os 6 Estados de nascimento que mais representam a população de residentes. Sim, é um tanto complexo. Eu fiquei algumas horas para poder criar o código e entender o que estava processando.&lt;/p&gt;
&lt;p&gt;Como exemplo vamos interpretar as informações de Roraima: do total de residentes, 55.6% nasceram no próprio Estado de Roraima; 5.2%, 6.5% e 19% nasceram no Amazonas, Pará e Maranhão, respectivamente.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggplot() +
  geom_sf(data = brmap_estado, color = &amp;quot;white&amp;quot;, fill = &amp;quot;grey80&amp;quot;, size = 0.3) +
  geom_sf(data = fluxo_poligono, aes(fill = valor), color = &amp;quot;white&amp;quot;, size = 0.3) +
  geom_sf(data = fluxo_linha, color = &amp;quot;cyan&amp;quot;, size = 0.3) +
  geom_label_repel(
    data = fluxo_linha,
    aes(lon, lat, label = round(valor, 1)),
    size = 3, segment.colour = NA
  ) +
  facet_wrap(~nasce) +
  labs(
    title = &amp;quot;População residente (% do total geral)&amp;quot;,
    subtitle = &amp;quot;PNAD/IBGE, 2015&amp;quot;,
    x = NULL, y = NULL
  ) +
  scale_fill_viridis_c(guide = FALSE) +
  coord_sf(datum = NA) +
  theme_void(16)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2018-03-24-qual-estado-tem-mais-pau-rodado_files/figure-html/unnamed-chunk-9-1.svg&#34; width=&#34;960&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Pontos interessantes:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Rondônia e Roraima retém uma proporção parecida da população dentro do próprio Estado, entretanto o pessoal que mora em Rondônia veio do Sul e Sudeste; ao passo que os moradores de Roraima vêm do AM, PA e MA.&lt;/li&gt;
&lt;li&gt;O Distrito Federal não me surpreendeu, grande parte de pessoas nasceram em GO, MG e BA.&lt;/li&gt;
&lt;li&gt;Um número expressivo de pessoas que nasceram em São Paulo e hoje moram no CE e PE… parece que o jogo virou, não é mesmo?&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Caso tenha alguma dúvida ou sugestão sobre o post, fique à vontade para fazer um comentário ou me contatar por E-mail.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;sessioninfo::session_info(c(&amp;quot;readr&amp;quot;, &amp;quot;dplyr&amp;quot;, &amp;quot;ggplot2&amp;quot;, &amp;quot;tidyr&amp;quot;, &amp;quot;forcats&amp;quot;, &amp;quot;sf&amp;quot;, &amp;quot;geosphere&amp;quot;, &amp;quot;ggrepel&amp;quot;, &amp;quot;geofacet&amp;quot;, &amp;quot;brmap&amp;quot;))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## - Session info ----------------------------------------------------------
##  setting  value                       
##  version  R version 3.5.1 (2018-07-02)
##  os       Windows 10 x64              
##  system   x86_64, mingw32             
##  ui       RTerm                       
##  language (EN)                        
##  collate  Portuguese_Brazil.1252      
##  ctype    Portuguese_Brazil.1252      
##  tz       America/Sao_Paulo           
##  date     2018-12-31                  
## 
## - Packages --------------------------------------------------------------
##  package       * version     date       lib
##  assertthat      0.2.0       2017-04-11 [1]
##  BH              1.66.0-1    2018-02-13 [1]
##  bindr           0.1.1       2018-03-13 [1]
##  bindrcpp      * 0.2.2       2018-03-29 [1]
##  brmap         * 0.0.5       2018-09-16 [1]
##  class           7.3-14      2015-08-30 [2]
##  classInt        0.3-1       2018-12-18 [1]
##  cli             1.0.1       2018-09-25 [1]
##  clipr           0.4.1       2018-06-23 [1]
##  colorspace      1.3-2       2016-12-14 [1]
##  crayon          1.3.4       2017-09-16 [1]
##  curl            3.2         2018-03-28 [1]
##  DBI             1.0.0       2018-05-02 [1]
##  digest          0.6.18      2018-10-10 [1]
##  dplyr         * 0.7.8       2018-11-10 [1]
##  e1071           1.7-0       2018-07-28 [1]
##  fansi           0.4.0       2018-10-05 [1]
##  forcats       * 0.3.0       2018-02-19 [1]
##  geofacet      * 0.1.9       2018-03-29 [1]
##  geogrid         0.1.1       2018-12-11 [1]
##  geosphere     * 1.5-7       2017-11-05 [1]
##  ggplot2       * 3.1.0       2018-10-25 [1]
##  ggrepel       * 0.8.0       2018-05-09 [1]
##  glue            1.3.0       2018-07-17 [1]
##  gridExtra       2.3         2017-09-09 [1]
##  gtable          0.2.0       2016-02-26 [1]
##  hms             0.4.2       2018-03-10 [1]
##  httr            1.4.0       2018-12-11 [1]
##  imguR           1.0.3       2016-03-29 [1]
##  jpeg            0.1-8       2014-01-23 [1]
##  jsonlite        1.6         2018-12-07 [1]
##  labeling        0.3         2014-08-23 [1]
##  lattice         0.20-35     2017-03-25 [2]
##  lazyeval        0.2.1       2017-10-29 [1]
##  magrittr        1.5         2014-11-22 [1]
##  MASS            7.3-50      2018-04-30 [2]
##  Matrix          1.2-14      2018-04-13 [2]
##  mgcv            1.8-24      2018-06-23 [2]
##  mime            0.6         2018-10-05 [1]
##  munsell         0.5.0       2018-06-12 [1]
##  nlme            3.1-137     2018-04-07 [2]
##  openssl         1.1         2018-11-15 [1]
##  pillar          1.3.1       2018-12-15 [1]
##  pkgconfig       2.0.2       2018-08-16 [1]
##  plogr           0.2.0       2018-03-25 [1]
##  plyr            1.8.4       2016-06-08 [1]
##  png             0.1-7       2013-12-03 [1]
##  purrr           0.2.5       2018-05-29 [1]
##  R6              2.3.0       2018-10-04 [1]
##  RColorBrewer    1.1-2       2014-12-07 [1]
##  Rcpp            1.0.0       2018-11-07 [1]
##  RcppArmadillo   0.9.200.5.0 2018-11-28 [1]
##  readr         * 1.3.1       2018-12-21 [1]
##  reshape2        1.4.3       2017-12-11 [1]
##  rgeos           0.4-2       2018-11-08 [1]
##  rlang           0.3.0.1     2018-10-25 [1]
##  rnaturalearth   0.1.0       2017-03-21 [1]
##  scales          1.0.0       2018-08-09 [1]
##  sf            * 0.7-2       2018-12-20 [1]
##  sp              1.3-1       2018-06-05 [1]
##  stringi         1.2.4       2018-07-20 [1]
##  stringr         1.3.1       2018-05-10 [1]
##  tibble          1.4.2       2018-01-22 [1]
##  tidyr         * 0.8.2       2018-10-28 [1]
##  tidyselect      0.2.5       2018-10-11 [1]
##  units           0.6-2       2018-12-05 [1]
##  utf8            1.1.4       2018-05-24 [1]
##  viridisLite     0.3.0       2018-02-01 [1]
##  withr           2.1.2       2018-03-15 [1]
##  source                             
##  CRAN (R 3.5.1)                     
##  CRAN (R 3.5.0)                     
##  CRAN (R 3.5.1)                     
##  CRAN (R 3.5.1)                     
##  Github (italocegatta/brmap@181fc73)
##  CRAN (R 3.5.1)                     
##  CRAN (R 3.5.2)                     
##  CRAN (R 3.5.1)                     
##  CRAN (R 3.5.1)                     
##  CRAN (R 3.5.1)                     
##  CRAN (R 3.5.1)                     
##  CRAN (R 3.5.1)                     
##  CRAN (R 3.5.1)                     
##  CRAN (R 3.5.1)                     
##  CRAN (R 3.5.1)                     
##  CRAN (R 3.5.1)                     
##  CRAN (R 3.5.1)                     
##  CRAN (R 3.5.1)                     
##  CRAN (R 3.5.2)                     
##  CRAN (R 3.5.2)                     
##  CRAN (R 3.5.2)                     
##  CRAN (R 3.5.1)                     
##  CRAN (R 3.5.1)                     
##  CRAN (R 3.5.1)                     
##  CRAN (R 3.5.1)                     
##  CRAN (R 3.5.1)                     
##  CRAN (R 3.5.1)                     
##  CRAN (R 3.5.2)                     
##  CRAN (R 3.5.1)                     
##  CRAN (R 3.5.0)                     
##  CRAN (R 3.5.2)                     
##  CRAN (R 3.5.0)                     
##  CRAN (R 3.5.1)                     
##  CRAN (R 3.5.1)                     
##  CRAN (R 3.5.1)                     
##  CRAN (R 3.5.1)                     
##  CRAN (R 3.5.1)                     
##  CRAN (R 3.5.1)                     
##  CRAN (R 3.5.1)                     
##  CRAN (R 3.5.1)                     
##  CRAN (R 3.5.1)                     
##  CRAN (R 3.5.1)                     
##  CRAN (R 3.5.2)                     
##  CRAN (R 3.5.1)                     
##  CRAN (R 3.5.1)                     
##  CRAN (R 3.5.1)                     
##  CRAN (R 3.5.0)                     
##  CRAN (R 3.5.1)                     
##  CRAN (R 3.5.1)                     
##  CRAN (R 3.5.0)                     
##  CRAN (R 3.5.1)                     
##  CRAN (R 3.5.2)                     
##  CRAN (R 3.5.2)                     
##  CRAN (R 3.5.1)                     
##  CRAN (R 3.5.1)                     
##  CRAN (R 3.5.1)                     
##  CRAN (R 3.5.1)                     
##  CRAN (R 3.5.1)                     
##  CRAN (R 3.5.2)                     
##  CRAN (R 3.5.1)                     
##  CRAN (R 3.5.1)                     
##  CRAN (R 3.5.1)                     
##  CRAN (R 3.5.1)                     
##  CRAN (R 3.5.1)                     
##  CRAN (R 3.5.1)                     
##  CRAN (R 3.5.2)                     
##  CRAN (R 3.5.1)                     
##  CRAN (R 3.5.1)                     
##  CRAN (R 3.5.1)                     
## 
## [1] C:/Users/Italo/Documents/R/win-library/3.5
## [2] C:/Program Files/R/R-3.5.1/library&lt;/code&gt;&lt;/pre&gt;

      </content:encoded>
    </item>
    
    <item>
      <title>Como um cientista de dados pesquisa o carro que quer comprar?</title>
      <link>/como-um-cientista-de-dados-pesquisa-o-carro-que-quer-comprar/</link>
      <pubDate>Sat, 29 Jul 2017 00:00:00 +0000</pubDate>
      
      <guid>/como-um-cientista-de-dados-pesquisa-o-carro-que-quer-comprar/</guid>
      <description>Estou naquela parte da vida em que se planeja comprar um carro. Como eu sou, acima de todos os sonhos, pão duro, decidir qual marca, modelo, versão e ano do veículo não vai ser fácil. Pensando nisso resolvi escrever um pacote no R para me ajudar a tomar esta decisão. O objetivo deste post é apresentar o pacote e as funções que auxiliam na coleta das informações da tabela FIPE.</description>
      <content:encoded>
        


&lt;p&gt;Estou naquela parte da vida em que se planeja comprar um carro. Como eu sou, acima de todos os sonhos, pão duro, decidir qual marca, modelo, versão e ano do veículo não vai ser fácil. Pensando nisso resolvi escrever um pacote no R para me ajudar a tomar esta decisão. O objetivo deste post é apresentar o pacote e as funções que auxiliam na coleta das informações da tabela &lt;a href=&#34;http://veiculos.fipe.org.br/&#34;&gt;FIPE&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Para aqueles que já passaram pela etapa de compra ou venda de um carro, provavelmente já consultaram a famosa tabela. Nas palavras do próprio site da FIPE:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A Tabela Fipe expressa preços médios de veículos no mercado nacional, servindo apenas como um parâmetro para negociações ou avaliações. Os preços efetivamente praticados variam em função da região, conservação, cor, acessórios ou qualquer outro fator que possa influenciar as condições de oferta e procura por um veículo específico.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;A motivação para este pacote foi exclusivamente pessoal e por isso a utilização das funções está bastante restrita. Por isso, se alguém quiser ajudar no desenvolvimento do pacote é só chegar e mandar um &lt;a href=&#34;https://github.com/italocegatta/fipe&#34;&gt;Pull Request&lt;/a&gt; no Github, contribuições serão muito bem-vindas.&lt;/p&gt;
&lt;p&gt;Primeiro vou mostrar as funções e o workflow idealizado para o pacote. Queremos saber, por enquanto, o preço atual de uma BMW X6 M ano 2015. O primeiro passo é definir o mês de referência que se deseja consultar o preço do veículo. A FIPE disponibiliza os valores consolidados desde janeiro de 2001.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;if (!require(&amp;quot;pacman&amp;quot;)) install.packages(&amp;quot;pacman&amp;quot;)
pacman::p_load(dplyr, purrr, stringr, tidyr, forcats, ggplot2)
pacman::p_load_gh(&amp;quot;italocegatta/fipe&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;fipe_referencia()&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 216 x 2
##    data_ref   cod_ref
##    &amp;lt;date&amp;gt;       &amp;lt;int&amp;gt;
##  1 2018-12-01     236
##  2 2018-11-01     235
##  3 2018-10-01     234
##  4 2018-09-01     233
##  5 2018-08-01     232
##  6 2018-07-01     231
##  7 2018-06-01     230
##  8 2018-05-01     229
##  9 2018-04-01     228
## 10 2018-03-01     227
## # ... with 206 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Como o objetivo saber o preço atual do veículo, pegaremos o código &lt;code&gt;215&lt;/code&gt; (mês em que escrevo este post). Agora vamos procurar o código da marca BMW. Note que precisamos inserir o código do mês de referência para consultar a marca, essa é uma exigência do site da FIPE. Lembrando que o pacote não possui nenhum banco de dados armazenado, todas as informações são consultadas no site da tabela FIPE no ato da execução da função.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;fipe_marca(cod_ref = 215)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 87 x 2
##    marca        cod_marca
##    &amp;lt;chr&amp;gt;            &amp;lt;int&amp;gt;
##  1 Acura                1
##  2 Agrale               2
##  3 Alfa Romeo           3
##  4 AM Gen               4
##  5 Asia Motors          5
##  6 ASTON MARTIN       189
##  7 Audi                 6
##  8 BMW                  7
##  9 BRM                  8
## 10 Buggy                9
## # ... with 77 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Por sorte, o código &lt;code&gt;7&lt;/code&gt; da BMW aparece logo nos primeiros valores por ordem alfabética. Podemos seguir para o próximo passo e pegar o código do modelo que queremos. A consulta a baixo mostras que a BMW tem 221 modelos cadastrados na tabela FIPE. Como já definimos o modelo que queremos, vamos filtrar do dataframe para enxergar o código do modelo.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;(bmw &amp;lt;- fipe_modelo(cod_ref = 215, cod_marca = 7))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 221 x 2
##    modelo                                 cod_modelo
##    &amp;lt;chr&amp;gt;                                       &amp;lt;int&amp;gt;
##  1 116iA 1.6 TB 16V 136cv 5p                    6146
##  2 118iA 2.0 16V 136cv 3p                       5576
##  3 118iA 2.0 16V 136cv 5p                       4960
##  4 118iA Full 1.6 TB 16V 170cv 5p               6147
##  5 118iA/ Urban/Sport 1.6 TB 16V 170cv 5p       5923
##  6 120i 2.0 16V 150cv/ 156cv 5p                  152
##  7 120iA 2.0 16V 150cv/ 156cv 5p                 153
##  8 120iA 2.0 16V 156cv 3p                       4700
##  9 120iA Cabrio 2.0 16V 156cv 2p                4683
## 10 120iA Sport 2.0/ActiveFlex 16V Aut.          7178
## # ... with 211 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;filter(bmw, str_detect(modelo, &amp;quot;X6 M&amp;quot;))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 1 x 2
##   modelo                            cod_modelo
##   &amp;lt;chr&amp;gt;                                  &amp;lt;int&amp;gt;
## 1 X6 M 4.4 4x4 V8 32V Bi-Turbo Aut.       5189&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Pronto, agora já sabemos que o código que a FIPE dá para o modelo X6 M é o &lt;code&gt;5189&lt;/code&gt;. Teríamos tudo pronto, se não fosse o padrão que a FIPE adota no campo&lt;code&gt;ano&lt;/code&gt;, onde o ano do modelo é acrescido de um código de combustível. A diferenciação para os “0 km” é feita na mesma coluna, utilizando a identificação 32000-*. Enfim, contornando as falhas estruturais no banco de dados deles, agora sabemos os códigos que identificam o ano do modelo, bem como o carro 0 km. Como eu optei por procurar o valor do carro 2015, iremos considerar o código &lt;code&gt;2015-1&lt;/code&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;fipe_ano(cod_ref = 215, cod_marca = 7, cod_modelo = 5189)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 9 x 2
##   ano   cod_ano
##   &amp;lt;chr&amp;gt; &amp;lt;chr&amp;gt;  
## 1 0 km  32000-1
## 2 2017  2017-1 
## 3 2016  2016-1 
## 4 2015  2015-1 
## 5 2014  2014-1 
## 6 2013  2013-1 
## 7 2012  2012-1 
## 8 2011  2011-1 
## 9 2010  2010-1&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Agora sim vamos ao bendito preço da BMW!&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;fipe(cod_ref = 215, cod_marca = 7, cod_modelo = 5189, cod_ano = &amp;quot;2015-1&amp;quot;) %&amp;gt;% 
  glimpse()&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Observations: 1
## Variables: 7
## $ cod_fipe    &amp;lt;chr&amp;gt; &amp;quot;009144-8&amp;quot;
## $ ref         &amp;lt;date&amp;gt; 2017-07-01
## $ marca       &amp;lt;chr&amp;gt; &amp;quot;BMW&amp;quot;
## $ modelo      &amp;lt;chr&amp;gt; &amp;quot;X6 M 4.4 4x4 V8 32V Bi-Turbo Aut.&amp;quot;
## $ ano         &amp;lt;chr&amp;gt; &amp;quot;2015&amp;quot;
## $ combustivel &amp;lt;chr&amp;gt; &amp;quot;Gasolina&amp;quot;
## $ valor       &amp;lt;dbl&amp;gt; 368603&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Achamos o preço do carro que eu queria. Apenas R$ 368 mil. Uma pechincha. Obviamente, saber quanto vale uma BMW X6 não faz diferença alguma no meu dia. Um abraço pra quem tem condições de comprar um carro desse sem precisar vender um rim.&lt;/p&gt;
&lt;p&gt;Agora que já conhecemos as funções e o fluxo para consultar o valor dos carros, vamos ampliar a consulta e justificar as horas que passamos aprendendo a programar. Já sabemos o preço do X6 M em julho/2017, mas e nos meses anteriores? Como será que foi a depreciação média do carro usado nos últimos meses? E os outros modelos X6, quanto será que estão valendo?&lt;/p&gt;
&lt;p&gt;Digamos que, agora, estas questões podem ser respondidas de forma bem rápida. Eu mostro.&lt;/p&gt;
&lt;p&gt;Vamos retomar os passos, mas agora no nível hard. Vou analisar o comportamento dos preços desde 2009. Para deixar a consulta mais rápida, serão considerados apenas 3 meses de referência por ano.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;(base_marca &amp;lt;- fipe_referencia() %&amp;gt;%
  filter(data_ref %in% seq.Date(as.Date(&amp;quot;2009-01-01&amp;quot;), as.Date(&amp;quot;2017-07-01&amp;quot;), by = &amp;quot;4 months&amp;quot;)) %&amp;gt;%
  mutate(marca = map(cod_ref, fipe_marca)) %&amp;gt;%
  unnest() %&amp;gt;% 
  filter(marca == &amp;quot;BMW&amp;quot;)
)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 26 x 4
##    data_ref   cod_ref marca cod_marca
##    &amp;lt;date&amp;gt;       &amp;lt;int&amp;gt; &amp;lt;chr&amp;gt;     &amp;lt;int&amp;gt;
##  1 2017-05-01     212 BMW           7
##  2 2017-01-01     202 BMW           7
##  3 2016-09-01     196 BMW           7
##  4 2016-05-01     191 BMW           7
##  5 2016-01-01     187 BMW           7
##  6 2015-09-01     183 BMW           7
##  7 2015-05-01     179 BMW           7
##  8 2015-01-01     174 BMW           7
##  9 2014-09-01     170 BMW           7
## 10 2014-05-01     166 BMW           7
## # ... with 16 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Notem que agora temos um dataframe com códigos de referência entre janeiro/2008 a maio/2017. Seguindo a análise, precisamos encontrar os códigos dos modelos X6.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;(base_modelo &amp;lt;- mutate(base_marca, modelo = map2(cod_ref, cod_marca, fipe_modelo)) %&amp;gt;%
  unnest() %&amp;gt;% 
  filter(str_detect(modelo, &amp;quot;X6&amp;quot;))
)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 82 x 6
##    data_ref   cod_ref marca cod_marca modelo                     cod_modelo
##    &amp;lt;date&amp;gt;       &amp;lt;int&amp;gt; &amp;lt;chr&amp;gt;     &amp;lt;int&amp;gt; &amp;lt;chr&amp;gt;                           &amp;lt;int&amp;gt;
##  1 2017-05-01     212 BMW           7 X6 M 4.4 4x4 V8 32V Bi-Tu~       5189
##  2 2017-05-01     212 BMW           7 X6 XDRIVE 35i 3.0 306cv B~       4745
##  3 2017-05-01     212 BMW           7 X6 XDRIVE 50i 4.4 407cv B~       4746
##  4 2017-05-01     212 BMW           7 X6 XDRIVE 50i M Sport 4.4~       7088
##  5 2017-01-01     202 BMW           7 X6 M 4.4 4x4 V8 32V Bi-Tu~       5189
##  6 2017-01-01     202 BMW           7 X6 XDRIVE 35i 3.0 306cv B~       4745
##  7 2017-01-01     202 BMW           7 X6 XDRIVE 50i 4.4 407cv B~       4746
##  8 2017-01-01     202 BMW           7 X6 XDRIVE 50i M Sport 4.4~       7088
##  9 2016-09-01     196 BMW           7 X6 M 4.4 4x4 V8 32V Bi-Tu~       5189
## 10 2016-09-01     196 BMW           7 X6 XDRIVE 35i 3.0 306cv B~       4745
## # ... with 72 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;O próximo passo é pegar, para cada versão, os diferentes anos de fabricação do carro. A função vai consultar os anos de fabricação que a FIPE consolidou para cada uma das 82 linhas (combinação entre modelo e mês de referência).&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;(base_consulta &amp;lt;- mutate(base_modelo, ano = pmap(list(cod_ref, cod_marca, cod_modelo), fipe_ano)) %&amp;gt;%
  unnest()
)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 480 x 8
##    data_ref   cod_ref marca cod_marca modelo       cod_modelo ano   cod_ano
##    &amp;lt;date&amp;gt;       &amp;lt;int&amp;gt; &amp;lt;chr&amp;gt;     &amp;lt;int&amp;gt; &amp;lt;chr&amp;gt;             &amp;lt;int&amp;gt; &amp;lt;chr&amp;gt; &amp;lt;chr&amp;gt;  
##  1 2017-05-01     212 BMW           7 X6 M 4.4 4x~       5189 0 km  32000-1
##  2 2017-05-01     212 BMW           7 X6 M 4.4 4x~       5189 2017  2017-1 
##  3 2017-05-01     212 BMW           7 X6 M 4.4 4x~       5189 2016  2016-1 
##  4 2017-05-01     212 BMW           7 X6 M 4.4 4x~       5189 2015  2015-1 
##  5 2017-05-01     212 BMW           7 X6 M 4.4 4x~       5189 2014  2014-1 
##  6 2017-05-01     212 BMW           7 X6 M 4.4 4x~       5189 2013  2013-1 
##  7 2017-05-01     212 BMW           7 X6 M 4.4 4x~       5189 2012  2012-1 
##  8 2017-05-01     212 BMW           7 X6 M 4.4 4x~       5189 2011  2011-1 
##  9 2017-05-01     212 BMW           7 X6 M 4.4 4x~       5189 2010  2010-1 
## 10 2017-05-01     212 BMW           7 X6 XDRIVE 3~       4745 0 km  32000-1
## # ... with 470 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Se na sua internet a função anterior demorou, prepara que a próxima vai demorar um tanto mais. Temos 480 requisições para fazer no site da FIPE em busca dos preços que queremos.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;(consulta &amp;lt;- mutate(
  base_consulta, 
  consulta = pmap(list(cod_ref, cod_marca, cod_modelo, cod_ano), fipe)
  )  %&amp;gt;%
  select(consulta) %&amp;gt;% 
  unnest() %&amp;gt;% 
  select(ref, modelo, ano, valor)
)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 480 x 4
##    ref        modelo                            ano    valor
##    &amp;lt;date&amp;gt;     &amp;lt;chr&amp;gt;                             &amp;lt;chr&amp;gt;  &amp;lt;dbl&amp;gt;
##  1 2017-05-01 X6 M 4.4 4x4 V8 32V Bi-Turbo Aut. 0 km  644550
##  2 2017-05-01 X6 M 4.4 4x4 V8 32V Bi-Turbo Aut. 2017  520193
##  3 2017-05-01 X6 M 4.4 4x4 V8 32V Bi-Turbo Aut. 2016  475803
##  4 2017-05-01 X6 M 4.4 4x4 V8 32V Bi-Turbo Aut. 2015  365088
##  5 2017-05-01 X6 M 4.4 4x4 V8 32V Bi-Turbo Aut. 2014  317505
##  6 2017-05-01 X6 M 4.4 4x4 V8 32V Bi-Turbo Aut. 2013  291749
##  7 2017-05-01 X6 M 4.4 4x4 V8 32V Bi-Turbo Aut. 2012  231191
##  8 2017-05-01 X6 M 4.4 4x4 V8 32V Bi-Turbo Aut. 2011  204481
##  9 2017-05-01 X6 M 4.4 4x4 V8 32V Bi-Turbo Aut. 2010  193629
## 10 2017-05-01 X6 XDRIVE 35i 3.0 306cv Bi-Turbo  0 km  415744
## # ... with 470 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Depois de 4 passos, temos o banco de dados desejado. Imagina coletar estes dados, na mão, pelo site oficial!&lt;/p&gt;
&lt;p&gt;Bom agora o pacote está apresentado. Pretendo fazer outros posts com estudos de casos mais específicos, portanto vou deixar apenas um gráfico que resume a consulta que acabamos de fazer.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;consulta %&amp;gt;%
  mutate(ano = fct_relevel(ano, &amp;quot;0 km&amp;quot;, after = Inf)) %&amp;gt;% 
  ggplot(aes(ref, valor, color =  ano, group = ano)) +
    geom_line(color = &amp;quot;grey30&amp;quot;) +
    geom_point(size = 3) +
    facet_wrap(~modelo) +
    labs(
      x = &amp;quot;Mês de refêrencia&amp;quot;,
      y = &amp;quot;Valor (R$)&amp;quot;,
      color = &amp;quot;Ano do \nmodelo&amp;quot;
    ) +
    scale_y_continuous(breaks = seq(0, 700000, 50000), labels = scales::dollar_format(prefix = NULL, big.mark = &amp;quot;.&amp;quot;)) +
    scale_x_date(date_breaks = &amp;quot;1 year&amp;quot;, date_labels = &amp;quot;%b/%y&amp;quot;) +
    scale_color_viridis_d() +
    theme_bw() +
    theme(legend.position = &amp;quot;top&amp;quot;) &lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2017-07-29-como-um-cientista-de-dados-pesquisa-o-carro-que-quer-comprar_files/figure-html/plot_fipe-1.svg&#34; width=&#34;960&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Caso tenha alguma dúvida ou sugestão sobre o post, fique à vontade para fazer um comentário ou me contatar por E-mail.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;sessioninfo::session_info(c(&amp;quot;readr&amp;quot;, &amp;quot;dplyr&amp;quot;, &amp;quot;ggplot2&amp;quot;, &amp;quot;purrr&amp;quot;, &amp;quot;stringr&amp;quot;, &amp;quot;tidyr&amp;quot;, &amp;quot;forcats&amp;quot;, &amp;quot;fipe&amp;quot;))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## - Session info ----------------------------------------------------------
##  setting  value                       
##  version  R version 3.5.1 (2018-07-02)
##  os       Windows 10 x64              
##  system   x86_64, mingw32             
##  ui       RTerm                       
##  language (EN)                        
##  collate  Portuguese_Brazil.1252      
##  ctype    Portuguese_Brazil.1252      
##  tz       America/Sao_Paulo           
##  date     2018-12-31                  
## 
## - Packages --------------------------------------------------------------
##  package      * version    date       lib
##  assertthat     0.2.0      2017-04-11 [1]
##  BH             1.66.0-1   2018-02-13 [1]
##  bindr          0.1.1      2018-03-13 [1]
##  bindrcpp     * 0.2.2      2018-03-29 [1]
##  cli            1.0.1      2018-09-25 [1]
##  clipr          0.4.1      2018-06-23 [1]
##  colorspace     1.3-2      2016-12-14 [1]
##  crayon         1.3.4      2017-09-16 [1]
##  curl           3.2        2018-03-28 [1]
##  digest         0.6.18     2018-10-10 [1]
##  dplyr        * 0.7.8      2018-11-10 [1]
##  fansi          0.4.0      2018-10-05 [1]
##  fipe         * 0.0.0.9000 2018-12-31 [1]
##  forcats      * 0.3.0      2018-02-19 [1]
##  ggplot2      * 3.1.0      2018-10-25 [1]
##  glue           1.3.0      2018-07-17 [1]
##  gtable         0.2.0      2016-02-26 [1]
##  hms            0.4.2      2018-03-10 [1]
##  httr           1.4.0      2018-12-11 [1]
##  jsonlite       1.6        2018-12-07 [1]
##  labeling       0.3        2014-08-23 [1]
##  lattice        0.20-35    2017-03-25 [2]
##  lazyeval       0.2.1      2017-10-29 [1]
##  lubridate      1.7.4      2018-04-11 [1]
##  magrittr       1.5        2014-11-22 [1]
##  MASS           7.3-50     2018-04-30 [2]
##  Matrix         1.2-14     2018-04-13 [2]
##  mgcv           1.8-24     2018-06-23 [2]
##  mime           0.6        2018-10-05 [1]
##  munsell        0.5.0      2018-06-12 [1]
##  nlme           3.1-137    2018-04-07 [2]
##  openssl        1.1        2018-11-15 [1]
##  pillar         1.3.1      2018-12-15 [1]
##  pkgconfig      2.0.2      2018-08-16 [1]
##  plogr          0.2.0      2018-03-25 [1]
##  plyr           1.8.4      2016-06-08 [1]
##  purrr        * 0.2.5      2018-05-29 [1]
##  R6             2.3.0      2018-10-04 [1]
##  RColorBrewer   1.1-2      2014-12-07 [1]
##  Rcpp           1.0.0      2018-11-07 [1]
##  readr          1.3.1      2018-12-21 [1]
##  reshape2       1.4.3      2017-12-11 [1]
##  rlang          0.3.0.1    2018-10-25 [1]
##  scales         1.0.0      2018-08-09 [1]
##  stringi        1.2.4      2018-07-20 [1]
##  stringr      * 1.3.1      2018-05-10 [1]
##  tibble         1.4.2      2018-01-22 [1]
##  tidyr        * 0.8.2      2018-10-28 [1]
##  tidyselect     0.2.5      2018-10-11 [1]
##  utf8           1.1.4      2018-05-24 [1]
##  viridisLite    0.3.0      2018-02-01 [1]
##  withr          2.1.2      2018-03-15 [1]
##  source                            
##  CRAN (R 3.5.1)                    
##  CRAN (R 3.5.0)                    
##  CRAN (R 3.5.1)                    
##  CRAN (R 3.5.1)                    
##  CRAN (R 3.5.1)                    
##  CRAN (R 3.5.1)                    
##  CRAN (R 3.5.1)                    
##  CRAN (R 3.5.1)                    
##  CRAN (R 3.5.1)                    
##  CRAN (R 3.5.1)                    
##  CRAN (R 3.5.1)                    
##  CRAN (R 3.5.1)                    
##  Github (italocegatta/fipe@0445ac6)
##  CRAN (R 3.5.1)                    
##  CRAN (R 3.5.1)                    
##  CRAN (R 3.5.1)                    
##  CRAN (R 3.5.1)                    
##  CRAN (R 3.5.1)                    
##  CRAN (R 3.5.2)                    
##  CRAN (R 3.5.2)                    
##  CRAN (R 3.5.0)                    
##  CRAN (R 3.5.1)                    
##  CRAN (R 3.5.1)                    
##  CRAN (R 3.5.1)                    
##  CRAN (R 3.5.1)                    
##  CRAN (R 3.5.1)                    
##  CRAN (R 3.5.1)                    
##  CRAN (R 3.5.1)                    
##  CRAN (R 3.5.1)                    
##  CRAN (R 3.5.1)                    
##  CRAN (R 3.5.1)                    
##  CRAN (R 3.5.1)                    
##  CRAN (R 3.5.2)                    
##  CRAN (R 3.5.1)                    
##  CRAN (R 3.5.1)                    
##  CRAN (R 3.5.1)                    
##  CRAN (R 3.5.1)                    
##  CRAN (R 3.5.1)                    
##  CRAN (R 3.5.0)                    
##  CRAN (R 3.5.1)                    
##  CRAN (R 3.5.2)                    
##  CRAN (R 3.5.1)                    
##  CRAN (R 3.5.1)                    
##  CRAN (R 3.5.1)                    
##  CRAN (R 3.5.1)                    
##  CRAN (R 3.5.1)                    
##  CRAN (R 3.5.1)                    
##  CRAN (R 3.5.1)                    
##  CRAN (R 3.5.1)                    
##  CRAN (R 3.5.1)                    
##  CRAN (R 3.5.1)                    
##  CRAN (R 3.5.1)                    
## 
## [1] C:/Users/Italo/Documents/R/win-library/3.5
## [2] C:/Program Files/R/R-3.5.1/library&lt;/code&gt;&lt;/pre&gt;

      </content:encoded>
    </item>
    
    <item>
      <title>Índice de uniformidade (PV50)</title>
      <link>/indice-de-uniformidade-pv50/</link>
      <pubDate>Sun, 09 Oct 2016 00:00:00 +0000</pubDate>
      
      <guid>/indice-de-uniformidade-pv50/</guid>
      <description>O PV50 é hoje o índice mais utilizado quando queremos expressar a uniformidade de um plantio florestal. Hakamada (2012) apresentou um estudo detalhado sobre diversos índices e concluiu que o PV50 é o índice mais indicado para explicar a relação entre uniformidade, qualidade silvicultural e produtividade em plantios homogêneos de Eucalyptus.
O objetivo deste post é mostrar, passo a passo, como calcular este índice no R e fazer uma breve análise de seus resultados.</description>
      <content:encoded>
        


&lt;p&gt;O PV50 é hoje o índice mais utilizado quando queremos expressar a uniformidade de um plantio florestal. &lt;span class=&#34;citation&#34;&gt;Hakamada (&lt;a href=&#34;#ref-Hakamada2012&#34;&gt;2012&lt;/a&gt;)&lt;/span&gt; apresentou um estudo detalhado sobre diversos índices e concluiu que o PV50 é o índice mais indicado para explicar a relação entre uniformidade, qualidade silvicultural e produtividade em plantios homogêneos de &lt;em&gt;Eucalyptus&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;O objetivo deste post é mostrar, passo a passo, como calcular este índice no R e fazer uma breve análise de seus resultados.&lt;/p&gt;
&lt;p&gt;O PV50 é a porcentagem de volume acumulado das 50% menores árvores do seu conjunto de dados, considerando as falhas de plantio e árvores mortas &lt;span class=&#34;citation&#34;&gt;(Hakamada et al. &lt;a href=&#34;#ref-Hakamada2015&#34;&gt;2015&lt;/a&gt;)&lt;/span&gt;. A expressão do índice é dada da seguinte forma:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.sciweavers.org/tex2img.php?eq=PV50%20%3D%20%5Cfrac%7B%5Csum_%7Bk%3D1%7D%5E%7B%5Cfrac%7Bn%7D%7B2%7D%7DV_%7Bij%7D%7D%7B%5Csum_%7Bk%3D1%7D%5E%7Bn%7DV_%7Bij%7D%7D&amp;bc=White&amp;fc=Black&amp;im=jpg&amp;fs=12&amp;ff=arev&amp;edit=0&#34; align=&#34;center&#34; border=&#34;0&#34; alt=&#34;PV50 = \frac{\sum_{k=1}^{\frac{n}{2}}V_{ij}}{\sum_{k=1}^{n}V_{ij}}&#34; width=&#34;139&#34; height=&#34;62&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Onde: PV50 = porcentagem acumulada do volume das 50% menores árvores plantadas; V = volume da árvore i; n = número de árvores plantadas ordenadas (da menor para a maior).&lt;/p&gt;
&lt;p&gt;Primeiro vamos entender os cálculos do índice, considerando apenas 10 árvores hipotéticas com 0,1 metros cúbicos de volume.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# carrega os pacotes necessários
if (!require(&amp;quot;pacman&amp;quot;)) install.packages(&amp;quot;pacman&amp;quot;)
pacman::p_load(readr, dplyr, ggplot2, forcats)&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# exemplo com número par
arv10 &amp;lt;- rep(0.1, 10)
str(arv10)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  num [1:10] 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Este é o referencial teórico de uniformidade, todas as árvores do mesmo tamanho. Sem precisar fazer conta, sabemos que o volume das 50% menores árvores é igual a 50% do volume total, o que equivale a um PV50 = 50.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# identifica a metade do numero de árvores
metade &amp;lt;- length(arv10)/2
metade&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 5&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# soma todas as árvores
soma_todas &amp;lt;- sum(arv10, na.rm = TRUE)
soma_todas&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 1&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# soma o valor de metade das árvores em ordem crescente
soma_metade &amp;lt;- sum(sort(arv10)[1:metade], na.rm = TRUE)
soma_metade&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 0.5&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# calcula o PV50
PV50 &amp;lt;- soma_metade / soma_todas * 100
PV50&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 50&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Agora vamos simular 11 árvores com o mesmo volume, veja o que acontece.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# exemplo com número impar
arv11 &amp;lt;- rep(0.1, 11)
str(arv11)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  num [1:11] 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 ...&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# metade do numero de árvores
metade &amp;lt;- length(arv11)/2
metade&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 5.5&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# soma todas as árvores
soma_todas &amp;lt;- sum(arv11, na.rm = TRUE)
soma_todas&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 1.1&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# soma o valor de metade das árvores em ordem crescente
soma_metade &amp;lt;- sum(sort(arv11)[1:metade], na.rm = TRUE)
soma_metade&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 0.5&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# calcula o PV50
PV50 &amp;lt;- soma_metade / soma_todas * 100
PV50&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 45.45455&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;O resultado deveria ser 50, mas como o número de árvores é ímpar, o R arredonda a posição 5,5 para 5 e pega até a quinta árvore no momento em que queremos somar as 50% menores. Para contornar isso, vamos calcular a soma das 50% menores árvores de uma forma diferente. Primeiro calculamos a soma acumulada e depois extraímos a média (semelhante ao modo de se calcular uma mediana).&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# vetor de soma acumulada
soma_acumulada &amp;lt;- cumsum(sort(arv11))
soma_acumulada&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  [1] 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0 1.1&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# soma a metade do vetor de soma acumulada
soma_metade &amp;lt;- mean(soma_acumulada[metade + 0L:1L], na.rm = TRUE)
soma_metade&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 0.55&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# calcula o PV50
PV50 &amp;lt;- soma_metade / soma_todas * 100
PV50&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 50&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Agora que a questão do número de árvores foi superada, podemos incluir árvores mortas, o que equivale a elementos do tipo &lt;code&gt;NA&lt;/code&gt; no R. Veja que o resultado não está consistente pois a &lt;code&gt;soma_acumulada&lt;/code&gt; ignorou as árvores mortas.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# exemplo com valores perdidos
arv11_na &amp;lt;- rep(0.1, 11)
arv11_na[c(3,4)] &amp;lt;- NA
str(arv11_na)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  num [1:11] 0.1 0.1 NA NA 0.1 0.1 0.1 0.1 0.1 0.1 ...&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# metade do numero de árvores
metade &amp;lt;- length(arv11_na)/2
metade&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 5.5&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# soma todas as árvores
soma_todas &amp;lt;- sum(arv11_na, na.rm = TRUE)
soma_todas&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 0.9&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# vetor de soma acumulada
soma_acumulada &amp;lt;- cumsum(sort(arv11_na))
soma_acumulada&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# soma a metade do vetor de soma acumulada
soma_metade &amp;lt;- mean(soma_acumulada[metade + 0L:1L], na.rm = TRUE)
soma_metade&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 0.55&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# calcula o PV50
PV50 &amp;lt;- soma_metade / soma_todas * 100
PV50&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 61.11111&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Para corrigir este o erro, temos de incluir manualmente as árvores mortas na sequência. Veja que agora o resultado está de acordo com o esperado.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# vetor de valores perdidos
mortas &amp;lt;- arv11_na[is.na(arv11_na)]
mortas&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] NA NA&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# metade do numero de árvores
metade &amp;lt;- length(arv11_na)/2
metade&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 5.5&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# soma todas as árvores
soma_todas &amp;lt;- sum(arv11_na, na.rm = TRUE)
soma_todas&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 0.9&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# vetor de soma acumulada com valores perdidos
soma_acumulada &amp;lt;- c(mortas, cumsum(sort(arv11_na)))
soma_acumulada&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  [1]  NA  NA 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# soma a metade do vetor de soma acumulada
soma_metade &amp;lt;- mean(soma_acumulada[metade + 0L:1L], na.rm = TRUE)
soma_metade&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 0.35&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# calcula o PV50
PV50 &amp;lt;- soma_metade / soma_todas * 100
PV50&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 38.88889&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Agora eu vou dar aquele passo mágico dos livros de matemática e física, em que o autor diz “é fácil notar que o resultado leva a …” e apresentar uma função que lida com as questões que mostramos acima e retorna o PV50 do nosso conjunto de dados de forma correta.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;pv50 &amp;lt;- function(x) {
  
  mortas &amp;lt;- x[is.na(x)]
  
  metade &amp;lt;- length(x)/2
  
  soma_todas &amp;lt;- sum(x, na.rm = TRUE)
  
  soma_acumulada &amp;lt;- c(mortas, cumsum(sort(x)))
  
  if (metade%%2L == 1L)
    soma_metade &amp;lt;- mean(soma_acumulada[metade], na.rm = TRUE)
  else
    soma_metade &amp;lt;- mean(soma_acumulada[metade + 0L:1L], na.rm = TRUE)
  
  z &amp;lt;- soma_metade / soma_todas * 100
  
  return(z)
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Podemos rapidamente verificar se os resultados estão consistentes fazendo alguns testes.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;a &amp;lt;- rep(10, 10)
str(a)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  num [1:10] 10 10 10 10 10 10 10 10 10 10&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;pv50(a) # Ok!&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 50&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;a1 &amp;lt;- rep(10 ,11)
str(a1)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  num [1:11] 10 10 10 10 10 10 10 10 10 10 ...&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;pv50(a1) # Ok!&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 50&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;b &amp;lt;- a
b[c(3, 7)] &amp;lt;- NA
str(b)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  num [1:10] 10 10 NA 10 10 10 NA 10 10 10&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;pv50(b) # Ok!&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 37.5&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;b1 &amp;lt;- a1
b1[c(3, 7)] &amp;lt;- NA
str(b1)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  num [1:11] 10 10 NA 10 10 10 NA 10 10 10 ...&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;pv50(b1) # Ok!&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 38.88889&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Boa, já temos uma função para calcular o PV50 e podemos aplicá-la em um conjunto de dados para podermos interpretar. Utilizaremos mais uma vez os dados do &lt;a href=&#34;www.projetotume.com&#34;&gt;Projeto TUME&lt;/a&gt;, referente ao &lt;a href=&#34;http://www.projetotume.com/tume134&#34;&gt;TUME 134&lt;/a&gt; plantado em Piracicaba-SP. O volume individual foi calculado arbitrariamente utilizando o fator de forma 0,5.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# importa o arquivo tume_55.csv
dados &amp;lt;- read_csv2(
  &amp;quot;https://github.com/italocegatta/italocegatta.github.io_source/raw/master/content/dados/tume_55.csv&amp;quot;
)

glimpse(dados)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Observations: 1,222
## Variables: 7
## $ Esp     &amp;lt;chr&amp;gt; &amp;quot;E_camaldulensis&amp;quot;, &amp;quot;E_camaldulensis&amp;quot;, &amp;quot;E_camaldulensis...
## $ I_meses &amp;lt;dbl&amp;gt; 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34...
## $ Parc_m2 &amp;lt;dbl&amp;gt; 288, 288, 288, 288, 288, 288, 288, 288, 288, 288, 288,...
## $ N_arv   &amp;lt;dbl&amp;gt; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16,...
## $ DAP_cm  &amp;lt;dbl&amp;gt; 5.411268, 12.254931, 3.978874, 6.429860, 9.676621, 5.6...
## $ H_m     &amp;lt;dbl&amp;gt; 7.651490, 11.424046, 5.909205, 8.572873, 10.498957, 7....
## $ Vol     &amp;lt;dbl&amp;gt; 0.008798406, 0.067375427, 0.003673747, 0.013918399, 0....&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Iremos calcular o PV50 e o volume por hectare para cada fator &lt;code&gt;Esp&lt;/code&gt; e &lt;code&gt;I_meses&lt;/code&gt; e em seguida ordenar as espécies pelo PV50.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# agrupa os dados em função de espécie e idade para 
# calcular o pv50 e o volume
dados_pv50 &amp;lt;- dados %&amp;gt;% 
  group_by(Esp, I_meses) %&amp;gt;% 
  summarise(
    Parc_m2 = mean( Parc_m2),
    PV50 = pv50(Vol),
    Vol_ha = sum(Vol, na.rm = TRUE) * (10000/Parc_m2)
  ) %&amp;gt;%
  ungroup() %&amp;gt;% 
  # ordena o fator de espécies de forma decrescente em função do pv50
  mutate(Esp = fct_reorder(Esp, -PV50))

dados_pv50&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 20 x 5
##    Esp                 I_meses Parc_m2  PV50 Vol_ha
##    &amp;lt;fct&amp;gt;                 &amp;lt;dbl&amp;gt;   &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt;
##  1 E_camaldulensis          34     288  21.4   47.5
##  2 E_camaldulensis          46     288  14.3   79.1
##  3 E_camaldulensis          60     600  13.2  110. 
##  4 E_camaldulensis          85     288  12.7  204. 
##  5 E_citriodora             34     288  17.8   46.6
##  6 E_citriodora             46     288  16.4   85.0
##  7 E_citriodora             60     600  12.5   97.0
##  8 E_citriodora             85     288  12.7  205. 
##  9 E_dunnii                 34     288  28.6  103. 
## 10 E_dunnii                 46     288  29.2  161. 
## 11 E_dunnii                 60     600  27.5  198. 
## 12 E_dunnii                 85     288  26.4  350. 
## 13 E_paniculata             34     288  27.4   46.4
## 14 E_paniculata             46     288  24.1   84.4
## 15 E_paniculata             60     600  19.6  115. 
## 16 E_paniculata             85     288  18.2  195. 
## 17 E_urophylla_grandis      34     288  26.3   85.7
## 18 E_urophylla_grandis      46     288  24.2  157. 
## 19 E_urophylla_grandis      60     600  20.3  217. 
## 20 E_urophylla_grandis      85     288  17.9  277.&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Para entendermos os dados, vamos primeiro ver o crescimento em volume de cada espécies em função do tempo (Figura &lt;a href=&#34;#fig:12-vol-idade&#34;&gt;1&lt;/a&gt;). Note que &lt;em&gt;E. dunnii&lt;/em&gt; e &lt;em&gt;E. urophylla&lt;/em&gt; x &lt;em&gt;E. grandis&lt;/em&gt; tinham crescimento muito parecido até os 60 meses de idade.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggplot(dados_pv50, aes(I_meses, Vol_ha, color = Esp)) +
  geom_point() +
  geom_line() +
  labs(
    color = &amp;quot;Espécies&amp;quot;,
    x = &amp;quot;Idade (meses)&amp;quot;,
    y = Volume~m^3~ha^-1
  ) +
  scale_color_brewer(palette = &amp;quot;Set1&amp;quot;) +
  theme_bw(16) +
  theme(legend.justification = &amp;quot;top&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;figure&#34;&gt;&lt;span id=&#34;fig:12-vol-idade&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;/post/2016-10-09-indice-de-uniformidade-pv50_files/figure-html/12-vol-idade-1.svg&#34; alt=&#34;Crescimento em volume por hectare em função da idade.&#34; width=&#34;960&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figura  1: Crescimento em volume por hectare em função da idade.
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Agora podemos construir um gráfico que relaciona o PV50 e a idade (Figura &lt;a href=&#34;#fig:12-pv50-idade&#34;&gt;2&lt;/a&gt;). A interpretação do índice é simples, o PV50 representa a porcentagem em volume que as 50% menores árvores contribuem para o volume total. Em nossos dados, &lt;em&gt;E. dunnii&lt;/em&gt;, aos 85 meses de idade, tem um PV50 de aproximadamente 26. Isso quer dizer que aos 7 anos, as 50% menores árvores da parcela de &lt;em&gt;E. dunnii&lt;/em&gt; representam apenas 26% do volume total. Ou seja, 50% das árvores contribuem muito pouco para o volume total da parcela e isso tem um impacto direto na produtividade.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggplot(dados_pv50, aes(I_meses, PV50, color = Esp)) +
  geom_point() +
  geom_line() +
  labs(color = &amp;quot;Espécies&amp;quot;, x = &amp;quot;Idade (meses)&amp;quot;, y = &amp;quot;PV50&amp;quot;) +
  scale_color_brewer(palette = &amp;quot;Set1&amp;quot;) +
  scale_y_continuous(breaks = seq(10, 30, 2)) +
  theme_bw(16) +
  theme(legend.justification = &amp;quot;top&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;figure&#34;&gt;&lt;span id=&#34;fig:12-pv50-idade&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;/post/2016-10-09-indice-de-uniformidade-pv50_files/figure-html/12-pv50-idade-1.svg&#34; alt=&#34;Variação do PV50 por espécies em função da idade.&#34; width=&#34;960&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figura  2: Variação do PV50 por espécies em função da idade.
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;A Figura &lt;a href=&#34;#fig:12-pv50-vol&#34;&gt;3&lt;/a&gt; mostra claramente a relação direta que há entre produção de madeira e a uniformidade ao longo do crescimento da floresta. Note também que na medida em que a idade avança, a uniformidade diminui, uma vez que a dominância das árvores maiores sobre as menores fica cada vez mais forte.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggplot(dados_pv50, aes(Vol_ha, PV50)) +
  geom_point(aes(color = factor(I_meses))) +
  geom_smooth(method = &amp;quot;lm&amp;quot;, formula = y ~x, se = FALSE) +
  facet_wrap(~Esp, dir = &amp;quot;v&amp;quot;) +
  labs(color = &amp;quot;Idade (meses)&amp;quot;, x = Volume~m^3~ha^-1, y = &amp;quot;PV50&amp;quot;) +
  scale_color_brewer(palette = &amp;quot;Dark2&amp;quot;) +
  theme_bw(16) +
  theme(legend.justification = &amp;quot;top&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;figure&#34;&gt;&lt;span id=&#34;fig:12-pv50-vol&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;/post/2016-10-09-indice-de-uniformidade-pv50_files/figure-html/12-pv50-vol-1.svg&#34; alt=&#34;Relação entre o PV50 e volume por hectare em função da idade.&#34; width=&#34;960&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figura  3: Relação entre o PV50 e volume por hectare em função da idade.
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Por fim, para colocar tudo em um só gráfico, podemos adicionar ao gráfico de crescimento em volume a informação do PV50 para evidenciar que as espécies mais produtivas tem PV50 elevado e que este índice consegue explicar muito bem essa relação (Figura &lt;a href=&#34;#fig:12-vol-pv50-idade&#34;&gt;4&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;Um comentário interessante é que dentre as espécies que estamos estudando, todas são de origem seminal, com exceção do &lt;em&gt;E. dunnii&lt;/em&gt;, que é um clone. Este fator explica sua produtividade e alta homogeneidade, principalmente frente ao hibrido de &lt;em&gt;E. urophylla&lt;/em&gt; x &lt;em&gt;E. grandis&lt;/em&gt;, que é seu concorrente direto. Quando estivermos analisando dados de plantios clonais, o PV50 vai expressar a qualidade silvicultural do plantio, uma vez que a base genética é a mesma em todas as plantas.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggplot(dados_pv50, aes(I_meses, Vol_ha, color = Esp)) +
  geom_point(aes(size = PV50), alpha = 0.4) +
  geom_line() +
  labs(
    color = &amp;quot;Espécies&amp;quot;,
    x = &amp;quot;Idade (meses)&amp;quot;,
    y = Volume~m^3~ha^-1
  ) +
  scale_color_brewer(palette = &amp;quot;Set1&amp;quot;) +
  theme_bw(16) +
  theme(legend.justification = &amp;quot;top&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;figure&#34;&gt;&lt;span id=&#34;fig:12-vol-pv50-idade&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;/post/2016-10-09-indice-de-uniformidade-pv50_files/figure-html/12-vol-pv50-idade-1.svg&#34; alt=&#34;Crescimento do volume em função da idade, com informação do PV50 no tamanho do ponto.&#34; width=&#34;960&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figura  4: Crescimento do volume em função da idade, com informação do PV50 no tamanho do ponto.
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Caso tenha alguma dúvida ou sugestão sobre o post, fique à vontade para fazer um comentário ou me contatar por E-mail.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;sessioninfo::session_info(c(&amp;quot;readr&amp;quot;, &amp;quot;dplyr&amp;quot;, &amp;quot;ggplot2&amp;quot;, &amp;quot;forcats&amp;quot;))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## - Session info ----------------------------------------------------------
##  setting  value                       
##  version  R version 3.5.1 (2018-07-02)
##  os       Windows 10 x64              
##  system   x86_64, mingw32             
##  ui       RTerm                       
##  language (EN)                        
##  collate  Portuguese_Brazil.1252      
##  ctype    Portuguese_Brazil.1252      
##  tz       America/Sao_Paulo           
##  date     2018-12-31                  
## 
## - Packages --------------------------------------------------------------
##  package      * version  date       lib source        
##  assertthat     0.2.0    2017-04-11 [1] CRAN (R 3.5.1)
##  BH             1.66.0-1 2018-02-13 [1] CRAN (R 3.5.0)
##  bindr          0.1.1    2018-03-13 [1] CRAN (R 3.5.1)
##  bindrcpp     * 0.2.2    2018-03-29 [1] CRAN (R 3.5.1)
##  cli            1.0.1    2018-09-25 [1] CRAN (R 3.5.1)
##  clipr          0.4.1    2018-06-23 [1] CRAN (R 3.5.1)
##  colorspace     1.3-2    2016-12-14 [1] CRAN (R 3.5.1)
##  crayon         1.3.4    2017-09-16 [1] CRAN (R 3.5.1)
##  digest         0.6.18   2018-10-10 [1] CRAN (R 3.5.1)
##  dplyr        * 0.7.8    2018-11-10 [1] CRAN (R 3.5.1)
##  fansi          0.4.0    2018-10-05 [1] CRAN (R 3.5.1)
##  forcats      * 0.3.0    2018-02-19 [1] CRAN (R 3.5.1)
##  ggplot2      * 3.1.0    2018-10-25 [1] CRAN (R 3.5.1)
##  glue           1.3.0    2018-07-17 [1] CRAN (R 3.5.1)
##  gtable         0.2.0    2016-02-26 [1] CRAN (R 3.5.1)
##  hms            0.4.2    2018-03-10 [1] CRAN (R 3.5.1)
##  labeling       0.3      2014-08-23 [1] CRAN (R 3.5.0)
##  lattice        0.20-35  2017-03-25 [2] CRAN (R 3.5.1)
##  lazyeval       0.2.1    2017-10-29 [1] CRAN (R 3.5.1)
##  magrittr       1.5      2014-11-22 [1] CRAN (R 3.5.1)
##  MASS           7.3-50   2018-04-30 [2] CRAN (R 3.5.1)
##  Matrix         1.2-14   2018-04-13 [2] CRAN (R 3.5.1)
##  mgcv           1.8-24   2018-06-23 [2] CRAN (R 3.5.1)
##  munsell        0.5.0    2018-06-12 [1] CRAN (R 3.5.1)
##  nlme           3.1-137  2018-04-07 [2] CRAN (R 3.5.1)
##  pillar         1.3.1    2018-12-15 [1] CRAN (R 3.5.2)
##  pkgconfig      2.0.2    2018-08-16 [1] CRAN (R 3.5.1)
##  plogr          0.2.0    2018-03-25 [1] CRAN (R 3.5.1)
##  plyr           1.8.4    2016-06-08 [1] CRAN (R 3.5.1)
##  purrr          0.2.5    2018-05-29 [1] CRAN (R 3.5.1)
##  R6             2.3.0    2018-10-04 [1] CRAN (R 3.5.1)
##  RColorBrewer   1.1-2    2014-12-07 [1] CRAN (R 3.5.0)
##  Rcpp           1.0.0    2018-11-07 [1] CRAN (R 3.5.1)
##  readr        * 1.2.1    2018-11-22 [1] CRAN (R 3.5.1)
##  reshape2       1.4.3    2017-12-11 [1] CRAN (R 3.5.1)
##  rlang          0.3.0.1  2018-10-25 [1] CRAN (R 3.5.1)
##  scales         1.0.0    2018-08-09 [1] CRAN (R 3.5.1)
##  stringi        1.2.4    2018-07-20 [1] CRAN (R 3.5.1)
##  stringr        1.3.1    2018-05-10 [1] CRAN (R 3.5.1)
##  tibble         1.4.2    2018-01-22 [1] CRAN (R 3.5.1)
##  tidyselect     0.2.5    2018-10-11 [1] CRAN (R 3.5.1)
##  utf8           1.1.4    2018-05-24 [1] CRAN (R 3.5.1)
##  viridisLite    0.3.0    2018-02-01 [1] CRAN (R 3.5.1)
##  withr          2.1.2    2018-03-15 [1] CRAN (R 3.5.1)
## 
## [1] C:/Users/Italo/Documents/R/win-library/3.5
## [2] C:/Program Files/R/R-3.5.1/library&lt;/code&gt;&lt;/pre&gt;
&lt;div id=&#34;referencias&#34; class=&#34;section level1 unnumbered&#34;&gt;
&lt;h1&gt;Referências&lt;/h1&gt;
&lt;div id=&#34;refs&#34; class=&#34;references&#34;&gt;
&lt;div id=&#34;ref-Hakamada2012&#34;&gt;
&lt;p&gt;Hakamada, Rodrigo Eiji. 2012. “Uso do inventário florestal como ferramenta de monitoramento da qualidade silvicultura em povoamentos clonais de Eucalyptus.” PhD thesis, Piracicaba: Universidade de São Paulo; Biblioteca Digital de Teses e Dissertações da Universidade de São Paulo. doi:&lt;a href=&#34;https://doi.org/10.11606/D.11.2012.tde-05072012-100431&#34;&gt;10.11606/D.11.2012.tde-05072012-100431&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;ref-Hakamada2015&#34;&gt;
&lt;p&gt;Hakamada, Rodrigo Eiji, José Luiz Stape, Cristiane Camargo Zani de Lemos, Adriano Emanuel Amaral Almeida, and Luis Fernando Silva. 2015. “Uniformidade entre árvores durante uma rotação e sua relação com a produtividade em Eucalyptus clonais.” &lt;em&gt;CERNE&lt;/em&gt; 21 (3). Universidade Federal de Lavras: 465–72. doi:&lt;a href=&#34;https://doi.org/10.1590/01047760201521031716&#34;&gt;10.1590/01047760201521031716&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

      </content:encoded>
    </item>
    
  </channel>
</rss>
