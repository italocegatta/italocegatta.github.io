<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Forcats on Italo Cegatta</title>
    <link>https://italocegatta.github.io/tags/forcats/</link>
    <description>Recent content in Forcats on Italo Cegatta</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>pt-br</language>
    <lastBuildDate>Tue, 01 Jan 2019 00:00:00 +0000</lastBuildDate>
    
        <atom:link href="https://italocegatta.github.io/tags/forcats/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>O quão popular é o seu nome?</title>
      <link>https://italocegatta.github.io/o-quao-popular-e-o-seu-nome/</link>
      <pubDate>Tue, 01 Jan 2019 00:00:00 +0000</pubDate>
      
      <guid>https://italocegatta.github.io/o-quao-popular-e-o-seu-nome/</guid>
      <description>No Censo 2010, o IBGE incorporou no levantamento a coleta de nomes (apenas o primeiro) e sobrenome (apenas o último). Para quem é curioso por coisas sem muita utilidade prática (e eu jogo forte nesse time!), vale a pena entrar no site https://censo2010.ibge.gov.br/nomes e conferir as estatísticas do nome de interesse.
O site é legal, mas eu queria ter os dados na mão para fazer as coisas do meu jeito.</description>
      <content:encoded>
        


&lt;p&gt;No Censo 2010, o IBGE incorporou no levantamento a coleta de nomes (apenas o primeiro) e sobrenome (apenas o último). Para quem é curioso por coisas sem muita utilidade prática (e eu jogo forte nesse time!), vale a pena entrar no site &lt;a href=&#34;https://censo2010.ibge.gov.br/nomes&#34;&gt;https://censo2010.ibge.gov.br/nomes&lt;/a&gt; e conferir as estatísticas do nome de interesse.&lt;/p&gt;
&lt;p&gt;O site é legal, mas eu queria ter os dados na mão para fazer as coisas do meu jeito. Então decidi escrever um pacote no R para acessar os dados da &lt;a href=&#34;https://servicodados.ibge.gov.br/api/docs/censos/nomes?versao=2&#34;&gt;API&lt;/a&gt; que o IBGE montou para esse banco.&lt;/p&gt;
&lt;p&gt;O pacote chama &lt;code&gt;brnome&lt;/code&gt; e está disponível no meu &lt;a href=&#34;https://github.com/italocegatta/brnome&#34;&gt;Github&lt;/a&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;if (!require(&amp;quot;pacman&amp;quot;)) install.packages(&amp;quot;pacman&amp;quot;)
pacman::p_load(readr, dplyr, purrr, tidyr, ggplot2, forcats, wordcloud)
pacman::p_load_gh(&amp;quot;italocegatta/brnome&amp;quot;)
pacman::p_load_gh(&amp;quot;italocegatta/brmap&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Vamos começar com a função &lt;code&gt;brnome_freq()&lt;/code&gt; e entender a distribuição espacial e temporal (década de nascimento) do nome da minha queria e sapeca sobrinha, Eliza.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;eliza_freq &amp;lt;- brnome_freq(nome = &amp;quot;eliza&amp;quot;)

eliza_freq&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 9 x 7
##   nome  sexo  localidade_cod localidade_nome nascimento_peri~
##   &amp;lt;chr&amp;gt; &amp;lt;lgl&amp;gt; &amp;lt;chr&amp;gt;          &amp;lt;chr&amp;gt;           &amp;lt;chr&amp;gt;           
## 1 ELIZA NA    BR             Brasil          [    , 1930]    
## 2 ELIZA NA    BR             Brasil          [1930, 1940]    
## 3 ELIZA NA    BR             Brasil          [1940, 1950]    
## 4 ELIZA NA    BR             Brasil          [1950, 1960]    
## 5 ELIZA NA    BR             Brasil          [1960, 1970]    
## 6 ELIZA NA    BR             Brasil          [1970, 1980]    
## 7 ELIZA NA    BR             Brasil          [1980, 1990]    
## 8 ELIZA NA    BR             Brasil          [1990, 2000]    
## 9 ELIZA NA    BR             Brasil          [2000, 2010]    
## # ... with 2 more variables: nascimento_decada &amp;lt;int&amp;gt;, frequencia &amp;lt;int&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Notem que as colunas &lt;code&gt;sexo&lt;/code&gt; e &lt;code&gt;localidade&lt;/code&gt; estão vazias pois não foram especificadas. Significa que foi considerada a busca de homens e mulheres para todo o Brasil.&lt;/p&gt;
&lt;p&gt;Será que tem algum homem batizado com o nome Eliza? Tem, e eu não sei se foi de propósito ou se foi um erro de coleta. Fica aí o questionamento hehehehe.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;brnome_freq(nome = &amp;quot;eliza&amp;quot;, sexo = &amp;quot;m&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 9 x 7
##   nome  sexo  localidade_cod localidade_nome nascimento_peri~
##   &amp;lt;chr&amp;gt; &amp;lt;chr&amp;gt; &amp;lt;chr&amp;gt;          &amp;lt;chr&amp;gt;           &amp;lt;chr&amp;gt;           
## 1 ELIZA M     BR             Brasil          [    , 1930]    
## 2 ELIZA M     BR             Brasil          [1930, 1940]    
## 3 ELIZA M     BR             Brasil          [1940, 1950]    
## 4 ELIZA M     BR             Brasil          [1950, 1960]    
## 5 ELIZA M     BR             Brasil          [1960, 1970]    
## 6 ELIZA M     BR             Brasil          [1970, 1980]    
## 7 ELIZA M     BR             Brasil          [1980, 1990]    
## 8 ELIZA M     BR             Brasil          [1990, 2000]    
## 9 ELIZA M     BR             Brasil          [2000, 2010]    
## # ... with 2 more variables: nascimento_decada &amp;lt;int&amp;gt;, frequencia &amp;lt;int&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A pesquisa também pode ser feita para um determinado município ou estado. Neste caso, você precisa utilizar o código oficial do IBGE de localidades. Como exemplo, vamos ver os resultados para Cuiabá (&lt;code&gt;5103403&lt;/code&gt;) e Mato Grosso (&lt;code&gt;51&lt;/code&gt;).&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;brnome_freq(nome = &amp;quot;eliza&amp;quot;, localidade_cod = 5103403)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 7 x 7
##   nome  sexo  localidade_cod localidade_nome nascimento_peri~
##   &amp;lt;chr&amp;gt; &amp;lt;lgl&amp;gt;          &amp;lt;int&amp;gt; &amp;lt;chr&amp;gt;           &amp;lt;chr&amp;gt;           
## 1 ELIZA NA           5103403 Cuiabá          [1940, 1950]    
## 2 ELIZA NA           5103403 Cuiabá          [1950, 1960]    
## 3 ELIZA NA           5103403 Cuiabá          [1960, 1970]    
## 4 ELIZA NA           5103403 Cuiabá          [1970, 1980]    
## 5 ELIZA NA           5103403 Cuiabá          [1980, 1990]    
## 6 ELIZA NA           5103403 Cuiabá          [1990, 2000]    
## 7 ELIZA NA           5103403 Cuiabá          [2000, 2010]    
## # ... with 2 more variables: nascimento_decada &amp;lt;int&amp;gt;, frequencia &amp;lt;int&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;brnome_freq(nome = &amp;quot;eliza&amp;quot;, localidade_cod = 51)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 9 x 7
##   nome  sexo  localidade_cod localidade_nome nascimento_peri~
##   &amp;lt;chr&amp;gt; &amp;lt;lgl&amp;gt;          &amp;lt;int&amp;gt; &amp;lt;chr&amp;gt;           &amp;lt;chr&amp;gt;           
## 1 ELIZA NA                51 Mato Grosso     [    , 1930]    
## 2 ELIZA NA                51 Mato Grosso     [1930, 1940]    
## 3 ELIZA NA                51 Mato Grosso     [1940, 1950]    
## 4 ELIZA NA                51 Mato Grosso     [1950, 1960]    
## 5 ELIZA NA                51 Mato Grosso     [1960, 1970]    
## 6 ELIZA NA                51 Mato Grosso     [1970, 1980]    
## 7 ELIZA NA                51 Mato Grosso     [1980, 1990]    
## 8 ELIZA NA                51 Mato Grosso     [1990, 2000]    
## 9 ELIZA NA                51 Mato Grosso     [2000, 2010]    
## # ... with 2 more variables: nascimento_decada &amp;lt;int&amp;gt;, frequencia &amp;lt;int&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Para consultar os códigos das localidades, o pacote disponibiliza um dataframe auxiliar &lt;code&gt;localidades&lt;/code&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;localidades&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 5,597 x 3
##    localidade localidade_nome       tipo     
##    &amp;lt;chr&amp;gt;      &amp;lt;chr&amp;gt;                 &amp;lt;chr&amp;gt;    
##  1 1100015    Alta Floresta D&amp;#39;Oeste Município
##  2 1100023    Ariquemes             Município
##  3 1100031    Cabixi                Município
##  4 1100049    Cacoal                Município
##  5 1100056    Cerejeiras            Município
##  6 1100064    Colorado do Oeste     Município
##  7 1100072    Corumbiara            Município
##  8 1100080    Costa Marques         Município
##  9 1100098    Espigão D&amp;#39;Oeste       Município
## 10 1100106    Guajará-Mirim         Município
## # ... with 5,587 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Bom, consultas simples como está podem ser feitas diretamente pelo site do IBGE, mas podemos deixar um pouco mais complexo e pegar a frequência do nome Eliza para todos os estados do Brasil.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;eliza_estado &amp;lt;- localidades %&amp;gt;% 
  filter(tipo == &amp;quot;Estado&amp;quot;) %&amp;gt;% 
  mutate(
    freq = map(
      localidade,
      ~brnome_freq(nome = &amp;quot;Eliza&amp;quot;, localidade_cod = .x) 
    )
  ) %&amp;gt;% 
  select(freq) %&amp;gt;% 
  unnest()

eliza_estado&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 218 x 7
##    nome  sexo  localidade_cod localidade_nome nascimento_peri~
##    &amp;lt;chr&amp;gt; &amp;lt;lgl&amp;gt;          &amp;lt;int&amp;gt; &amp;lt;chr&amp;gt;           &amp;lt;chr&amp;gt;           
##  1 ELIZA NA                11 Rondônia        [1940, 1950]    
##  2 ELIZA NA                11 Rondônia        [1950, 1960]    
##  3 ELIZA NA                11 Rondônia        [1960, 1970]    
##  4 ELIZA NA                11 Rondônia        [1970, 1980]    
##  5 ELIZA NA                11 Rondônia        [1980, 1990]    
##  6 ELIZA NA                11 Rondônia        [1990, 2000]    
##  7 ELIZA NA                11 Rondônia        [2000, 2010]    
##  8 ELIZA NA                12 Acre            [1940, 1950]    
##  9 ELIZA NA                12 Acre            [1960, 1970]    
## 10 ELIZA NA                12 Acre            [1970, 1980]    
## # ... with 208 more rows, and 2 more variables: nascimento_decada &amp;lt;int&amp;gt;,
## #   frequencia &amp;lt;int&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Primeiro vamos analisar a frequência do nome pela década de nascimento somando os valores de todos os estados.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;eliza_estado %&amp;gt;% 
  group_by(nascimento_decada) %&amp;gt;% 
  summarise(frequencia = sum(frequencia)) %&amp;gt;% 
  ggplot(aes(nascimento_decada, frequencia)) +
    geom_line(size = 1) +
    geom_point(shape = 21, color = &amp;quot;white&amp;quot;, fill =  &amp;quot;#80b1d3&amp;quot;, size = 7, stroke = 2) +
    labs(x = &amp;quot;Década de nascimento&amp;quot;, y = &amp;quot;Frequência do nome Eliza&amp;quot;) +
    scale_x_continuous(breaks = seq(1900, 2020, 10)) + 
    scale_y_continuous(limits = c(0, NA), labels = scales::unit_format(unit = &amp;quot;k&amp;quot;, scale = 1e-3)) + 
    theme_bw(16)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://italocegatta.github.io/post/2019-01-01-o-quao-popular-e-o-seu-nome_files/figure-html/unnamed-chunk-8-1.svg&#34; width=&#34;960&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Também podemos ver a distribuição espacial pelos estados do Brasil.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;eliza_estado %&amp;gt;% 
  left_join(brmap_estado_simples, by = c(&amp;quot;localidade_nome&amp;quot; = &amp;quot;estado_nome&amp;quot;)) %&amp;gt;% 
  st_as_sf() %&amp;gt;% 
  ggplot(aes(fill = frequencia)) +
    geom_sf(color = &amp;quot;white&amp;quot;) +
    scale_fill_distiller(palette = &amp;quot;Purples&amp;quot;, direction = 1) +
    labs(fill = &amp;quot;Frequência do nome Eliza&amp;quot;) +
    theme_bw(16) +
    theme(legend.position = &amp;quot;bottom&amp;quot;, legend.justification = &amp;quot;right&amp;quot;) +
    guides(fill = guide_colorbar(barwidth = 15, title.position = &amp;quot;top&amp;quot;))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://italocegatta.github.io/post/2019-01-01-o-quao-popular-e-o-seu-nome_files/figure-html/unnamed-chunk-9-1.png&#34; width=&#34;960&#34; /&gt;&lt;/p&gt;
&lt;p&gt;A segunda função presente no pacote acessa o rank dos nomes mais populares por sexo, década de nascimento e localidade.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;rank_decada &amp;lt;- map_dfr(seq(1930, 2000, 10), ~brnome_rank(decada = .x))

rank_decada %&amp;gt;%
  ggplot(aes(decada, ranking, fill = frequencia, label = nome)) +
  geom_line(aes(group = nome), alpha = 0.5) +
  geom_label(color = &amp;quot;black&amp;quot;, size = 3) +
  #facet_wrap(~sexo, labeller = labeller(sexo = c(&amp;quot;F&amp;quot; = &amp;quot;Feminino&amp;quot;, &amp;quot;M&amp;quot; = &amp;quot;Masculino&amp;quot;))) +
  labs(x = &amp;quot;Décade de nascimento&amp;quot;, y = &amp;quot;Ranking&amp;quot;, fill = &amp;quot;Frequência&amp;quot;) +
  scale_x_continuous(breaks = seq(1930, 2000, 10)) +
  scale_y_reverse(breaks = 1:20) +
  scale_fill_distiller(
    palette = &amp;quot;PuBuGn&amp;quot;, direction = 1, 
    labels = scales::unit_format(unit = &amp;quot;k&amp;quot;, scale = 1e-3)
  ) +
  theme_bw() +
  theme(legend.position = &amp;quot;bottom&amp;quot;, legend.justification = &amp;quot;right&amp;quot;) +
  guides(fill = guide_colorbar(barwidth = 20, title.position = &amp;quot;top&amp;quot;))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://italocegatta.github.io/post/2019-01-01-o-quao-popular-e-o-seu-nome_files/figure-html/unnamed-chunk-10-1.svg&#34; width=&#34;960&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Para finalizar, vamos fazer um gráfico com os nomes mais frequentes em forma de nuvem de palavras.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;top_nomes &amp;lt;- bind_rows(
  brnome_rank(sexo = &amp;quot;f&amp;quot;),
  brnome_rank(sexo = &amp;quot;m&amp;quot;)
)
  
set.seed(1)
wordcloud(top_nomes$nome, top_nomes$frequencia, scale=c(8, 1))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://italocegatta.github.io/post/2019-01-01-o-quao-popular-e-o-seu-nome_files/figure-html/unnamed-chunk-11-1.svg&#34; width=&#34;960&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Caso tenha alguma dúvida ou sugestão sobre o post, fique à vontade para fazer um comentário ou me contatar por E-mail.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;sessioninfo::session_info(c(&amp;quot;readr&amp;quot;, &amp;quot;dplyr&amp;quot;, &amp;quot;purrr&amp;quot;, &amp;quot;tidyr&amp;quot;, &amp;quot;ggplot2&amp;quot;, &amp;quot;forcats&amp;quot;, &amp;quot;brmap&amp;quot;, &amp;quot;brnome&amp;quot;, &amp;quot;wordcloud&amp;quot;))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## - Session info ----------------------------------------------------------
##  setting  value                       
##  version  R version 3.5.3 (2019-03-11)
##  os       Windows 10 x64              
##  system   x86_64, mingw32             
##  ui       RTerm                       
##  language (EN)                        
##  collate  Portuguese_Brazil.1252      
##  ctype    Portuguese_Brazil.1252      
##  tz       America/Sao_Paulo           
##  date     2019-07-21                  
## 
## - Packages --------------------------------------------------------------
##  package      * version    date       lib
##  askpass        1.1        2019-01-13 [1]
##  assertthat     0.2.1      2019-03-21 [1]
##  backports      1.1.4      2019-04-10 [1]
##  BH             1.69.0-1   2019-01-07 [1]
##  brmap        * 0.1.0      2019-03-04 [1]
##  brnome       * 0.0.0.9000 2019-07-08 [1]
##  class          7.3-15     2019-01-01 [2]
##  classInt       0.3-3      2019-04-26 [1]
##  cli            1.1.0      2019-03-19 [1]
##  clipr          0.6.0      2019-04-15 [1]
##  colorspace     1.4-1      2019-03-18 [1]
##  crayon         1.3.4      2017-09-16 [1]
##  curl           3.3        2019-01-10 [1]
##  DBI            1.0.0      2018-05-02 [1]
##  digest         0.6.20     2019-07-04 [1]
##  dplyr        * 0.8.3      2019-07-04 [1]
##  e1071          1.7-2      2019-06-05 [1]
##  ellipsis       0.2.0.1    2019-07-02 [1]
##  fansi          0.4.0      2018-10-05 [1]
##  forcats      * 0.4.0      2019-02-17 [1]
##  ggplot2      * 3.2.0      2019-06-16 [1]
##  glue           1.3.1      2019-03-12 [1]
##  gtable         0.3.0      2019-03-25 [1]
##  hms            0.4.2      2018-03-10 [1]
##  httr           1.4.0      2018-12-11 [1]
##  jsonlite       1.6        2018-12-07 [1]
##  KernSmooth     2.23-15    2015-06-29 [2]
##  labeling       0.3        2014-08-23 [1]
##  lattice        0.20-38    2018-11-04 [2]
##  lazyeval       0.2.2      2019-03-15 [1]
##  magrittr       1.5        2014-11-22 [1]
##  MASS           7.3-51.1   2018-11-01 [2]
##  Matrix         1.2-17     2019-03-22 [1]
##  mgcv           1.8-28     2019-03-21 [1]
##  mime           0.7        2019-06-11 [1]
##  munsell        0.5.0      2018-06-12 [1]
##  nlme           3.1-137    2018-04-07 [2]
##  openssl        1.4        2019-05-31 [1]
##  pillar         1.4.2      2019-06-29 [1]
##  pkgconfig      2.0.2      2018-08-16 [1]
##  plogr          0.2.0      2018-03-25 [1]
##  plyr           1.8.4      2016-06-08 [1]
##  purrr        * 0.3.2      2019-03-15 [1]
##  R6             2.4.0      2019-02-14 [1]
##  RColorBrewer * 1.1-2      2014-12-07 [1]
##  Rcpp           1.0.1      2019-03-17 [1]
##  readr        * 1.3.1      2018-12-21 [1]
##  reshape2       1.4.3      2017-12-11 [1]
##  rlang          0.4.0      2019-06-25 [1]
##  rvest          0.3.4      2019-05-15 [1]
##  scales         1.0.0      2018-08-09 [1]
##  selectr        0.4-1      2018-04-06 [1]
##  sf           * 0.7-6      2019-07-05 [1]
##  stringi        1.4.3      2019-03-12 [1]
##  stringr        1.4.0      2019-02-10 [1]
##  sys            3.2        2019-04-23 [1]
##  tibble         2.1.3      2019-06-06 [1]
##  tidyr        * 0.8.3      2019-03-01 [1]
##  tidyselect     0.2.5      2018-10-11 [1]
##  units          0.6-3      2019-05-03 [1]
##  utf8           1.1.4      2018-05-24 [1]
##  vctrs          0.2.0      2019-07-05 [1]
##  viridisLite    0.3.0      2018-02-01 [1]
##  withr          2.1.2      2018-03-15 [1]
##  wordcloud    * 2.6        2018-08-24 [1]
##  xml2           1.2.0      2018-01-24 [1]
##  zeallot        0.1.0      2018-01-28 [1]
##  source                              
##  CRAN (R 3.5.2)                      
##  CRAN (R 3.5.3)                      
##  CRAN (R 3.5.3)                      
##  CRAN (R 3.5.2)                      
##  local                               
##  Github (italocegatta/brnome@85a10a7)
##  CRAN (R 3.5.3)                      
##  CRAN (R 3.5.3)                      
##  CRAN (R 3.5.3)                      
##  CRAN (R 3.5.3)                      
##  CRAN (R 3.5.3)                      
##  CRAN (R 3.5.1)                      
##  CRAN (R 3.5.2)                      
##  CRAN (R 3.5.1)                      
##  CRAN (R 3.5.3)                      
##  CRAN (R 3.5.3)                      
##  CRAN (R 3.5.3)                      
##  CRAN (R 3.5.3)                      
##  CRAN (R 3.5.1)                      
##  CRAN (R 3.5.2)                      
##  CRAN (R 3.5.3)                      
##  CRAN (R 3.5.3)                      
##  CRAN (R 3.5.3)                      
##  CRAN (R 3.5.1)                      
##  CRAN (R 3.5.2)                      
##  CRAN (R 3.5.2)                      
##  CRAN (R 3.5.3)                      
##  CRAN (R 3.5.0)                      
##  CRAN (R 3.5.3)                      
##  CRAN (R 3.5.3)                      
##  CRAN (R 3.5.1)                      
##  CRAN (R 3.5.3)                      
##  CRAN (R 3.5.3)                      
##  CRAN (R 3.5.3)                      
##  CRAN (R 3.5.3)                      
##  CRAN (R 3.5.1)                      
##  CRAN (R 3.5.3)                      
##  CRAN (R 3.5.3)                      
##  CRAN (R 3.5.3)                      
##  CRAN (R 3.5.1)                      
##  CRAN (R 3.5.1)                      
##  CRAN (R 3.5.1)                      
##  CRAN (R 3.5.3)                      
##  CRAN (R 3.5.2)                      
##  CRAN (R 3.5.0)                      
##  CRAN (R 3.5.3)                      
##  CRAN (R 3.5.2)                      
##  CRAN (R 3.5.1)                      
##  CRAN (R 3.5.3)                      
##  CRAN (R 3.5.3)                      
##  CRAN (R 3.5.1)                      
##  CRAN (R 3.5.1)                      
##  CRAN (R 3.5.3)                      
##  CRAN (R 3.5.3)                      
##  CRAN (R 3.5.2)                      
##  CRAN (R 3.5.3)                      
##  CRAN (R 3.5.3)                      
##  CRAN (R 3.5.3)                      
##  CRAN (R 3.5.1)                      
##  CRAN (R 3.5.3)                      
##  CRAN (R 3.5.1)                      
##  CRAN (R 3.5.3)                      
##  CRAN (R 3.5.1)                      
##  CRAN (R 3.5.1)                      
##  CRAN (R 3.5.2)                      
##  CRAN (R 3.5.1)                      
##  CRAN (R 3.5.2)                      
## 
## [1] C:/Users/Italo/Documents/R/win-library/3.5
## [2] C:/Program Files/R/R-3.5.3/library&lt;/code&gt;&lt;/pre&gt;

      </content:encoded>
    </item>
    
    <item>
      <title>Risco de incêndio pela Fórmula de Monte Alegre</title>
      <link>https://italocegatta.github.io/risco-de-incendio-pela-formula-de-monte-alegre/</link>
      <pubDate>Sun, 15 Jul 2018 00:00:00 +0000</pubDate>
      
      <guid>https://italocegatta.github.io/risco-de-incendio-pela-formula-de-monte-alegre/</guid>
      <description>No setor florestal o fogo é uma questão recorrente e preocupante. Utilizar um índice de risco ou perigo de incêndio ajuda, no mínimo, no planejamento e no alerta para quem mora no entorno de maciços florestais como parques, hortos e plantios florestais.
A Fórmula de Monte Alegre (FMA) é um índice bastante simples, foi proposta em 1972 por Soares (1972) e utiliza apenas a umidade relativa do ar às 13h e a precipitação para calcular o risco de incêndio.</description>
      <content:encoded>
        


&lt;p&gt;No setor florestal o fogo é uma questão recorrente e preocupante. Utilizar um índice de risco ou perigo de incêndio ajuda, no mínimo, no planejamento e no alerta para quem mora no entorno de maciços florestais como parques, hortos e plantios florestais.&lt;/p&gt;
&lt;p&gt;A Fórmula de Monte Alegre (FMA) é um índice bastante simples, foi proposta em 1972 por &lt;span class=&#34;citation&#34;&gt;Soares (1972)&lt;/span&gt; e utiliza apenas a umidade relativa do ar às 13h e a precipitação para calcular o risco de incêndio. É um índice que possui 5 classes de risco e é cumulativo, portanto precisa ser calculado todos os dias.&lt;/p&gt;
&lt;p&gt;O objetivo deste post é implementar a FMA utilizando dados de 1988 à 2017 da estação meteorológica convencional da &lt;a href=&#34;http://www.esalq.usp.br/departamentos/leb/postocon.html&#34;&gt;ESALQ em Piracicaba&lt;/a&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;if (!require(&amp;quot;pacman&amp;quot;)) install.packages(&amp;quot;pacman&amp;quot;)
pacman::p_load(readr, dplyr, tidyr, forcats, lubridate, ggplot2, ggridges)&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;base &amp;lt;- read_csv2(
  &amp;quot;https://raw.githubusercontent.com/italocegatta/italocegatta.github.io_source/master/content/dados/posto_esalq_dia.csv&amp;quot;,
  col_types = cols(.default = col_number(), data = col_character())
)

base&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 10,961 x 3
##    data         ppt ur_med
##    &amp;lt;chr&amp;gt;      &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt;
##  1 01/01/1988   0       62
##  2 02/01/1988   0       65
##  3 03/01/1988   0       65
##  4 04/01/1988   0       69
##  5 05/01/1988  33.9     74
##  6 06/01/1988  66       90
##  7 07/01/1988   0       78
##  8 08/01/1988   0.5     88
##  9 09/01/1988  17.1     83
## 10 10/01/1988   7.8     83
## # ... with 10,951 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;O primeiro passo é estimar a umidade relativa às 13h, uma vez que é este valor que a FMA considera para o cálculo. Utilizaremos a equação ajustada por &lt;span class=&#34;citation&#34;&gt;Alvares et al. (2014)&lt;/span&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;base_fma &amp;lt;- base %&amp;gt;%
  mutate(
    data = dmy(data),
    ur13 = (8.77 * exp(0.024 * ur_med)) - 2.943
  ) %&amp;gt;% 
  select(data, ppt, ur13)

base_fma&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 10,961 x 3
##    data         ppt  ur13
##    &amp;lt;date&amp;gt;     &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt;
##  1 1988-01-01   0    35.9
##  2 1988-01-02   0    38.8
##  3 1988-01-03   0    38.8
##  4 1988-01-04   0    43.0
##  5 1988-01-05  33.9  48.9
##  6 1988-01-06  66    73.1
##  7 1988-01-07   0    54.1
##  8 1988-01-08   0.5  69.5
##  9 1988-01-09  17.1  61.3
## 10 1988-01-10   7.8  61.3
## # ... with 10,951 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Agora vamos fazer uma breve análise dos dados brutos. Começando pela chuva, podemos calcular o número médio de dias de chuva forte e fraca neste período. Entre julho e agosto há poucas chuvas em Piracicaba e isso já sugere que neste período o risco de incêndio deve ser alto.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;base_fma %&amp;gt;%
  mutate(ano = year(data), mes = month(data)) %&amp;gt;% 
  mutate(
    d_1 = ifelse(ppt &amp;gt; 1 &amp;amp; ppt &amp;lt;= 5, 1, 0),
    d_5 = ifelse(ppt &amp;gt; 5 , 1, 0)
  ) %&amp;gt;% 
  group_by(ano, mes) %&amp;gt;% 
  summarise_at(vars(d_1, d_5), sum, na.rm = TRUE) %&amp;gt;% 
  group_by(mes) %&amp;gt;% 
  summarise_at(vars(d_1, d_5), ~round(mean(.))) %&amp;gt;% 
  ungroup() %&amp;gt;% 
  rename(`&amp;lt;5` = d_1, `&amp;gt;5` = d_5) %&amp;gt;% 
  gather(nivel, d_chuva, `&amp;lt;5`:`&amp;gt;5`) %&amp;gt;% 
  mutate(
    d_chuva = ifelse(d_chuva == 0, NA, d_chuva),
    nivel = fct_relevel(nivel, &amp;quot;&amp;lt;5&amp;quot; , &amp;quot;&amp;gt;5&amp;quot;)
  ) %&amp;gt;% 
  ggplot(aes(mes, d_chuva, fill = nivel)) +
    geom_col(alpha = 0.8) +
    labs(
      x = &amp;quot;Mês do ano&amp;quot;,
      y = &amp;quot;Nº de dias de chuva (#)&amp;quot;,
      fill = NULL
    ) +
    scale_x_continuous(breaks = 1:12, labels = format(ISOdate(2000, 1:12, 1), &amp;quot;%b&amp;quot;)) +
    scale_y_continuous(breaks = seq(0, 30, 2), expand = expand_scale(mult = c(0.01, .1))) +
    scale_fill_manual(
      values = c(&amp;quot;#4292c6&amp;quot;, &amp;quot;#084594&amp;quot;),
      labels = c(&amp;quot;Chuva fraca (&amp;lt;5 mm)&amp;quot;,&amp;quot;Chuva forte (&amp;gt;5 mm)&amp;quot;)
    ) +
    theme_bw(16) +
    theme(legend.position = &amp;quot;top&amp;quot;, panel.grid.minor.x = element_blank())&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://italocegatta.github.io/post/2018-07-15-risco-de-incendio-pela-formula-de-monte-alegre_files/figure-html/unnamed-chunk-4-1.svg&#34; width=&#34;960&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Olhando para a distribuição da umidade relativa em cada mês, podemos ver que em junho a mediana ainda está próximo dos 50% de umidade. E só em julho que os dias mais secos começam a ter mais frequência e essa tendência aumenta até setembro, depois retorna gradativamente até a mediana de 57% de umidade em dezembro.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;base_fma %&amp;gt;% 
  filter(!is.na(ur13)) %&amp;gt;% 
  mutate(mes = factor(month(data))) %&amp;gt;% 
  ggplot(aes(ur13, mes)) +
    geom_density_ridges(quantile_lines = TRUE, quantiles = 2, fill = &amp;quot;#016c59&amp;quot;, alpha = 0.9) +
    labs(x = &amp;quot;Umidade Relativa às 13h (%)&amp;quot;, y = &amp;quot;Mês do ano&amp;quot;) +
    scale_x_continuous(breaks = seq(10, 100, 10)) +
    scale_y_discrete(labels = format(ISOdate(2000, 1:12, 1), &amp;quot;%b&amp;quot;)) +
    theme_bw(16)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://italocegatta.github.io/post/2018-07-15-risco-de-incendio-pela-formula-de-monte-alegre_files/figure-html/unnamed-chunk-5-1.svg&#34; width=&#34;960&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Sobre a Fórmula de Monte Alegre, o contexto que motivou seu desenvolvimento foi bastante trágico. Em 1963 um grande incêndio atingiu o estado do Paraná, com centenas de mortes e cerca de 2 milhões de hectares de florestas queimadas. Em 1972 o Professor Ronaldo Soares, da UFPR, defendeu sua tese de mestrado propondo a Fórmula de Monte Alegre com base em registros de incêndios florestais coletados a partir de 1965 na fazenda Monte Alegre (Klabin), em Telêmaco Borba-PR.&lt;/p&gt;
&lt;p&gt;A cálculo do índice é bastante simples, basta calcular o valor FMA do dia corrente e somar com o valor do dia anterior. O FMA é calculado através da seguinte expressão:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.sciweavers.org/tex2img.php?eq=FMA%20%3D%20%20%5Csum_%7Bi%3D1%7D%5En%20%20%5Cfrac%7B100%7D%7BURi_%7B13h%7D%7D%20&amp;bc=White&amp;fc=Black&amp;im=jpg&amp;fs=12&amp;ff=arev&amp;edit=0&#34; align=&#34;center&#34; border=&#34;0&#34; alt=&#34;FMA =  \sum_{i=1}^n  \frac{100}{URi_{13h}} &#34; width=&#34;139&#34; height=&#34;62&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Entretanto é preciso aplicar restrições ao valor FMA de acordo com a chuva do dia, seguindo estes parâmetros:&lt;/p&gt;
&lt;table&gt;
&lt;colgroup&gt;
&lt;col width=&#34;14%&#34; /&gt;
&lt;col width=&#34;86%&#34; /&gt;
&lt;/colgroup&gt;
&lt;thead&gt;
&lt;tr class=&#34;header&#34;&gt;
&lt;th&gt;Precipitação&lt;/th&gt;
&lt;th&gt;Restrição&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td&gt;&amp;lt; 2,5&lt;/td&gt;
&lt;td&gt;Nenhuma&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td&gt;2,5 - 4,9&lt;/td&gt;
&lt;td&gt;0,7 * FMAi-1 + FMAi&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td&gt;5,0 - 9,9&lt;/td&gt;
&lt;td&gt;0,4 * FMAi-1 + FMAi&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td&gt;10,0 - 12,9&lt;/td&gt;
&lt;td&gt;0,2 * FMAi-1 + FMAi&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td&gt;&amp;gt; 12,9&lt;/td&gt;
&lt;td&gt;Interromper o cálculo anterior (FMAi = 0) e começar novo cálculo no dia seguinte&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;O resultado do índice é apresentado com frequência na forma de classes de risco, obedecendo estes limites:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr class=&#34;header&#34;&gt;
&lt;th&gt;FMA&lt;/th&gt;
&lt;th&gt;Grau de perigo&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td&gt;0 - 1,0&lt;/td&gt;
&lt;td&gt;Nulo&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td&gt;1,1 - 3,0&lt;/td&gt;
&lt;td&gt;Pequeno&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td&gt;3,1 - 8,0&lt;/td&gt;
&lt;td&gt;Médio&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td&gt;8,1 – 20,0&lt;/td&gt;
&lt;td&gt;Alto&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td&gt;&amp;gt; 20,0&lt;/td&gt;
&lt;td&gt;Muito alto&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Vamos agora declara as funções que vão calcular o FMA e atribuir as classes de risco aos nossos dados.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;fma &amp;lt;- function(data, ur, ppt) {
  
  # testa se os dados estão ordenados
  if (any(data != sort(data))) {
    stop(&amp;quot;data precisa estar em ordem crescente&amp;quot;)
  }

  # cria o vetor de resultado  
  n &amp;lt;- length(ur)
  fma_vec &amp;lt;- rep(NA_real_, n)
  
  for (i in seq_len(n)) {
    
    # primeiro valor eh 0   
    if (i == 1) {
      fma_vec[i] &amp;lt;- 0
      next()
    }
    
    # se dia anterior nao tem informacao, valor eh 0
    if (is.na(ur[i - 1])) {
      fma_vec[i] &amp;lt;- 0
      next()
    }
    
    # aplica restricoes da chuva
    fma_vec[i] &amp;lt;- case_when(
      ppt[i] &amp;lt; 2.5 ~ (100 / ur[i]) + fma_vec[i - 1] * 1 ,
      ppt[i] &amp;gt;= 2.5 &amp;amp; ppt[i] &amp;lt; 5  ~ (100 / ur[i]) + fma_vec[i - 1] * 0.7,
      ppt[i] &amp;gt;= 5   &amp;amp; ppt[i] &amp;lt; 10 ~ (100 / ur[i]) + fma_vec[i - 1] * 0.4,
      ppt[i] &amp;gt;= 10  &amp;amp; ppt[i] &amp;lt; 13 ~ (100 / ur[i]) + fma_vec[i - 1] * 0.2,
      ppt[i] &amp;gt;= 13 ~ 0
    )
  }
  
  fma_vec
}

fma_classe &amp;lt;- function(fma, limites = c(1, 3, 8, 20)) {
  
  classe &amp;lt;- case_when(
    fma &amp;lt;= 1 ~ &amp;quot;Nulo&amp;quot;,
    fma &amp;gt; 1 &amp;amp; fma &amp;lt;= 3 ~&amp;quot;Pequeno&amp;quot;,
    fma &amp;gt; 3 &amp;amp; fma &amp;lt;= 8 ~ &amp;quot;Médio&amp;quot;,
    fma &amp;gt; 8 &amp;amp; fma &amp;lt;= 20 ~ &amp;quot;Alto&amp;quot;,
    fma &amp;gt; 20 ~ &amp;quot;Muito Alto&amp;quot;
  )
  
  factor(classe, levels = c(&amp;quot;Nulo&amp;quot;, &amp;quot;Pequeno&amp;quot;, &amp;quot;Médio&amp;quot;, &amp;quot;Alto&amp;quot;, &amp;quot;Muito Alto&amp;quot;))
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Seguindo para o cálculo do índice, vamos criar um novo data frame com o valor FMA e as classes de riscos utilizando as funções que acabamos de criar.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;dados_fma &amp;lt;- base_fma %&amp;gt;% 
  mutate(
    fma = fma(data, ur13, ppt),
    risco = fma_classe(fma)
  )

dados_fma&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 10,961 x 5
##    data         ppt  ur13   fma risco  
##    &amp;lt;date&amp;gt;     &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;fct&amp;gt;  
##  1 1988-01-01   0    35.9  0    Nulo   
##  2 1988-01-02   0    38.8  2.58 Pequeno
##  3 1988-01-03   0    38.8  5.16 Médio  
##  4 1988-01-04   0    43.0  7.48 Médio  
##  5 1988-01-05  33.9  48.9  0    Nulo   
##  6 1988-01-06  66    73.1  0    Nulo   
##  7 1988-01-07   0    54.1  1.85 Pequeno
##  8 1988-01-08   0.5  69.5  3.29 Médio  
##  9 1988-01-09  17.1  61.3  0    Nulo   
## 10 1988-01-10   7.8  61.3  1.63 Pequeno
## # ... with 10,951 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A primeira abordagem que quero mostrar é a evolução do valor FMA ao longo do ano. Considerando o dia do ano ou dia juliano, podemos ver a evolução do valor FMA devido á ausência de chuvas fortes. O máximo dessa “corrida” de risco vai até próximo do dia 290, que corresponde ao meio de outubro.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;dados_fma %&amp;gt;% 
  mutate(
    ano = year(data),
    dia_ano = yday(data)
  ) %&amp;gt;% 
  ggplot(aes(dia_ano, factor(ano), fill = fma)) +
  geom_tile() +
  labs(x = &amp;quot;Dia do ano&amp;quot;, y = &amp;quot;Ano&amp;quot;, fill = &amp;quot;FMA&amp;quot;) +
  scale_fill_viridis_c(option = &amp;quot;viridis&amp;quot;) +
  scale_x_continuous(breaks = seq(20, 360, 20), expand = c(0, 0)) +
  theme_bw()&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://italocegatta.github.io/post/2018-07-15-risco-de-incendio-pela-formula-de-monte-alegre_files/figure-html/unnamed-chunk-8-1.png&#34; width=&#34;960&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Calculando a frequência das classes dentro de cada ano, podemos ver que predomina o risco Muito Alto, seguido do risco Alto. O risco nulo, ocorre em aproximadamente 10% dos dias do ano.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;dados_fma  %&amp;gt;% 
  filter(!is.na(risco)) %&amp;gt;% 
  group_by(ano = year(data), risco) %&amp;gt;% 
  tally() %&amp;gt;% 
  ggplot(aes(ano, n, fill = risco)) +
  geom_col(position = &amp;quot;fill&amp;quot;, alpha = 0.8) +
  labs(x = &amp;quot;Ano&amp;quot;, y = &amp;quot;Frequência&amp;quot;, fill = &amp;quot;Risco&amp;quot;) +
  scale_y_continuous(breaks = seq(0.1, 1, 0.1), labels = scales::percent) +
  scale_fill_brewer(palette = &amp;quot;Spectral&amp;quot;, direction = -1) +
  theme_bw(16)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://italocegatta.github.io/post/2018-07-15-risco-de-incendio-pela-formula-de-monte-alegre_files/figure-html/unnamed-chunk-9-1.svg&#34; width=&#34;960&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Olhando para a frequência de risco dentro dos meses, fica claro o maior risco próximo do mês de agosto, como sugeriram os gráficos de frequências de chuva e umidade relativa.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;dados_fma  %&amp;gt;% 
  filter(!is.na(risco)) %&amp;gt;% 
  group_by(mes = month(data), risco) %&amp;gt;% 
  tally() %&amp;gt;% 
  ggplot(aes(mes, n, fill = risco)) +
  geom_col(position = &amp;quot;fill&amp;quot;, alpha = 0.8) +
  labs(x = &amp;quot;Mês do ano&amp;quot;, y = &amp;quot;Frequência&amp;quot;, fill = &amp;quot;Risco&amp;quot;) +
  scale_x_continuous(breaks = 1:12, labels = format(ISOdate(2000, 1:12, 1), &amp;quot;%b&amp;quot;)) +
  scale_y_continuous(labels = scales::percent) +
  scale_fill_brewer(palette = &amp;quot;Spectral&amp;quot;, direction = -1) +
  theme_bw(16)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://italocegatta.github.io/post/2018-07-15-risco-de-incendio-pela-formula-de-monte-alegre_files/figure-html/unnamed-chunk-10-1.svg&#34; width=&#34;960&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Bom, de maneira geral os gráficos não mostraram muita coisa nova. Todo mundo sabe que nos meses mais secos do ano o risco de incêndio é maior. De fato, o índice apenas dá um respaldo quantitativo para o senso comum. Uma vez calculado o índice, é possível confrontar com dados reais de incêndios e propor novos valores para as classes de risco com o objetivo de deixá-lo mais assertivo para uma certa região.&lt;/p&gt;
&lt;p&gt;Caso tenha alguma dúvida ou sugestão sobre o post, fique à vontade para fazer um comentário ou me contatar por E-mail.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;sessioninfo::session_info(c(&amp;quot;readr&amp;quot;, &amp;quot;dplyr&amp;quot;, &amp;quot;ggplot2&amp;quot;, &amp;quot;tidyr&amp;quot;, &amp;quot;forcats&amp;quot;, &amp;quot;lubridate&amp;quot;, &amp;quot;ggridges&amp;quot;))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## - Session info ----------------------------------------------------------
##  setting  value                       
##  version  R version 3.5.3 (2019-03-11)
##  os       Windows 10 x64              
##  system   x86_64, mingw32             
##  ui       RTerm                       
##  language (EN)                        
##  collate  Portuguese_Brazil.1252      
##  ctype    Portuguese_Brazil.1252      
##  tz       America/Sao_Paulo           
##  date     2019-07-21                  
## 
## - Packages --------------------------------------------------------------
##  package      * version  date       lib source        
##  assertthat     0.2.1    2019-03-21 [1] CRAN (R 3.5.3)
##  backports      1.1.4    2019-04-10 [1] CRAN (R 3.5.3)
##  BH             1.69.0-1 2019-01-07 [1] CRAN (R 3.5.2)
##  cli            1.1.0    2019-03-19 [1] CRAN (R 3.5.3)
##  clipr          0.6.0    2019-04-15 [1] CRAN (R 3.5.3)
##  colorspace     1.4-1    2019-03-18 [1] CRAN (R 3.5.3)
##  crayon         1.3.4    2017-09-16 [1] CRAN (R 3.5.1)
##  digest         0.6.20   2019-07-04 [1] CRAN (R 3.5.3)
##  dplyr        * 0.8.3    2019-07-04 [1] CRAN (R 3.5.3)
##  ellipsis       0.2.0.1  2019-07-02 [1] CRAN (R 3.5.3)
##  fansi          0.4.0    2018-10-05 [1] CRAN (R 3.5.1)
##  forcats      * 0.4.0    2019-02-17 [1] CRAN (R 3.5.2)
##  ggplot2      * 3.2.0    2019-06-16 [1] CRAN (R 3.5.3)
##  ggridges     * 0.5.1    2018-09-27 [1] CRAN (R 3.5.2)
##  glue           1.3.1    2019-03-12 [1] CRAN (R 3.5.3)
##  gtable         0.3.0    2019-03-25 [1] CRAN (R 3.5.3)
##  hms            0.4.2    2018-03-10 [1] CRAN (R 3.5.1)
##  labeling       0.3      2014-08-23 [1] CRAN (R 3.5.0)
##  lattice        0.20-38  2018-11-04 [2] CRAN (R 3.5.3)
##  lazyeval       0.2.2    2019-03-15 [1] CRAN (R 3.5.3)
##  lubridate    * 1.7.4    2018-04-11 [1] CRAN (R 3.5.1)
##  magrittr       1.5      2014-11-22 [1] CRAN (R 3.5.1)
##  MASS           7.3-51.1 2018-11-01 [2] CRAN (R 3.5.3)
##  Matrix         1.2-17   2019-03-22 [1] CRAN (R 3.5.3)
##  mgcv           1.8-28   2019-03-21 [1] CRAN (R 3.5.3)
##  munsell        0.5.0    2018-06-12 [1] CRAN (R 3.5.1)
##  nlme           3.1-137  2018-04-07 [2] CRAN (R 3.5.3)
##  pillar         1.4.2    2019-06-29 [1] CRAN (R 3.5.3)
##  pkgconfig      2.0.2    2018-08-16 [1] CRAN (R 3.5.1)
##  plogr          0.2.0    2018-03-25 [1] CRAN (R 3.5.1)
##  plyr           1.8.4    2016-06-08 [1] CRAN (R 3.5.1)
##  purrr          0.3.2    2019-03-15 [1] CRAN (R 3.5.3)
##  R6             2.4.0    2019-02-14 [1] CRAN (R 3.5.2)
##  RColorBrewer   1.1-2    2014-12-07 [1] CRAN (R 3.5.0)
##  Rcpp           1.0.1    2019-03-17 [1] CRAN (R 3.5.3)
##  readr        * 1.3.1    2018-12-21 [1] CRAN (R 3.5.2)
##  reshape2       1.4.3    2017-12-11 [1] CRAN (R 3.5.1)
##  rlang          0.4.0    2019-06-25 [1] CRAN (R 3.5.3)
##  scales         1.0.0    2018-08-09 [1] CRAN (R 3.5.1)
##  stringi        1.4.3    2019-03-12 [1] CRAN (R 3.5.3)
##  stringr        1.4.0    2019-02-10 [1] CRAN (R 3.5.2)
##  tibble         2.1.3    2019-06-06 [1] CRAN (R 3.5.3)
##  tidyr        * 0.8.3    2019-03-01 [1] CRAN (R 3.5.3)
##  tidyselect     0.2.5    2018-10-11 [1] CRAN (R 3.5.1)
##  utf8           1.1.4    2018-05-24 [1] CRAN (R 3.5.1)
##  vctrs          0.2.0    2019-07-05 [1] CRAN (R 3.5.3)
##  viridisLite    0.3.0    2018-02-01 [1] CRAN (R 3.5.1)
##  withr          2.1.2    2018-03-15 [1] CRAN (R 3.5.1)
##  zeallot        0.1.0    2018-01-28 [1] CRAN (R 3.5.2)
## 
## [1] C:/Users/Italo/Documents/R/win-library/3.5
## [2] C:/Program Files/R/R-3.5.3/library&lt;/code&gt;&lt;/pre&gt;
&lt;div id=&#34;referencias&#34; class=&#34;section level1 unnumbered&#34;&gt;
&lt;h1&gt;Referências&lt;/h1&gt;
&lt;div id=&#34;refs&#34; class=&#34;references&#34;&gt;
&lt;div id=&#34;ref-alvares2014&#34;&gt;
&lt;p&gt;Alvares, Clayton Alcarde, Italo Ramos Cegatta, Lucas Augusto Abra Vieira, Rafaela de Freitas Pavani, Eduardo Moré Mattos, Paulo Cesar Sentelhas, José Luiz Stape, and Ronaldo Viana Soares. 2014. “Perigo de Incêndio Florestal: Aplicação Da Fórmula de Monte Alegre E Avaliação Do Histórico Para Piracicaba, Sp.” &lt;em&gt;Scientia Forestalis, Piracicaba&lt;/em&gt; 42 (104): 511–22.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;ref-soares1972&#34;&gt;
&lt;p&gt;Soares, Ronaldo Viana. 1972. “Determinação de Um ı́ndice de Perigo de Incêndio Para a Região Centro Paranaense, Brasil. Turrialba, Costa Rica, Catie/Iica,. 72 P.” PhD thesis, Tese de Mestrado.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

      </content:encoded>
    </item>
    
    <item>
      <title>Qual Estado tem mais pau-rodado?</title>
      <link>https://italocegatta.github.io/qual-estado-tem-mais-pau-rodado/</link>
      <pubDate>Sat, 24 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://italocegatta.github.io/qual-estado-tem-mais-pau-rodado/</guid>
      <description>Em Cuiabá, cidade que nasci e cresci, pau-rodado é um substantivo que define pessoas que nasceram em outro Estado mas moram em Cuiabá e ali construíram suas vidas. Aliás, Cuiabá sempre foi conhecida por ser uma Cidade super acolhedora e talvez por isso todos encaram o dito pau-rodado de uma forma engraçada e sem qualquer sentido pejorativo.
Muito bem, meu interesse com este post é analisar o comportamento dos fluxos migratórios entre Estados e assim encontrar os Estados que tem mais e menos pau-rodado em sua população residente.</description>
      <content:encoded>
        


&lt;p&gt;Em Cuiabá, cidade que nasci e cresci, &lt;em&gt;pau-rodado&lt;/em&gt; é um substantivo que define pessoas que nasceram em outro Estado mas moram em Cuiabá e ali construíram suas vidas. Aliás, Cuiabá sempre foi conhecida por ser uma Cidade super acolhedora e talvez por isso todos encaram o dito &lt;em&gt;pau-rodado&lt;/em&gt; de uma forma engraçada e sem qualquer sentido pejorativo.&lt;/p&gt;
&lt;p&gt;Muito bem, meu interesse com este post é analisar o comportamento dos fluxos migratórios entre Estados e assim encontrar os Estados que tem mais e menos &lt;em&gt;pau-rodado&lt;/em&gt; em sua população residente. Serei breve e não vamos abordar todos os Estados, mas se você tiver curiosidade poderá aproveitar o código para uma análise mais ampla.&lt;/p&gt;
&lt;p&gt;A motivação partiu de uma matéria do &lt;a href=&#34;https://www.nexojornal.com.br/grafico/2017/12/01/Fluxos-migrat%C3%B3rios-a-distribui%C3%A7%C3%A3o-da-popula%C3%A7%C3%A3o-de-cada-estado-pelo-pa%C3%ADs&#34;&gt;Nexo Jornal&lt;/a&gt; sobre este tema, porém ao nível estadual. Depois de algumas horas tentando decifrar o site do IBGE, cheguei na &lt;a href=&#34;https://sidra.ibge.gov.br/tabela/1852&#34;&gt;página&lt;/a&gt; que informa a população residente, por lugar de nascimento e unidade da federação.&lt;/p&gt;
&lt;p&gt;Então vamos começar a análise carregando os pacotes do R necessários para este post.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;if (!require(&amp;quot;pacman&amp;quot;)) install.packages(&amp;quot;pacman&amp;quot;)
pacman::p_load(readr, dplyr, tidyr, forcats, sf, geosphere, brmap, ggplot2, ggrepel, geofacet)
pacman::p_load_gh(&amp;quot;italocegatta/brmap&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Os dados originais estão disponíveis neste &lt;a href=&#34;https://sidra.ibge.gov.br/tabela/1852&#34;&gt;link&lt;/a&gt;, fiz apenas adequações porque o IBGE insiste em mesclar células nas tabelas disponibilizadas. Já nesta tabela você consegue olhar para o Estado que você mora e analisar quanto dos residentes nasceram em outros Estados. Mas o objetivo é enxergar isso de forma gráfica para ampliar a percepção dos dados.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;base &amp;lt;- read_csv2(&amp;quot;https://raw.githubusercontent.com/italocegatta/italocegatta.github.io_source/master/content/dados/pnad_2015_migracao.csv&amp;quot;)

base&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 27 x 28
##    Estado Rondônia  Acre Amazonas Roraima  Pará Amapá Tocantins Maranhão
##    &amp;lt;chr&amp;gt;     &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt;    &amp;lt;dbl&amp;gt;   &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt;     &amp;lt;dbl&amp;gt;    &amp;lt;dbl&amp;gt;
##  1 Rondô~    57.4   1.84     1.9     0.08  0.7  NA        0.02      1.02
##  2 Acre       1.54 87.9      3.89    0.02  0.17 NA        0.02      0.11
##  3 Amazo~     0.46  1.6     87.6     0.23  5.36  0.13     0.06      0.87
##  4 Rorai~     0.65  0.24     5.16   55.6   6.54  0.04     0.570    19.0 
##  5 Pará       0.03  0.02     0.49    0.02 84.6   0.19     1.07      6.89
##  6 Amapá      0.1   0.03     0.2     0.17 20.8  72.7      0.1       3.65
##  7 Tocan~     0.07  0.07     0.02   NA     2.83  0.02    69.5       8.58
##  8 Maran~     0.03  0.01     0.05   NA     1.11  0.01     0.32     92.4 
##  9 Piauí      0.04  0.02     0.04    0.05  0.28 NA        0.11      3.97
## 10 Ceará      0.03  0.04     0.11   NA     0.22  0.01     0.03      0.35
## # ... with 17 more rows, and 19 more variables: Piauí &amp;lt;dbl&amp;gt;, Ceará &amp;lt;dbl&amp;gt;,
## #   `Rio Grande do Norte` &amp;lt;dbl&amp;gt;, Paraíba &amp;lt;dbl&amp;gt;, Pernambuco &amp;lt;dbl&amp;gt;,
## #   Alagoas &amp;lt;dbl&amp;gt;, Sergipe &amp;lt;dbl&amp;gt;, Bahia &amp;lt;dbl&amp;gt;, `Minas Gerais` &amp;lt;dbl&amp;gt;,
## #   `Espírito Santo` &amp;lt;dbl&amp;gt;, `Rio de Janeiro` &amp;lt;dbl&amp;gt;, `São Paulo` &amp;lt;dbl&amp;gt;,
## #   Paraná &amp;lt;dbl&amp;gt;, `Santa Catarina` &amp;lt;dbl&amp;gt;, `Rio Grande do Sul` &amp;lt;dbl&amp;gt;, `Mato
## #   Grosso do Sul` &amp;lt;dbl&amp;gt;, `Mato Grosso` &amp;lt;dbl&amp;gt;, Goiás &amp;lt;dbl&amp;gt;, `Distrito
## #   Federal` &amp;lt;dbl&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Dados longitudinais como estes ajudam humanos a enxergar os valores de forma mais fácil, mas do ponto de vista de processamento de dados, não dá pra fazer muita coisa com os dados assim. Vamos organizá-los seguindo a filosofia do &lt;a href=&#34;https://italocegatta.github.io/o-conceito-tidy-data&#34;&gt;Tidy data&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;A nova tabela nos informa a porcentagem da população residente (coluna ‘valor’) para cada Estado, subdividindo os valores por local de nascimento. E agora vai a primeira simplificação: foram selecionados apenas os 6 Estados de nascimento mais representativos para cada Estado de residência.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;df &amp;lt;- base %&amp;gt;% 
  gather(reside, valor, -Estado) %&amp;gt;%
  select(nasce = Estado, reside, valor) %&amp;gt;% 
  replace_na(list(valor = 0)) %&amp;gt;% 
  group_by(nasce) %&amp;gt;% 
  filter(row_number(-valor) &amp;lt;= 6) %&amp;gt;% 
  ungroup()

df&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 162 x 3
##    nasce    reside   valor
##    &amp;lt;chr&amp;gt;    &amp;lt;chr&amp;gt;    &amp;lt;dbl&amp;gt;
##  1 Rondônia Rondônia 57.4 
##  2 Acre     Rondônia  1.54
##  3 Amazonas Rondônia  0.46
##  4 Acre     Acre     87.9 
##  5 Amazonas Acre      1.6 
##  6 Acre     Amazonas  3.89
##  7 Amazonas Amazonas 87.6 
##  8 Roraima  Amazonas  5.16
##  9 Roraima  Roraima  55.6 
## 10 Amazonas Pará      5.36
## # ... with 152 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Vamos nos preparar para a segunda simplificação: selecionar os extremos em termos de população que nasceu e reside no mesmo Estado. Então, RS, CE e PE são os Estados que mais tem moradores nascidos dentro do próprio Estado, enquanto RO, RR e DF tem uma parcela maior de residentes nascidos em outros Estados.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;estados_interesse &amp;lt;- df %&amp;gt;%
  filter(reside == nasce) %&amp;gt;%
  filter(row_number(-valor) &amp;lt;= 3 | row_number(valor) &amp;lt;= 3) %&amp;gt;% 
  arrange(-valor) %&amp;gt;%
  pull(nasce)

estados_interesse&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;Rio Grande do Sul&amp;quot; &amp;quot;Ceará&amp;quot;             &amp;quot;Pernambuco&amp;quot;       
## [4] &amp;quot;Rondônia&amp;quot;          &amp;quot;Roraima&amp;quot;           &amp;quot;Distrito Federal&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Preparando para o mapa, vamos pegar as coordenadas dos centroides de cada Estado.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;estado_cent &amp;lt;- brmap_estado_simples %&amp;gt;% 
  st_centroid() %&amp;gt;% 
  cbind(., st_coordinates(.)) %&amp;gt;% 
  st_set_geometry(NULL) %&amp;gt;% 
  select(estado = estado_nome, lon = X, lat = Y)

estado_cent&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##                 estado       lon        lat
## 1             Rondônia -62.84198 -10.913179
## 2                 Acre -70.47331  -9.212856
## 3             Amazonas -64.65314  -4.154180
## 4              Roraima -61.39929   2.084236
## 5                 Pará -53.06412  -3.974753
## 6                Amapá -51.95593   1.443332
## 7            Tocantins -48.32923 -10.150295
## 8             Maranhão -45.27924  -5.060364
## 9                Piauí -42.96862  -7.387507
## 10               Ceará -39.61569  -5.093333
## 11 Rio Grande do Norte -36.67345  -5.839671
## 12             Paraíba -36.83252  -7.121067
## 13          Pernambuco -37.99844  -8.326032
## 14             Alagoas -36.62489  -9.513860
## 15             Sergipe -37.44398 -10.584509
## 16               Bahia -41.72093 -12.475028
## 17        Minas Gerais -44.67342 -18.456183
## 18      Espírito Santo -40.67104 -19.575096
## 19      Rio de Janeiro -42.65244 -22.188742
## 20           São Paulo -48.73408 -22.263477
## 21              Paraná -51.61670 -24.635890
## 22      Santa Catarina -50.47486 -27.247326
## 23   Rio Grande do Sul -53.32041 -29.705543
## 24  Mato Grosso do Sul -54.84563 -20.327333
## 25         Mato Grosso -55.91218 -12.949089
## 26               Goiás -49.62337 -16.042019
## 27    Distrito Federal -47.79736 -15.780667&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;E agora, o pulo do gato. Vamos criar as linhas que ligam os Estados entre si e em seguida adicionar à tabela que informa as relações de fluxo. Portanto, para cada relação entre Estado de nascimento/residência temos uma feição de linha e o valor que representa a porcentagem de residentes.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;coord &amp;lt;- df %&amp;gt;% 
  left_join(estado_cent, by = c(&amp;quot;nasce&amp;quot; = &amp;quot;estado&amp;quot;)) %&amp;gt;% 
  left_join(estado_cent, by = c(&amp;quot;reside&amp;quot; = &amp;quot;estado&amp;quot;)) %&amp;gt;%
  filter(nasce %in% estados_interesse)

linhas &amp;lt;- gcIntermediate(
  select(coord, lon.x, lat.x), 
  select(coord, lon.y, lat.y), 
  sp = TRUE, addStartEnd = TRUE
  ) %&amp;gt;% 
  st_as_sf()

fluxo_linha &amp;lt;- coord %&amp;gt;% 
  select(nasce, reside, valor) %&amp;gt;% 
  bind_cols(linhas) %&amp;gt;% 
  left_join(estado_cent, by = c(&amp;quot;reside&amp;quot; = &amp;quot;estado&amp;quot;)) %&amp;gt;% 
  mutate(nasce = fct_relevel(nasce, estados_interesse)) %&amp;gt;% 
  st_as_sf()

fluxo_linha&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Simple feature collection with 36 features and 5 fields
## geometry type:  LINESTRING
## dimension:      XY
## bbox:           xmin: -64.65314 ymin: -29.70554 xmax: -36.62489 ymax: 2.084236
## epsg (SRID):    4326
## proj4string:    +proj=longlat +ellps=WGS84 +no_defs
## # A tibble: 36 x 6
##    nasce    reside  valor                             geometry   lon    lat
##    &amp;lt;fct&amp;gt;    &amp;lt;chr&amp;gt;   &amp;lt;dbl&amp;gt;                     &amp;lt;LINESTRING [°]&amp;gt; &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt;
##  1 Rondônia Rondôn~ 57.4  (-62.84198 -10.91318, -62.84198 -10~ -62.8 -10.9 
##  2 Roraima  Amazon~  5.16 (-61.39929 2.084236, -61.46309 1.96~ -64.7  -4.15
##  3 Roraima  Roraima 55.6  (-61.39929 2.084236, -61.39929 2.08~ -61.4   2.08
##  4 Roraima  Pará     6.54 (-61.39929 2.084236, -61.23585 1.96~ -53.1  -3.97
##  5 Roraima  Maranh~ 19.0  (-61.39929 2.084236, -61.08345 1.94~ -45.3  -5.06
##  6 Distrit~ Maranh~  4.42 (-47.79736 -15.78067, -47.74601 -15~ -45.3  -5.06
##  7 Ceará    Piauí    0.39 (-39.61569 -5.093333, -39.68117 -5.~ -43.0  -7.39
##  8 Distrit~ Piauí    5.08 (-47.79736 -15.78067, -47.69952 -15~ -43.0  -7.39
##  9 Roraima  Ceará    2.76 (-61.39929 2.084236, -60.9725 1.942~ -39.6  -5.09
## 10 Ceará    Ceará   95.8  (-39.61569 -5.093333, -39.61569 -5.~ -39.6  -5.09
## # ... with 26 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Para deixar o gráfico um pouco mais bonito, vamos dar cor ao valor que estamos estudando. Mas agora a feição será o polígono que representa o Estado de residentes.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;fluxo_poligono &amp;lt;- brmap_estado_simples %&amp;gt;% 
  left_join(df, by =  c(&amp;quot;estado_nome&amp;quot; = &amp;quot;reside&amp;quot;)) %&amp;gt;% 
  rename(reside = estado_nome) %&amp;gt;% 
  filter(nasce %in% estados_interesse) %&amp;gt;% 
  mutate(nasce = fct_relevel(nasce, estados_interesse)) %&amp;gt;% 
  select(nasce, reside, valor)

fluxo_poligono&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Simple feature collection with 36 features and 3 fields
## geometry type:  POLYGON
## dimension:      XY
## bbox:           xmin: -73.80156 ymin: -33.75077 xmax: -34.79288 ymax: 5.271841
## epsg (SRID):    4674
## proj4string:    +proj=longlat +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +no_defs
## # A tibble: 36 x 4
##    nasce       reside  valor                                       geometry
##  * &amp;lt;fct&amp;gt;       &amp;lt;chr&amp;gt;   &amp;lt;dbl&amp;gt;                                  &amp;lt;POLYGON [°]&amp;gt;
##  1 Rondônia    Rondôn~ 57.4  ((-61.58313 -8.798689, -61.5801 -8.802692, -6~
##  2 Roraima     Amazon~  5.16 ((-63.37209 2.211862, -63.35979 2.197102, -63~
##  3 Roraima     Roraima 55.6  ((-58.8955 1.227694, -58.89546 0.9047314, -58~
##  4 Roraima     Pará     6.54 ((-54.87225 2.433747, -54.87625 2.426694, -54~
##  5 Roraima     Maranh~ 19.0  ((-41.81411 -2.739309, -41.82457 -2.756218, -~
##  6 Distrito F~ Maranh~  4.42 ((-41.81411 -2.739309, -41.82457 -2.756218, -~
##  7 Ceará       Piauí    0.39 ((-41.32268 -2.92132, -41.32156 -2.935416, -4~
##  8 Distrito F~ Piauí    5.08 ((-41.32268 -2.92132, -41.32156 -2.935416, -4~
##  9 Roraima     Ceará    2.76 ((-37.25329 -4.831556, -37.44645 -4.880961, -~
## 10 Ceará       Ceará   95.8  ((-37.25329 -4.831556, -37.44645 -4.880961, -~
## # ... with 26 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Pronto, já temos todos os dados que fazer o gráfico de interesse. Lembrando que optamos por dar destaque a 6 Estados e para cada um deles, os 6 Estados de nascimento que mais representam a população de residentes. Sim, é um tanto complexo. Eu fiquei algumas horas para poder criar o código e entender o que estava processando.&lt;/p&gt;
&lt;p&gt;Como exemplo vamos interpretar as informações de Roraima: do total de residentes, 55.6% nasceram no próprio Estado de Roraima; 5.2%, 6.5% e 19% nasceram no Amazonas, Pará e Maranhão, respectivamente.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggplot() +
  geom_sf(data = brmap_estado_simples, color = &amp;quot;white&amp;quot;, fill = &amp;quot;grey80&amp;quot;, size = 0.3) +
  geom_sf(data = fluxo_poligono, aes(fill = valor), color = &amp;quot;white&amp;quot;, size = 0.3) +
  geom_sf(data = fluxo_linha, color = &amp;quot;cyan&amp;quot;, size = 0.3) +
  geom_label_repel(
    data = fluxo_linha,
    aes(lon, lat, label = round(valor, 1)),
    size = 3, segment.colour = NA
  ) +
  facet_wrap(~nasce) +
  labs(
    title = &amp;quot;População residente (% do total geral)&amp;quot;,
    subtitle = &amp;quot;PNAD/IBGE, 2015&amp;quot;,
    x = NULL, y = NULL
  ) +
  scale_fill_viridis_c(guide = FALSE) +
  coord_sf(datum = NA) +
  theme_void(16)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://italocegatta.github.io/post/2018-03-24-qual-estado-tem-mais-pau-rodado_files/figure-html/unnamed-chunk-8-1.png&#34; width=&#34;960&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Pontos interessantes:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Rondônia e Roraima retém uma proporção parecida da população dentro do próprio Estado, entretanto o pessoal que mora em Rondônia veio do Sul e Sudeste; ao passo que os moradores de Roraima vêm do AM, PA e MA.&lt;/li&gt;
&lt;li&gt;O Distrito Federal não me surpreendeu, grande parte de pessoas nasceram em GO, MG e BA.&lt;/li&gt;
&lt;li&gt;Um número expressivo de pessoas que nasceram em São Paulo e hoje moram no CE e PE… parece que o jogo virou, não é mesmo?&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Caso tenha alguma dúvida ou sugestão sobre o post, fique à vontade para fazer um comentário ou me contatar por E-mail.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;sessioninfo::session_info(c(&amp;quot;readr&amp;quot;, &amp;quot;dplyr&amp;quot;, &amp;quot;ggplot2&amp;quot;, &amp;quot;tidyr&amp;quot;, &amp;quot;forcats&amp;quot;, &amp;quot;sf&amp;quot;, &amp;quot;geosphere&amp;quot;, &amp;quot;ggrepel&amp;quot;, &amp;quot;geofacet&amp;quot;, &amp;quot;brmap&amp;quot;))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## - Session info ----------------------------------------------------------
##  setting  value                       
##  version  R version 3.5.3 (2019-03-11)
##  os       Windows 10 x64              
##  system   x86_64, mingw32             
##  ui       RTerm                       
##  language (EN)                        
##  collate  Portuguese_Brazil.1252      
##  ctype    Portuguese_Brazil.1252      
##  tz       America/Sao_Paulo           
##  date     2019-07-21                  
## 
## - Packages --------------------------------------------------------------
##  package       * version     date       lib source        
##  askpass         1.1         2019-01-13 [1] CRAN (R 3.5.2)
##  assertthat      0.2.1       2019-03-21 [1] CRAN (R 3.5.3)
##  backports       1.1.4       2019-04-10 [1] CRAN (R 3.5.3)
##  BH              1.69.0-1    2019-01-07 [1] CRAN (R 3.5.2)
##  brmap         * 0.1.0       2019-03-04 [1] local         
##  class           7.3-15      2019-01-01 [2] CRAN (R 3.5.3)
##  classInt        0.3-3       2019-04-26 [1] CRAN (R 3.5.3)
##  cli             1.1.0       2019-03-19 [1] CRAN (R 3.5.3)
##  clipr           0.6.0       2019-04-15 [1] CRAN (R 3.5.3)
##  colorspace      1.4-1       2019-03-18 [1] CRAN (R 3.5.3)
##  crayon          1.3.4       2017-09-16 [1] CRAN (R 3.5.1)
##  curl            3.3         2019-01-10 [1] CRAN (R 3.5.2)
##  DBI             1.0.0       2018-05-02 [1] CRAN (R 3.5.1)
##  digest          0.6.20      2019-07-04 [1] CRAN (R 3.5.3)
##  dplyr         * 0.8.3       2019-07-04 [1] CRAN (R 3.5.3)
##  e1071           1.7-2       2019-06-05 [1] CRAN (R 3.5.3)
##  ellipsis        0.2.0.1     2019-07-02 [1] CRAN (R 3.5.3)
##  fansi           0.4.0       2018-10-05 [1] CRAN (R 3.5.1)
##  forcats       * 0.4.0       2019-02-17 [1] CRAN (R 3.5.2)
##  geofacet      * 0.1.10      2019-03-13 [1] CRAN (R 3.5.3)
##  geogrid         0.1.1       2018-12-11 [1] CRAN (R 3.5.2)
##  geosphere     * 1.5-10      2019-05-26 [1] CRAN (R 3.5.3)
##  ggplot2       * 3.2.0       2019-06-16 [1] CRAN (R 3.5.3)
##  ggrepel       * 0.8.1       2019-05-07 [1] CRAN (R 3.5.3)
##  glue            1.3.1       2019-03-12 [1] CRAN (R 3.5.3)
##  gridExtra       2.3         2017-09-09 [1] CRAN (R 3.5.1)
##  gtable          0.3.0       2019-03-25 [1] CRAN (R 3.5.3)
##  hms             0.4.2       2018-03-10 [1] CRAN (R 3.5.1)
##  httr            1.4.0       2018-12-11 [1] CRAN (R 3.5.2)
##  imguR           1.0.3       2016-03-29 [1] CRAN (R 3.5.1)
##  jpeg            0.1-8       2014-01-23 [1] CRAN (R 3.5.0)
##  jsonlite        1.6         2018-12-07 [1] CRAN (R 3.5.2)
##  KernSmooth      2.23-15     2015-06-29 [2] CRAN (R 3.5.3)
##  labeling        0.3         2014-08-23 [1] CRAN (R 3.5.0)
##  lattice         0.20-38     2018-11-04 [2] CRAN (R 3.5.3)
##  lazyeval        0.2.2       2019-03-15 [1] CRAN (R 3.5.3)
##  magrittr        1.5         2014-11-22 [1] CRAN (R 3.5.1)
##  MASS            7.3-51.1    2018-11-01 [2] CRAN (R 3.5.3)
##  Matrix          1.2-17      2019-03-22 [1] CRAN (R 3.5.3)
##  mgcv            1.8-28      2019-03-21 [1] CRAN (R 3.5.3)
##  mime            0.7         2019-06-11 [1] CRAN (R 3.5.3)
##  munsell         0.5.0       2018-06-12 [1] CRAN (R 3.5.1)
##  nlme            3.1-137     2018-04-07 [2] CRAN (R 3.5.3)
##  openssl         1.4         2019-05-31 [1] CRAN (R 3.5.3)
##  pillar          1.4.2       2019-06-29 [1] CRAN (R 3.5.3)
##  pkgconfig       2.0.2       2018-08-16 [1] CRAN (R 3.5.1)
##  plogr           0.2.0       2018-03-25 [1] CRAN (R 3.5.1)
##  plyr            1.8.4       2016-06-08 [1] CRAN (R 3.5.1)
##  png             0.1-7       2013-12-03 [1] CRAN (R 3.5.0)
##  purrr           0.3.2       2019-03-15 [1] CRAN (R 3.5.3)
##  R6              2.4.0       2019-02-14 [1] CRAN (R 3.5.2)
##  RColorBrewer    1.1-2       2014-12-07 [1] CRAN (R 3.5.0)
##  Rcpp            1.0.1       2019-03-17 [1] CRAN (R 3.5.3)
##  RcppArmadillo   0.9.500.2.0 2019-06-12 [1] CRAN (R 3.5.3)
##  readr         * 1.3.1       2018-12-21 [1] CRAN (R 3.5.2)
##  reshape2        1.4.3       2017-12-11 [1] CRAN (R 3.5.1)
##  rgeos           0.4-3       2019-04-24 [1] CRAN (R 3.5.3)
##  rlang           0.4.0       2019-06-25 [1] CRAN (R 3.5.3)
##  rnaturalearth   0.1.0       2017-03-21 [1] CRAN (R 3.5.1)
##  scales          1.0.0       2018-08-09 [1] CRAN (R 3.5.1)
##  sf            * 0.7-6       2019-07-05 [1] CRAN (R 3.5.3)
##  sp              1.3-1       2018-06-05 [1] CRAN (R 3.5.1)
##  stringi         1.4.3       2019-03-12 [1] CRAN (R 3.5.3)
##  stringr         1.4.0       2019-02-10 [1] CRAN (R 3.5.2)
##  sys             3.2         2019-04-23 [1] CRAN (R 3.5.3)
##  tibble          2.1.3       2019-06-06 [1] CRAN (R 3.5.3)
##  tidyr         * 0.8.3       2019-03-01 [1] CRAN (R 3.5.3)
##  tidyselect      0.2.5       2018-10-11 [1] CRAN (R 3.5.1)
##  units           0.6-3       2019-05-03 [1] CRAN (R 3.5.3)
##  utf8            1.1.4       2018-05-24 [1] CRAN (R 3.5.1)
##  vctrs           0.2.0       2019-07-05 [1] CRAN (R 3.5.3)
##  viridisLite     0.3.0       2018-02-01 [1] CRAN (R 3.5.1)
##  withr           2.1.2       2018-03-15 [1] CRAN (R 3.5.1)
##  zeallot         0.1.0       2018-01-28 [1] CRAN (R 3.5.2)
## 
## [1] C:/Users/Italo/Documents/R/win-library/3.5
## [2] C:/Program Files/R/R-3.5.3/library&lt;/code&gt;&lt;/pre&gt;

      </content:encoded>
    </item>
    
    <item>
      <title>Como um cientista de dados pesquisa o carro que quer comprar?</title>
      <link>https://italocegatta.github.io/como-um-cientista-de-dados-pesquisa-o-carro-que-quer-comprar/</link>
      <pubDate>Sat, 29 Jul 2017 00:00:00 +0000</pubDate>
      
      <guid>https://italocegatta.github.io/como-um-cientista-de-dados-pesquisa-o-carro-que-quer-comprar/</guid>
      <description>Estou naquela parte da vida em que se planeja comprar um carro. Como eu sou, acima de todos os sonhos, pão duro, decidir qual marca, modelo, versão e ano do veículo não vai ser fácil. Pensando nisso resolvi escrever um pacote no R para me ajudar a tomar esta decisão. O objetivo deste post é apresentar o pacote e as funções que auxiliam na coleta das informações da tabela FIPE.</description>
      <content:encoded>
        


&lt;p&gt;Estou naquela parte da vida em que se planeja comprar um carro. Como eu sou, acima de todos os sonhos, pão duro, decidir qual marca, modelo, versão e ano do veículo não vai ser fácil. Pensando nisso resolvi escrever um pacote no R para me ajudar a tomar esta decisão. O objetivo deste post é apresentar o pacote e as funções que auxiliam na coleta das informações da tabela &lt;a href=&#34;http://veiculos.fipe.org.br/&#34;&gt;FIPE&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Para aqueles que já passaram pela etapa de compra ou venda de um carro, provavelmente já consultaram a famosa tabela. Nas palavras do próprio site da FIPE:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A Tabela Fipe expressa preços médios de veículos no mercado nacional, servindo apenas como um parâmetro para negociações ou avaliações. Os preços efetivamente praticados variam em função da região, conservação, cor, acessórios ou qualquer outro fator que possa influenciar as condições de oferta e procura por um veículo específico.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;A motivação para este pacote foi exclusivamente pessoal e por isso a utilização das funções está bastante restrita. Por isso, se alguém quiser ajudar no desenvolvimento do pacote é só chegar e mandar um &lt;a href=&#34;https://github.com/italocegatta/fipe&#34;&gt;Pull Request&lt;/a&gt; no Github, contribuições serão muito bem-vindas.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;if (!require(&amp;quot;pacman&amp;quot;)) install.packages(&amp;quot;pacman&amp;quot;)
pacman::p_load(dplyr, purrr, stringr, tidyr, forcats, ggplot2)
pacman::p_load_gh(&amp;quot;italocegatta/fipe&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Primeiro vou mostrar as funções e o workflow idealizado para o pacote. Queremos saber, por enquanto, o preço de uma BMW X6 M ano 2015 em julho de 2017.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# acesso aos dados no site da fipe
bmw_x6_m_2015 &amp;lt;- fipe_carro(
  modelo = &amp;quot;x6 m&amp;quot;, marca = &amp;quot;bmw&amp;quot;, 
  ano = 2015,  data_referencia = &amp;quot;2017-07-01&amp;quot;
)

bmw_x6_m_2015&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 1 x 5
##   modelo                            marca ano   data_referencia  valor
##   &amp;lt;chr&amp;gt;                             &amp;lt;chr&amp;gt; &amp;lt;fct&amp;gt; &amp;lt;date&amp;gt;           &amp;lt;dbl&amp;gt;
## 1 X6 M 4.4 4x4 V8 32V Bi-Turbo Aut. BMW   2015  2017-07-01      368603&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Achamos o preço do carro que eu queria. Apenas R$ 368 mil. Uma pechincha. Obviamente, saber quanto vale uma BMW X6 não faz diferença alguma no meu dia. Um abraço pra quem tem condições de comprar um carro desse sem precisar vender um rim.&lt;/p&gt;
&lt;p&gt;Agora que já conhecemos a função que pega o valor dos carros, vamos ampliar a consulta e justificar as horas que passamos aprendendo a programar. Já sabemos o preço do X6 M em julho/2017, mas e nos meses anteriores? Como foi a depreciação média do carro usado nos últimos meses? E os outros modelos X6, quanto será que estão valendo?&lt;/p&gt;
&lt;p&gt;Digamos que, agora, estas questões podem ser respondidas de forma bem rápida. Calma que eu mostro. Modificando a consulta anterior, iremos simplificar o nome do modelo para apenas x6, assim serão retornadas todas as versões do mesmo. A segunda alteração é a ausência do ano de fabricação, o que significa que serão retornados todos os anos na consulta. E por último, definimos os meses de referência para poder acompanhar a variação do preço ao longo nos anos.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;bmw_x6 &amp;lt;- fipe_carro(
  modelo = &amp;quot;x6&amp;quot;, marca = &amp;quot;bmw&amp;quot;, 
  data_referencia = seq.Date(as.Date(&amp;quot;2009-01-01&amp;quot;), as.Date(&amp;quot;2017-07-01&amp;quot;), by = &amp;quot;4 months&amp;quot;)
)

bmw_x6&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 480 x 5
##    modelo                            marca ano   data_referencia  valor
##    &amp;lt;chr&amp;gt;                             &amp;lt;chr&amp;gt; &amp;lt;fct&amp;gt; &amp;lt;date&amp;gt;           &amp;lt;dbl&amp;gt;
##  1 X6 M 4.4 4x4 V8 32V Bi-Turbo Aut. BMW   0 km  2010-05-01      477030
##  2 X6 M 4.4 4x4 V8 32V Bi-Turbo Aut. BMW   0 km  2010-09-01      465300
##  3 X6 M 4.4 4x4 V8 32V Bi-Turbo Aut. BMW   0 km  2011-01-01      468543
##  4 X6 M 4.4 4x4 V8 32V Bi-Turbo Aut. BMW   0 km  2011-05-01      459500
##  5 X6 M 4.4 4x4 V8 32V Bi-Turbo Aut. BMW   0 km  2011-09-01      462000
##  6 X6 M 4.4 4x4 V8 32V Bi-Turbo Aut. BMW   0 km  2012-01-01      464510
##  7 X6 M 4.4 4x4 V8 32V Bi-Turbo Aut. BMW   0 km  2012-05-01      558789
##  8 X6 M 4.4 4x4 V8 32V Bi-Turbo Aut. BMW   0 km  2012-09-01      573333
##  9 X6 M 4.4 4x4 V8 32V Bi-Turbo Aut. BMW   0 km  2013-01-01      550000
## 10 X6 M 4.4 4x4 V8 32V Bi-Turbo Aut. BMW   0 km  2013-05-01      494950
## # ... with 470 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Lembrando que o pacote não possui nenhum banco de dados armazenado, todas as informações são consultadas no site da tabela FIPE no ato da execução da função. Se sua internet não for muito rápida, pode ser que tenha demorado um pouquinho. Mas agora temos o banco de dados desejado. Imagina coletar estes dados, na mão, pelo site oficial!?!&lt;/p&gt;
&lt;p&gt;Bom agora o pacote está apresentado. Pretendo fazer outros posts com estudos de casos mais específicos, portanto vou deixar apenas um gráfico que resume a consulta que acabamos de fazer.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;bmw_x6 %&amp;gt;%
  ggplot(aes(data_referencia, valor, color = ano, group = ano)) +
    geom_line(color = &amp;quot;grey30&amp;quot;) +
    geom_point(size = 3) +
    facet_wrap(~modelo) +
    labs(
      x = &amp;quot;Mês de refêrencia&amp;quot;,
      y = &amp;quot;Valor (R$)&amp;quot;,
      color = &amp;quot;Ano do \nmodelo&amp;quot;
    ) +
    scale_y_continuous(breaks = seq(0, 700000, 50000), labels = scales::dollar_format(prefix = NULL, big.mark = &amp;quot;.&amp;quot;)) +
    scale_x_date(date_breaks = &amp;quot;1 year&amp;quot;, date_labels = &amp;quot;%b/%y&amp;quot;) +
    scale_color_viridis_d() +
    theme_bw() +
    theme(legend.position = &amp;quot;top&amp;quot;) &lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://italocegatta.github.io/post/2017-07-29-como-um-cientista-de-dados-pesquisa-o-carro-que-quer-comprar_files/figure-html/unnamed-chunk-4-1.svg&#34; width=&#34;960&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Caso tenha alguma dúvida ou sugestão sobre o post, fique à vontade para fazer um comentário ou me contatar por E-mail.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;sessioninfo::session_info(c(&amp;quot;readr&amp;quot;, &amp;quot;dplyr&amp;quot;, &amp;quot;ggplot2&amp;quot;, &amp;quot;purrr&amp;quot;, &amp;quot;stringr&amp;quot;, &amp;quot;tidyr&amp;quot;, &amp;quot;forcats&amp;quot;, &amp;quot;fipe&amp;quot;))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## - Session info ----------------------------------------------------------
##  setting  value                       
##  version  R version 3.5.3 (2019-03-11)
##  os       Windows 10 x64              
##  system   x86_64, mingw32             
##  ui       RTerm                       
##  language (EN)                        
##  collate  Portuguese_Brazil.1252      
##  ctype    Portuguese_Brazil.1252      
##  tz       America/Sao_Paulo           
##  date     2019-07-21                  
## 
## - Packages --------------------------------------------------------------
##  package      * version  date       lib source                            
##  askpass        1.1      2019-01-13 [1] CRAN (R 3.5.2)                    
##  assertthat     0.2.1    2019-03-21 [1] CRAN (R 3.5.3)                    
##  backports      1.1.4    2019-04-10 [1] CRAN (R 3.5.3)                    
##  BH             1.69.0-1 2019-01-07 [1] CRAN (R 3.5.2)                    
##  cli            1.1.0    2019-03-19 [1] CRAN (R 3.5.3)                    
##  clipr          0.6.0    2019-04-15 [1] CRAN (R 3.5.3)                    
##  colorspace     1.4-1    2019-03-18 [1] CRAN (R 3.5.3)                    
##  crayon         1.3.4    2017-09-16 [1] CRAN (R 3.5.1)                    
##  curl           3.3      2019-01-10 [1] CRAN (R 3.5.2)                    
##  digest         0.6.20   2019-07-04 [1] CRAN (R 3.5.3)                    
##  dplyr        * 0.8.3    2019-07-04 [1] CRAN (R 3.5.3)                    
##  ellipsis       0.2.0.1  2019-07-02 [1] CRAN (R 3.5.3)                    
##  fansi          0.4.0    2018-10-05 [1] CRAN (R 3.5.1)                    
##  fipe         * 0.0.1    2019-06-20 [1] Github (italocegatta/fipe@56db15e)
##  forcats      * 0.4.0    2019-02-17 [1] CRAN (R 3.5.2)                    
##  ggplot2      * 3.2.0    2019-06-16 [1] CRAN (R 3.5.3)                    
##  glue           1.3.1    2019-03-12 [1] CRAN (R 3.5.3)                    
##  gtable         0.3.0    2019-03-25 [1] CRAN (R 3.5.3)                    
##  hms            0.4.2    2018-03-10 [1] CRAN (R 3.5.1)                    
##  httr           1.4.0    2018-12-11 [1] CRAN (R 3.5.2)                    
##  jsonlite       1.6      2018-12-07 [1] CRAN (R 3.5.2)                    
##  labeling       0.3      2014-08-23 [1] CRAN (R 3.5.0)                    
##  lattice        0.20-38  2018-11-04 [2] CRAN (R 3.5.3)                    
##  lazyeval       0.2.2    2019-03-15 [1] CRAN (R 3.5.3)                    
##  lubridate      1.7.4    2018-04-11 [1] CRAN (R 3.5.1)                    
##  magrittr       1.5      2014-11-22 [1] CRAN (R 3.5.1)                    
##  MASS           7.3-51.1 2018-11-01 [2] CRAN (R 3.5.3)                    
##  Matrix         1.2-17   2019-03-22 [1] CRAN (R 3.5.3)                    
##  mgcv           1.8-28   2019-03-21 [1] CRAN (R 3.5.3)                    
##  mime           0.7      2019-06-11 [1] CRAN (R 3.5.3)                    
##  munsell        0.5.0    2018-06-12 [1] CRAN (R 3.5.1)                    
##  nlme           3.1-137  2018-04-07 [2] CRAN (R 3.5.3)                    
##  openssl        1.4      2019-05-31 [1] CRAN (R 3.5.3)                    
##  pillar         1.4.2    2019-06-29 [1] CRAN (R 3.5.3)                    
##  pkgconfig      2.0.2    2018-08-16 [1] CRAN (R 3.5.1)                    
##  plogr          0.2.0    2018-03-25 [1] CRAN (R 3.5.1)                    
##  plyr           1.8.4    2016-06-08 [1] CRAN (R 3.5.1)                    
##  purrr        * 0.3.2    2019-03-15 [1] CRAN (R 3.5.3)                    
##  R6             2.4.0    2019-02-14 [1] CRAN (R 3.5.2)                    
##  RColorBrewer   1.1-2    2014-12-07 [1] CRAN (R 3.5.0)                    
##  Rcpp           1.0.1    2019-03-17 [1] CRAN (R 3.5.3)                    
##  readr          1.3.1    2018-12-21 [1] CRAN (R 3.5.2)                    
##  reshape2       1.4.3    2017-12-11 [1] CRAN (R 3.5.1)                    
##  rlang          0.4.0    2019-06-25 [1] CRAN (R 3.5.3)                    
##  scales         1.0.0    2018-08-09 [1] CRAN (R 3.5.1)                    
##  stringi        1.4.3    2019-03-12 [1] CRAN (R 3.5.3)                    
##  stringr      * 1.4.0    2019-02-10 [1] CRAN (R 3.5.2)                    
##  sys            3.2      2019-04-23 [1] CRAN (R 3.5.3)                    
##  tibble         2.1.3    2019-06-06 [1] CRAN (R 3.5.3)                    
##  tidyr        * 0.8.3    2019-03-01 [1] CRAN (R 3.5.3)                    
##  tidyselect     0.2.5    2018-10-11 [1] CRAN (R 3.5.1)                    
##  utf8           1.1.4    2018-05-24 [1] CRAN (R 3.5.1)                    
##  vctrs          0.2.0    2019-07-05 [1] CRAN (R 3.5.3)                    
##  viridisLite    0.3.0    2018-02-01 [1] CRAN (R 3.5.1)                    
##  withr          2.1.2    2018-03-15 [1] CRAN (R 3.5.1)                    
##  zeallot        0.1.0    2018-01-28 [1] CRAN (R 3.5.2)                    
## 
## [1] C:/Users/Italo/Documents/R/win-library/3.5
## [2] C:/Program Files/R/R-3.5.3/library&lt;/code&gt;&lt;/pre&gt;

      </content:encoded>
    </item>
    
    <item>
      <title>Índice de uniformidade (PV50)</title>
      <link>https://italocegatta.github.io/indice-de-uniformidade-pv50/</link>
      <pubDate>Sun, 09 Oct 2016 00:00:00 +0000</pubDate>
      
      <guid>https://italocegatta.github.io/indice-de-uniformidade-pv50/</guid>
      <description>O PV50 é hoje o índice mais utilizado quando queremos expressar a uniformidade de um plantio florestal. Hakamada (2012) apresentou um estudo detalhado sobre diversos índices e concluiu que o PV50 é o índice mais indicado para explicar a relação entre uniformidade, qualidade silvicultural e produtividade em plantios homogêneos de Eucalyptus.
O objetivo deste post é mostrar, passo a passo, como calcular este índice no R e fazer uma breve análise de seus resultados.</description>
      <content:encoded>
        


&lt;p&gt;O PV50 é hoje o índice mais utilizado quando queremos expressar a uniformidade de um plantio florestal. &lt;span class=&#34;citation&#34;&gt;Hakamada (&lt;a href=&#34;#ref-Hakamada2012&#34;&gt;2012&lt;/a&gt;)&lt;/span&gt; apresentou um estudo detalhado sobre diversos índices e concluiu que o PV50 é o índice mais indicado para explicar a relação entre uniformidade, qualidade silvicultural e produtividade em plantios homogêneos de &lt;em&gt;Eucalyptus&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;O objetivo deste post é mostrar, passo a passo, como calcular este índice no R e fazer uma breve análise de seus resultados.&lt;/p&gt;
&lt;p&gt;O PV50 é a porcentagem de volume acumulado das 50% menores árvores do seu conjunto de dados, considerando as falhas de plantio e árvores mortas &lt;span class=&#34;citation&#34;&gt;(Hakamada et al. &lt;a href=&#34;#ref-Hakamada2015&#34;&gt;2015&lt;/a&gt;)&lt;/span&gt;. A expressão do índice é dada da seguinte forma:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.sciweavers.org/tex2img.php?eq=PV50%20%3D%20%5Cfrac%7B%5Csum_%7Bk%3D1%7D%5E%7B%5Cfrac%7Bn%7D%7B2%7D%7DV_%7Bij%7D%7D%7B%5Csum_%7Bk%3D1%7D%5E%7Bn%7DV_%7Bij%7D%7D&amp;bc=White&amp;fc=Black&amp;im=jpg&amp;fs=12&amp;ff=arev&amp;edit=0&#34; align=&#34;center&#34; border=&#34;0&#34; alt=&#34;PV50 = \frac{\sum_{k=1}^{\frac{n}{2}}V_{ij}}{\sum_{k=1}^{n}V_{ij}}&#34; width=&#34;139&#34; height=&#34;62&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Onde: PV50 = porcentagem acumulada do volume das 50% menores árvores plantadas; V = volume da árvore i; n = número de árvores plantadas ordenadas (da menor para a maior).&lt;/p&gt;
&lt;p&gt;Primeiro vamos entender os cálculos do índice, considerando apenas 10 árvores hipotéticas com 0,1 metros cúbicos de volume.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# carrega os pacotes necessários
if (!require(&amp;quot;pacman&amp;quot;)) install.packages(&amp;quot;pacman&amp;quot;)
pacman::p_load(readr, dplyr, ggplot2, forcats)&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# exemplo com número par
arv10 &amp;lt;- rep(0.1, 10)
str(arv10)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  num [1:10] 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Este é o referencial teórico de uniformidade, todas as árvores do mesmo tamanho. Sem precisar fazer conta, sabemos que o volume das 50% menores árvores é igual a 50% do volume total, o que equivale a um PV50 = 50.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# identifica a metade do numero de árvores
metade &amp;lt;- length(arv10)/2
metade&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 5&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# soma todas as árvores
soma_todas &amp;lt;- sum(arv10, na.rm = TRUE)
soma_todas&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 1&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# soma o valor de metade das árvores em ordem crescente
soma_metade &amp;lt;- sum(sort(arv10)[1:metade], na.rm = TRUE)
soma_metade&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 0.5&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# calcula o PV50
PV50 &amp;lt;- soma_metade / soma_todas * 100
PV50&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 50&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Agora vamos simular 11 árvores com o mesmo volume, veja o que acontece.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# exemplo com número impar
arv11 &amp;lt;- rep(0.1, 11)
str(arv11)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  num [1:11] 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 ...&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# metade do numero de árvores
metade &amp;lt;- length(arv11)/2
metade&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 5.5&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# soma todas as árvores
soma_todas &amp;lt;- sum(arv11, na.rm = TRUE)
soma_todas&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 1.1&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# soma o valor de metade das árvores em ordem crescente
soma_metade &amp;lt;- sum(sort(arv11)[1:metade], na.rm = TRUE)
soma_metade&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 0.5&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# calcula o PV50
PV50 &amp;lt;- soma_metade / soma_todas * 100
PV50&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 45.45455&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;O resultado deveria ser 50, mas como o número de árvores é ímpar, o R arredonda a posição 5,5 para 5 e pega até a quinta árvore no momento em que queremos somar as 50% menores. Para contornar isso, vamos calcular a soma das 50% menores árvores de uma forma diferente. Primeiro calculamos a soma acumulada e depois extraímos a média (semelhante ao modo de se calcular uma mediana).&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# vetor de soma acumulada
soma_acumulada &amp;lt;- cumsum(sort(arv11))
soma_acumulada&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  [1] 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0 1.1&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# soma a metade do vetor de soma acumulada
soma_metade &amp;lt;- mean(soma_acumulada[metade + 0L:1L], na.rm = TRUE)
soma_metade&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 0.55&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# calcula o PV50
PV50 &amp;lt;- soma_metade / soma_todas * 100
PV50&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 50&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Agora que a questão do número de árvores foi superada, podemos incluir árvores mortas, o que equivale a elementos do tipo &lt;code&gt;NA&lt;/code&gt; no R. Veja que o resultado não está consistente pois a &lt;code&gt;soma_acumulada&lt;/code&gt; ignorou as árvores mortas.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# exemplo com valores perdidos
arv11_na &amp;lt;- rep(0.1, 11)
arv11_na[c(3,4)] &amp;lt;- NA
str(arv11_na)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  num [1:11] 0.1 0.1 NA NA 0.1 0.1 0.1 0.1 0.1 0.1 ...&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# metade do numero de árvores
metade &amp;lt;- length(arv11_na)/2
metade&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 5.5&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# soma todas as árvores
soma_todas &amp;lt;- sum(arv11_na, na.rm = TRUE)
soma_todas&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 0.9&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# vetor de soma acumulada
soma_acumulada &amp;lt;- cumsum(sort(arv11_na))
soma_acumulada&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# soma a metade do vetor de soma acumulada
soma_metade &amp;lt;- mean(soma_acumulada[metade + 0L:1L], na.rm = TRUE)
soma_metade&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 0.55&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# calcula o PV50
PV50 &amp;lt;- soma_metade / soma_todas * 100
PV50&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 61.11111&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Para corrigir este o erro, temos de incluir manualmente as árvores mortas na sequência. Veja que agora o resultado está de acordo com o esperado.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# vetor de valores perdidos
mortas &amp;lt;- arv11_na[is.na(arv11_na)]
mortas&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] NA NA&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# metade do numero de árvores
metade &amp;lt;- length(arv11_na)/2
metade&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 5.5&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# soma todas as árvores
soma_todas &amp;lt;- sum(arv11_na, na.rm = TRUE)
soma_todas&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 0.9&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# vetor de soma acumulada com valores perdidos
soma_acumulada &amp;lt;- c(mortas, cumsum(sort(arv11_na)))
soma_acumulada&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  [1]  NA  NA 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# soma a metade do vetor de soma acumulada
soma_metade &amp;lt;- mean(soma_acumulada[metade + 0L:1L], na.rm = TRUE)
soma_metade&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 0.35&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# calcula o PV50
PV50 &amp;lt;- soma_metade / soma_todas * 100
PV50&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 38.88889&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Agora eu vou dar aquele passo mágico dos livros de matemática e física, em que o autor diz “é fácil notar que o resultado leva a …” e apresentar uma função que lida com as questões que mostramos acima e retorna o PV50 do nosso conjunto de dados de forma correta.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;pv50 &amp;lt;- function(x) {
  
  mortas &amp;lt;- x[is.na(x)]
  
  metade &amp;lt;- length(x)/2
  
  soma_todas &amp;lt;- sum(x, na.rm = TRUE)
  
  soma_acumulada &amp;lt;- c(mortas, cumsum(sort(x)))
  
  if (metade%%2L == 1L)
    soma_metade &amp;lt;- mean(soma_acumulada[metade], na.rm = TRUE)
  else
    soma_metade &amp;lt;- mean(soma_acumulada[metade + 0L:1L], na.rm = TRUE)
  
  z &amp;lt;- soma_metade / soma_todas * 100
  
  return(z)
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Podemos rapidamente verificar se os resultados estão consistentes fazendo alguns testes.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;a &amp;lt;- rep(10, 10)
str(a)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  num [1:10] 10 10 10 10 10 10 10 10 10 10&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;pv50(a) # Ok!&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 50&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;a1 &amp;lt;- rep(10 ,11)
str(a1)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  num [1:11] 10 10 10 10 10 10 10 10 10 10 ...&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;pv50(a1) # Ok!&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 50&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;b &amp;lt;- a
b[c(3, 7)] &amp;lt;- NA
str(b)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  num [1:10] 10 10 NA 10 10 10 NA 10 10 10&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;pv50(b) # Ok!&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 37.5&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;b1 &amp;lt;- a1
b1[c(3, 7)] &amp;lt;- NA
str(b1)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  num [1:11] 10 10 NA 10 10 10 NA 10 10 10 ...&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;pv50(b1) # Ok!&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 38.88889&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Boa, já temos uma função para calcular o PV50 e podemos aplicá-la em um conjunto de dados para podermos interpretar. Utilizaremos mais uma vez os dados do &lt;a href=&#34;www.projetotume.com&#34;&gt;Projeto TUME&lt;/a&gt;, referente ao &lt;a href=&#34;http://www.projetotume.com/tume134&#34;&gt;TUME 134&lt;/a&gt; plantado em Piracicaba-SP. O volume individual foi calculado arbitrariamente utilizando o fator de forma 0,5.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# importa o arquivo tume_55.csv
dados &amp;lt;- read_csv2(
  &amp;quot;https://github.com/italocegatta/italocegatta.github.io_source/raw/master/content/dados/tume_55.csv&amp;quot;
)

glimpse(dados)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Observations: 1,222
## Variables: 7
## $ Esp     &amp;lt;chr&amp;gt; &amp;quot;E_camaldulensis&amp;quot;, &amp;quot;E_camaldulensis&amp;quot;, &amp;quot;E_camaldulensis...
## $ I_meses &amp;lt;dbl&amp;gt; 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34...
## $ Parc_m2 &amp;lt;dbl&amp;gt; 288, 288, 288, 288, 288, 288, 288, 288, 288, 288, 288,...
## $ N_arv   &amp;lt;dbl&amp;gt; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16,...
## $ DAP_cm  &amp;lt;dbl&amp;gt; 5.411268, 12.254931, 3.978874, 6.429860, 9.676621, 5.6...
## $ H_m     &amp;lt;dbl&amp;gt; 7.651490, 11.424046, 5.909205, 8.572873, 10.498957, 7....
## $ Vol     &amp;lt;dbl&amp;gt; 0.008798406, 0.067375427, 0.003673747, 0.013918399, 0....&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Iremos calcular o PV50 e o volume por hectare para cada fator &lt;code&gt;Esp&lt;/code&gt; e &lt;code&gt;I_meses&lt;/code&gt; e em seguida ordenar as espécies pelo PV50.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# agrupa os dados em função de espécie e idade para 
# calcular o pv50 e o volume
dados_pv50 &amp;lt;- dados %&amp;gt;% 
  group_by(Esp, I_meses) %&amp;gt;% 
  summarise(
    Parc_m2 = mean( Parc_m2),
    PV50 = pv50(Vol),
    Vol_ha = sum(Vol, na.rm = TRUE) * (10000/Parc_m2)
  ) %&amp;gt;%
  ungroup() %&amp;gt;% 
  # ordena o fator de espécies de forma decrescente em função do pv50
  mutate(Esp = fct_reorder(Esp, -PV50))

dados_pv50&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 20 x 5
##    Esp                 I_meses Parc_m2  PV50 Vol_ha
##    &amp;lt;fct&amp;gt;                 &amp;lt;dbl&amp;gt;   &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt;
##  1 E_camaldulensis          34     288  21.4   47.5
##  2 E_camaldulensis          46     288  14.3   79.1
##  3 E_camaldulensis          60     600  13.2  110. 
##  4 E_camaldulensis          85     288  12.7  204. 
##  5 E_citriodora             34     288  17.8   46.6
##  6 E_citriodora             46     288  16.4   85.0
##  7 E_citriodora             60     600  12.5   97.0
##  8 E_citriodora             85     288  12.7  205. 
##  9 E_dunnii                 34     288  28.6  103. 
## 10 E_dunnii                 46     288  29.2  161. 
## 11 E_dunnii                 60     600  27.5  198. 
## 12 E_dunnii                 85     288  26.4  350. 
## 13 E_paniculata             34     288  27.4   46.4
## 14 E_paniculata             46     288  24.1   84.4
## 15 E_paniculata             60     600  19.6  115. 
## 16 E_paniculata             85     288  18.2  195. 
## 17 E_urophylla_grandis      34     288  26.3   85.7
## 18 E_urophylla_grandis      46     288  24.2  157. 
## 19 E_urophylla_grandis      60     600  20.3  217. 
## 20 E_urophylla_grandis      85     288  17.9  277.&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Para entendermos os dados, vamos primeiro ver o crescimento em volume de cada espécies em função do tempo (Figura &lt;a href=&#34;#fig:12-vol-idade&#34;&gt;1&lt;/a&gt;). Note que &lt;em&gt;E. dunnii&lt;/em&gt; e &lt;em&gt;E. urophylla&lt;/em&gt; x &lt;em&gt;E. grandis&lt;/em&gt; tinham crescimento muito parecido até os 60 meses de idade.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggplot(dados_pv50, aes(I_meses, Vol_ha, color = Esp)) +
  geom_point() +
  geom_line() +
  labs(
    color = &amp;quot;Espécies&amp;quot;,
    x = &amp;quot;Idade (meses)&amp;quot;,
    y = Volume~m^3~ha^-1
  ) +
  scale_color_brewer(palette = &amp;quot;Set1&amp;quot;) +
  theme_bw(16) +
  theme(legend.justification = &amp;quot;top&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;figure&#34;&gt;&lt;span id=&#34;fig:12-vol-idade&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;https://italocegatta.github.io/post/2016-10-09-indice-de-uniformidade-pv50_files/figure-html/12-vol-idade-1.svg&#34; alt=&#34;Crescimento em volume por hectare em função da idade.&#34; width=&#34;960&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figura  1: Crescimento em volume por hectare em função da idade.
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Agora podemos construir um gráfico que relaciona o PV50 e a idade (Figura &lt;a href=&#34;#fig:12-pv50-idade&#34;&gt;2&lt;/a&gt;). A interpretação do índice é simples, o PV50 representa a porcentagem em volume que as 50% menores árvores contribuem para o volume total. Em nossos dados, &lt;em&gt;E. dunnii&lt;/em&gt;, aos 85 meses de idade, tem um PV50 de aproximadamente 26. Isso quer dizer que aos 7 anos, as 50% menores árvores da parcela de &lt;em&gt;E. dunnii&lt;/em&gt; representam apenas 26% do volume total. Ou seja, 50% das árvores contribuem muito pouco para o volume total da parcela e isso tem um impacto direto na produtividade.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggplot(dados_pv50, aes(I_meses, PV50, color = Esp)) +
  geom_point() +
  geom_line() +
  labs(color = &amp;quot;Espécies&amp;quot;, x = &amp;quot;Idade (meses)&amp;quot;, y = &amp;quot;PV50&amp;quot;) +
  scale_color_brewer(palette = &amp;quot;Set1&amp;quot;) +
  scale_y_continuous(breaks = seq(10, 30, 2)) +
  theme_bw(16) +
  theme(legend.justification = &amp;quot;top&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;figure&#34;&gt;&lt;span id=&#34;fig:12-pv50-idade&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;https://italocegatta.github.io/post/2016-10-09-indice-de-uniformidade-pv50_files/figure-html/12-pv50-idade-1.svg&#34; alt=&#34;Variação do PV50 por espécies em função da idade.&#34; width=&#34;960&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figura  2: Variação do PV50 por espécies em função da idade.
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;A Figura &lt;a href=&#34;#fig:12-pv50-vol&#34;&gt;3&lt;/a&gt; mostra claramente a relação direta que há entre produção de madeira e a uniformidade ao longo do crescimento da floresta. Note também que na medida em que a idade avança, a uniformidade diminui, uma vez que a dominância das árvores maiores sobre as menores fica cada vez mais forte.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggplot(dados_pv50, aes(Vol_ha, PV50)) +
  geom_point(aes(color = factor(I_meses))) +
  geom_smooth(method = &amp;quot;lm&amp;quot;, formula = y ~x, se = FALSE) +
  facet_wrap(~Esp, dir = &amp;quot;v&amp;quot;) +
  labs(color = &amp;quot;Idade (meses)&amp;quot;, x = Volume~m^3~ha^-1, y = &amp;quot;PV50&amp;quot;) +
  scale_color_brewer(palette = &amp;quot;Dark2&amp;quot;) +
  theme_bw(16) +
  theme(legend.justification = &amp;quot;top&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;figure&#34;&gt;&lt;span id=&#34;fig:12-pv50-vol&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;https://italocegatta.github.io/post/2016-10-09-indice-de-uniformidade-pv50_files/figure-html/12-pv50-vol-1.svg&#34; alt=&#34;Relação entre o PV50 e volume por hectare em função da idade.&#34; width=&#34;960&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figura  3: Relação entre o PV50 e volume por hectare em função da idade.
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Por fim, para colocar tudo em um só gráfico, podemos adicionar ao gráfico de crescimento em volume a informação do PV50 para evidenciar que as espécies mais produtivas tem PV50 elevado e que este índice consegue explicar muito bem essa relação (Figura &lt;a href=&#34;#fig:12-vol-pv50-idade&#34;&gt;4&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;Um comentário interessante é que dentre as espécies que estamos estudando, todas são de origem seminal, com exceção do &lt;em&gt;E. dunnii&lt;/em&gt;, que é um clone. Este fator explica sua produtividade e alta homogeneidade, principalmente frente ao hibrido de &lt;em&gt;E. urophylla&lt;/em&gt; x &lt;em&gt;E. grandis&lt;/em&gt;, que é seu concorrente direto. Quando estivermos analisando dados de plantios clonais, o PV50 vai expressar a qualidade silvicultural do plantio, uma vez que a base genética é a mesma em todas as plantas.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggplot(dados_pv50, aes(I_meses, Vol_ha, color = Esp)) +
  geom_point(aes(size = PV50), alpha = 0.4) +
  geom_line() +
  labs(
    color = &amp;quot;Espécies&amp;quot;,
    x = &amp;quot;Idade (meses)&amp;quot;,
    y = Volume~m^3~ha^-1
  ) +
  scale_color_brewer(palette = &amp;quot;Set1&amp;quot;) +
  theme_bw(16) +
  theme(legend.justification = &amp;quot;top&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;figure&#34;&gt;&lt;span id=&#34;fig:12-vol-pv50-idade&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;https://italocegatta.github.io/post/2016-10-09-indice-de-uniformidade-pv50_files/figure-html/12-vol-pv50-idade-1.svg&#34; alt=&#34;Crescimento do volume em função da idade, com informação do PV50 no tamanho do ponto.&#34; width=&#34;960&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figura  4: Crescimento do volume em função da idade, com informação do PV50 no tamanho do ponto.
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Caso tenha alguma dúvida ou sugestão sobre o post, fique à vontade para fazer um comentário ou me contatar por E-mail.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;sessioninfo::session_info(c(&amp;quot;readr&amp;quot;, &amp;quot;dplyr&amp;quot;, &amp;quot;ggplot2&amp;quot;, &amp;quot;forcats&amp;quot;))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## - Session info ----------------------------------------------------------
##  setting  value                       
##  version  R version 3.5.3 (2019-03-11)
##  os       Windows 10 x64              
##  system   x86_64, mingw32             
##  ui       RTerm                       
##  language (EN)                        
##  collate  Portuguese_Brazil.1252      
##  ctype    Portuguese_Brazil.1252      
##  tz       America/Sao_Paulo           
##  date     2019-07-21                  
## 
## - Packages --------------------------------------------------------------
##  package      * version  date       lib source        
##  assertthat     0.2.1    2019-03-21 [1] CRAN (R 3.5.3)
##  backports      1.1.4    2019-04-10 [1] CRAN (R 3.5.3)
##  BH             1.69.0-1 2019-01-07 [1] CRAN (R 3.5.2)
##  cli            1.1.0    2019-03-19 [1] CRAN (R 3.5.3)
##  clipr          0.6.0    2019-04-15 [1] CRAN (R 3.5.3)
##  colorspace     1.4-1    2019-03-18 [1] CRAN (R 3.5.3)
##  crayon         1.3.4    2017-09-16 [1] CRAN (R 3.5.1)
##  digest         0.6.20   2019-07-04 [1] CRAN (R 3.5.3)
##  dplyr        * 0.8.3    2019-07-04 [1] CRAN (R 3.5.3)
##  ellipsis       0.2.0.1  2019-07-02 [1] CRAN (R 3.5.3)
##  fansi          0.4.0    2018-10-05 [1] CRAN (R 3.5.1)
##  forcats      * 0.4.0    2019-02-17 [1] CRAN (R 3.5.2)
##  ggplot2      * 3.2.0    2019-06-16 [1] CRAN (R 3.5.3)
##  glue           1.3.1    2019-03-12 [1] CRAN (R 3.5.3)
##  gtable         0.3.0    2019-03-25 [1] CRAN (R 3.5.3)
##  hms            0.4.2    2018-03-10 [1] CRAN (R 3.5.1)
##  labeling       0.3      2014-08-23 [1] CRAN (R 3.5.0)
##  lattice        0.20-38  2018-11-04 [2] CRAN (R 3.5.3)
##  lazyeval       0.2.2    2019-03-15 [1] CRAN (R 3.5.3)
##  magrittr       1.5      2014-11-22 [1] CRAN (R 3.5.1)
##  MASS           7.3-51.1 2018-11-01 [2] CRAN (R 3.5.3)
##  Matrix         1.2-17   2019-03-22 [1] CRAN (R 3.5.3)
##  mgcv           1.8-28   2019-03-21 [1] CRAN (R 3.5.3)
##  munsell        0.5.0    2018-06-12 [1] CRAN (R 3.5.1)
##  nlme           3.1-137  2018-04-07 [2] CRAN (R 3.5.3)
##  pillar         1.4.2    2019-06-29 [1] CRAN (R 3.5.3)
##  pkgconfig      2.0.2    2018-08-16 [1] CRAN (R 3.5.1)
##  plogr          0.2.0    2018-03-25 [1] CRAN (R 3.5.1)
##  plyr           1.8.4    2016-06-08 [1] CRAN (R 3.5.1)
##  purrr          0.3.2    2019-03-15 [1] CRAN (R 3.5.3)
##  R6             2.4.0    2019-02-14 [1] CRAN (R 3.5.2)
##  RColorBrewer   1.1-2    2014-12-07 [1] CRAN (R 3.5.0)
##  Rcpp           1.0.1    2019-03-17 [1] CRAN (R 3.5.3)
##  readr        * 1.3.1    2018-12-21 [1] CRAN (R 3.5.2)
##  reshape2       1.4.3    2017-12-11 [1] CRAN (R 3.5.1)
##  rlang          0.4.0    2019-06-25 [1] CRAN (R 3.5.3)
##  scales         1.0.0    2018-08-09 [1] CRAN (R 3.5.1)
##  stringi        1.4.3    2019-03-12 [1] CRAN (R 3.5.3)
##  stringr        1.4.0    2019-02-10 [1] CRAN (R 3.5.2)
##  tibble         2.1.3    2019-06-06 [1] CRAN (R 3.5.3)
##  tidyselect     0.2.5    2018-10-11 [1] CRAN (R 3.5.1)
##  utf8           1.1.4    2018-05-24 [1] CRAN (R 3.5.1)
##  vctrs          0.2.0    2019-07-05 [1] CRAN (R 3.5.3)
##  viridisLite    0.3.0    2018-02-01 [1] CRAN (R 3.5.1)
##  withr          2.1.2    2018-03-15 [1] CRAN (R 3.5.1)
##  zeallot        0.1.0    2018-01-28 [1] CRAN (R 3.5.2)
## 
## [1] C:/Users/Italo/Documents/R/win-library/3.5
## [2] C:/Program Files/R/R-3.5.3/library&lt;/code&gt;&lt;/pre&gt;
&lt;div id=&#34;referencias&#34; class=&#34;section level1 unnumbered&#34;&gt;
&lt;h1&gt;Referências&lt;/h1&gt;
&lt;div id=&#34;refs&#34; class=&#34;references&#34;&gt;
&lt;div id=&#34;ref-Hakamada2012&#34;&gt;
&lt;p&gt;Hakamada, Rodrigo Eiji. 2012. “Uso do inventário florestal como ferramenta de monitoramento da qualidade silvicultura em povoamentos clonais de Eucalyptus.” PhD thesis, Piracicaba: Universidade de São Paulo; Biblioteca Digital de Teses e Dissertações da Universidade de São Paulo. &lt;a href=&#34;https://doi.org/10.11606/D.11.2012.tde-05072012-100431&#34;&gt;https://doi.org/10.11606/D.11.2012.tde-05072012-100431&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;ref-Hakamada2015&#34;&gt;
&lt;p&gt;Hakamada, Rodrigo Eiji, José Luiz Stape, Cristiane Camargo Zani de Lemos, Adriano Emanuel Amaral Almeida, and Luis Fernando Silva. 2015. “Uniformidade entre árvores durante uma rotação e sua relação com a produtividade em Eucalyptus clonais.” &lt;em&gt;CERNE&lt;/em&gt; 21 (3): 465–72. &lt;a href=&#34;https://doi.org/10.1590/01047760201521031716&#34;&gt;https://doi.org/10.1590/01047760201521031716&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

      </content:encoded>
    </item>
    
  </channel>
</rss>
