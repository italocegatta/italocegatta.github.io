<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Forcats on Ítalo Cegatta</title>
    <link>/tags/forcats/index.xml</link>
    <description>Recent content in Forcats on Ítalo Cegatta</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>pt-br</language>
    <atom:link href="/tags/forcats/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Como um cientista de dados pesquisa o carro que quer comprar?</title>
      <link>/como-um-cientista-de-dados-pesquisa-o-carro-que-quer-comprar/</link>
      <pubDate>Sat, 29 Jul 2017 00:00:00 +0000</pubDate>
      
      <guid>/como-um-cientista-de-dados-pesquisa-o-carro-que-quer-comprar/</guid>
      <description>&lt;p&gt;Estou naquela parte da vida em que se planeja comprar um carro. Como eu sou, acima de todos os sonhos, pão duro, decidir qual marca, modelo, versão e ano do veículo não vai ser fácil. Pensando nisso resolvi escrever um pacote no R para me ajudar a tomar esta decisão. O objetivo deste post é apresentar o pacote e as funções que auxiliam na coleta das informações da tabela &lt;a href=&#34;http://veiculos.fipe.org.br/&#34;&gt;FIPE&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Para aqueles que já passaram pela etapa de compra ou venda de um carro, provavelmente já consultaram a famosa tabela. Nas palavras do próprio site da FIPE:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A Tabela Fipe expressa preços médios de veículos no mercado nacional, servindo apenas como um parâmetro para negociações ou avaliações. Os preços efetivamente praticados variam em função da região, conservação, cor, acessórios ou qualquer outro fator que possa influenciar as condições de oferta e procura por um veículo específico.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;A motivação para este pacote foi exclusivamente pessoal e por isso a utilização das funções está bastante restrita. Por isso, se alguém quiser ajudar no desenvolvimento do pacote é só chegar e mandar um &lt;a href=&#34;https://github.com/italocegatta/fipe&#34;&gt;Pull Request&lt;/a&gt; no Github, contribuições serão muito bem vindas.&lt;/p&gt;
&lt;p&gt;Primeiro vou mostrar as funções e o workflow idealizado para o pacote. Queremos saber, por enquanto, o preço atual de uma BMW X6 M ano 2015. O primeiro passo é definir o mês de referência que se deseja consultar o preço do veículo. A FIPE disponibiliza os valores consolidados desde janeiro de 2001.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;if (!require(&amp;quot;pacman&amp;quot;)) install.packages(&amp;quot;pacman&amp;quot;)
pacman::p_load(dplyr, purrr, stringr, tidyr, forcats, ggplot2)
pacman::p_load_gh(&amp;quot;italocegatta/fipe&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;fipe_referencia()&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 202 x 2
##      data_ref cod_ref
##        &amp;lt;date&amp;gt;   &amp;lt;int&amp;gt;
##  1 2017-10-01     218
##  2 2017-09-01     217
##  3 2017-08-01     216
##  4 2017-07-01     215
##  5 2017-06-01     214
##  6 2017-05-01     212
##  7 2017-04-01     211
##  8 2017-03-01     207
##  9 2017-02-01     205
## 10 2017-01-01     202
## # ... with 192 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Como o objetivo saber o preço atual do veículo, pegaremos o código &lt;code&gt;215&lt;/code&gt; (mês em que escrevo este post). Agora vamos procurar o código da marca BMW. Note que precisamos inserir o código do mês de referência para consultar a marca, essa é uma exigência do site da FIPE. Lembrando que o pacote não possui nenhum banco de dados armazenado, todas as informações são consultadas no site da tabela FIPE no ato da execução da função.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;fipe_marca(cod_ref = 215)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 87 x 2
##           marca cod_marca
##           &amp;lt;chr&amp;gt;     &amp;lt;int&amp;gt;
##  1        Acura         1
##  2       Agrale         2
##  3   Alfa Romeo         3
##  4       AM Gen         4
##  5  Asia Motors         5
##  6 ASTON MARTIN       189
##  7         Audi         6
##  8          BMW         7
##  9          BRM         8
## 10        Buggy         9
## # ... with 77 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Por sorte, o código &lt;code&gt;7&lt;/code&gt; da BMW aparece logo nos primeiros valores por ordem alfabética. Podemos seguir para o próximo passo e pegar o código do modelo que queremos. A consulta a baixo mostras que a BMW tem 221 modelos cadastrados na tabela FIPE. Como já definimos o modelo que queremos, vamos filtrar do dataframe para enxergar o código do modelo.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;(bmw &amp;lt;- fipe_modelo(cod_ref = 215, cod_marca = 7))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 221 x 2
##                                    modelo cod_modelo
##                                     &amp;lt;chr&amp;gt;      &amp;lt;int&amp;gt;
##  1              116iA 1.6 TB 16V 136cv 5p       6146
##  2                 118iA 2.0 16V 136cv 3p       5576
##  3                 118iA 2.0 16V 136cv 5p       4960
##  4         118iA Full 1.6 TB 16V 170cv 5p       6147
##  5 118iA/ Urban/Sport 1.6 TB 16V 170cv 5p       5923
##  6           120i 2.0 16V 150cv/ 156cv 5p        152
##  7          120iA 2.0 16V 150cv/ 156cv 5p        153
##  8                 120iA 2.0 16V 156cv 3p       4700
##  9          120iA Cabrio 2.0 16V 156cv 2p       4683
## 10    120iA Sport 2.0 ActiveFlex 16V Aut.       7178
## # ... with 211 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;filter(bmw, str_detect(modelo, &amp;quot;X6 M&amp;quot;))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 1 x 2
##                              modelo cod_modelo
##                               &amp;lt;chr&amp;gt;      &amp;lt;int&amp;gt;
## 1 X6 M 4.4 4x4 V8 32V Bi-Turbo Aut.       5189&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Pronto, agora já sabemos que o código que a FIPE dá para o modelo X6 M é o &lt;code&gt;5189&lt;/code&gt;. Teríamos tudo pronto, se não fosse o padrão que a FIPE adota no campo&lt;code&gt;ano&lt;/code&gt;, onde o ano do modelo é acrescido de um código de combustível. A diferenciação para os “0 km” é feita na mesma coluna, utilizando a identificação 32000-*. Enfim, contornando as falhas estruturais no banco de dados deles, agora sabemos os códigos que identificam o ano do modelo, bem como o carro 0 km. Como eu optei por procurar o valor do carro 2015, iremos considerar o código &lt;code&gt;2015-1&lt;/code&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;fipe_ano(cod_ref = 215, cod_marca = 7, cod_modelo = 5189)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 9 x 2
##     ano cod_ano
##   &amp;lt;chr&amp;gt;   &amp;lt;chr&amp;gt;
## 1  0 km 32000-1
## 2  2017  2017-1
## 3  2016  2016-1
## 4  2015  2015-1
## 5  2014  2014-1
## 6  2013  2013-1
## 7  2012  2012-1
## 8  2011  2011-1
## 9  2010  2010-1&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Agora sim vamos ao bendito preço da BMW!&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;fipe(cod_ref = 215, cod_marca = 7, cod_modelo = 5189, cod_ano = &amp;quot;2015-1&amp;quot;) %&amp;gt;% 
  glimpse()&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Observations: 1
## Variables: 7
## $ cod_fipe    &amp;lt;chr&amp;gt; &amp;quot;009144-8&amp;quot;
## $ ref         &amp;lt;date&amp;gt; 2017-07-01
## $ marca       &amp;lt;chr&amp;gt; &amp;quot;BMW&amp;quot;
## $ modelo      &amp;lt;chr&amp;gt; &amp;quot;X6 M 4.4 4x4 V8 32V Bi-Turbo Aut.&amp;quot;
## $ ano         &amp;lt;chr&amp;gt; &amp;quot;2015&amp;quot;
## $ combustivel &amp;lt;chr&amp;gt; &amp;quot;Gasolina&amp;quot;
## $ valor       &amp;lt;dbl&amp;gt; 368603&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Achamos o preço do carro que eu queria. Apenas R$ 368 mil. Uma pechincha. Obviamente, saber quanto vale uma BMW X6 não faz diferênça alguma no meu dia. Um abraço pra quem tem condições de comprar um carro desse sem precisar vender um rim.&lt;/p&gt;
&lt;p&gt;Agora que já conhecemos as funções e o fluxo para consultar o valor dos carros, vamos ampliar a consulta e justificar as horas que passamos aprendendo a programar. Já sabemos o preço do X6 M em julho/2017, mas e nos meses anteriores? Como será que foi a depreciação média do carro usado nos últimos meses? E os outros modelos X6, quanto será que estão valendo?&lt;/p&gt;
&lt;p&gt;Digamos que, agora, estas questões podem ser respondidas de forma bem rápida. Eu mostro.&lt;/p&gt;
&lt;p&gt;Vamos retomar os passos, mas agora no nível hard. Vou analisar o comportamento dos preços desde 2009. Para deixar a consulta mais rápida, serão considerados apenas 3 meses de referência por ano.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;(base_marca &amp;lt;- fipe_referencia() %&amp;gt;%
  filter(data_ref %in% seq.Date(as.Date(&amp;quot;2009-01-01&amp;quot;), as.Date(&amp;quot;2017-07-01&amp;quot;), by = &amp;quot;4 months&amp;quot;)) %&amp;gt;%
  mutate(marca = map(cod_ref, fipe_marca)) %&amp;gt;%
  unnest() %&amp;gt;% 
  filter(marca == &amp;quot;BMW&amp;quot;)
)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 26 x 4
##      data_ref cod_ref marca cod_marca
##        &amp;lt;date&amp;gt;   &amp;lt;int&amp;gt; &amp;lt;chr&amp;gt;     &amp;lt;int&amp;gt;
##  1 2017-05-01     212   BMW         7
##  2 2017-01-01     202   BMW         7
##  3 2016-09-01     196   BMW         7
##  4 2016-05-01     191   BMW         7
##  5 2016-01-01     187   BMW         7
##  6 2015-09-01     183   BMW         7
##  7 2015-05-01     179   BMW         7
##  8 2015-01-01     174   BMW         7
##  9 2014-09-01     170   BMW         7
## 10 2014-05-01     166   BMW         7
## # ... with 16 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Notem que agora temos um dataframe com códigos de referência entre janeiro/2008 a maio/2017. Seguindo a análise, precisamos encontrar os códigos dos modelos X6.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;(base_modelo &amp;lt;- mutate(base_marca, modelo = map2(cod_ref, cod_marca, fipe_modelo)) %&amp;gt;%
  unnest() %&amp;gt;% 
  filter(str_detect(modelo, &amp;quot;X6&amp;quot;))
)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 82 x 6
##      data_ref cod_ref marca cod_marca                             modelo
##        &amp;lt;date&amp;gt;   &amp;lt;int&amp;gt; &amp;lt;chr&amp;gt;     &amp;lt;int&amp;gt;                              &amp;lt;chr&amp;gt;
##  1 2017-05-01     212   BMW         7  X6 M 4.4 4x4 V8 32V Bi-Turbo Aut.
##  2 2017-05-01     212   BMW         7   X6 XDRIVE 35i 3.0 306cv Bi-Turbo
##  3 2017-05-01     212   BMW         7   X6 XDRIVE 50i 4.4 407cv Bi-Turbo
##  4 2017-05-01     212   BMW         7 X6 XDRIVE 50i M Sport 4.4 Bi-Turbo
##  5 2017-01-01     202   BMW         7  X6 M 4.4 4x4 V8 32V Bi-Turbo Aut.
##  6 2017-01-01     202   BMW         7   X6 XDRIVE 35i 3.0 306cv Bi-Turbo
##  7 2017-01-01     202   BMW         7   X6 XDRIVE 50i 4.4 407cv Bi-Turbo
##  8 2017-01-01     202   BMW         7 X6 XDRIVE 50i M Sport 4.4 Bi-Turbo
##  9 2016-09-01     196   BMW         7  X6 M 4.4 4x4 V8 32V Bi-Turbo Aut.
## 10 2016-09-01     196   BMW         7   X6 XDRIVE 35i 3.0 306cv Bi-Turbo
## # ... with 72 more rows, and 1 more variables: cod_modelo &amp;lt;int&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;O próximo passo é pegar, para cada versão, os diferentes anos de fabricação do carro. A função vai consultar os anos de fabricação que a FIPE consolidou para cada uma das 82 linhas (combinação entre modelo e mês de referência).&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;(base_consulta &amp;lt;- mutate(base_modelo, ano = pmap(list(cod_ref, cod_marca, cod_modelo), fipe_ano)) %&amp;gt;%
  unnest()
)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 480 x 8
##      data_ref cod_ref marca cod_marca                            modelo
##        &amp;lt;date&amp;gt;   &amp;lt;int&amp;gt; &amp;lt;chr&amp;gt;     &amp;lt;int&amp;gt;                             &amp;lt;chr&amp;gt;
##  1 2017-05-01     212   BMW         7 X6 M 4.4 4x4 V8 32V Bi-Turbo Aut.
##  2 2017-05-01     212   BMW         7 X6 M 4.4 4x4 V8 32V Bi-Turbo Aut.
##  3 2017-05-01     212   BMW         7 X6 M 4.4 4x4 V8 32V Bi-Turbo Aut.
##  4 2017-05-01     212   BMW         7 X6 M 4.4 4x4 V8 32V Bi-Turbo Aut.
##  5 2017-05-01     212   BMW         7 X6 M 4.4 4x4 V8 32V Bi-Turbo Aut.
##  6 2017-05-01     212   BMW         7 X6 M 4.4 4x4 V8 32V Bi-Turbo Aut.
##  7 2017-05-01     212   BMW         7 X6 M 4.4 4x4 V8 32V Bi-Turbo Aut.
##  8 2017-05-01     212   BMW         7 X6 M 4.4 4x4 V8 32V Bi-Turbo Aut.
##  9 2017-05-01     212   BMW         7 X6 M 4.4 4x4 V8 32V Bi-Turbo Aut.
## 10 2017-05-01     212   BMW         7  X6 XDRIVE 35i 3.0 306cv Bi-Turbo
## # ... with 470 more rows, and 3 more variables: cod_modelo &amp;lt;int&amp;gt;,
## #   ano &amp;lt;chr&amp;gt;, cod_ano &amp;lt;chr&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Se na sua internet a função anterior demorou, prepara que a próxima vai demorar um tanto mais. Temos 480 requisições para fazer no site da FIPE em busca dos preços que queremos.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;(consulta &amp;lt;- mutate(
  base_consulta, 
  consulta = pmap(list(cod_ref, cod_marca, cod_modelo, cod_ano), fipe)
  )  %&amp;gt;%
  select(consulta) %&amp;gt;% 
  unnest() %&amp;gt;% 
  select(ref, modelo, ano, valor)
)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 480 x 4
##           ref                            modelo   ano  valor
##        &amp;lt;date&amp;gt;                             &amp;lt;chr&amp;gt; &amp;lt;chr&amp;gt;  &amp;lt;dbl&amp;gt;
##  1 2017-05-01 X6 M 4.4 4x4 V8 32V Bi-Turbo Aut.  0 km 644550
##  2 2017-05-01 X6 M 4.4 4x4 V8 32V Bi-Turbo Aut.  2017 520193
##  3 2017-05-01 X6 M 4.4 4x4 V8 32V Bi-Turbo Aut.  2016 475803
##  4 2017-05-01 X6 M 4.4 4x4 V8 32V Bi-Turbo Aut.  2015 365088
##  5 2017-05-01 X6 M 4.4 4x4 V8 32V Bi-Turbo Aut.  2014 317505
##  6 2017-05-01 X6 M 4.4 4x4 V8 32V Bi-Turbo Aut.  2013 291749
##  7 2017-05-01 X6 M 4.4 4x4 V8 32V Bi-Turbo Aut.  2012 231191
##  8 2017-05-01 X6 M 4.4 4x4 V8 32V Bi-Turbo Aut.  2011 204481
##  9 2017-05-01 X6 M 4.4 4x4 V8 32V Bi-Turbo Aut.  2010 193629
## 10 2017-05-01  X6 XDRIVE 35i 3.0 306cv Bi-Turbo  0 km 415744
## # ... with 470 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Depois de 4 passos, temos o banco de dados desejado. Imagina coletar estes dados, na mão, pelo site oficial!&lt;/p&gt;
&lt;p&gt;Bom agora o pacote está apresentado. Pretendo fazer outros posts com estudos de casos mais específicos, portanto vou deixar apenas um gráfico que resume a consulta que acabamos de fazer.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;consulta %&amp;gt;%
  mutate(ano = fct_relevel(ano, &amp;quot;0 km&amp;quot;, after = Inf)) %&amp;gt;% 
  ggplot(aes(ref, valor, color =  ano, group = ano)) +
    geom_line(color = &amp;quot;grey30&amp;quot;) +
    geom_point(size = 3) +
    facet_wrap(~modelo) +
    labs(
      x = &amp;quot;Mês de refêrencia&amp;quot;,
      y = &amp;quot;Valor (R$)&amp;quot;,
      color = &amp;quot;Ano do \nmodelo&amp;quot;
    ) +
    scale_y_continuous(breaks = seq(0, 700000, 50000), labels = scales::dollar_format(prefix = NULL, big.mark = &amp;quot;.&amp;quot;)) +
    scale_x_date(date_breaks = &amp;quot;1 year&amp;quot;, date_labels = &amp;quot;%b/%y&amp;quot;) +
    scale_color_viridis_d() +
    theme_bw() +
    theme(legend.position = &amp;quot;top&amp;quot;) &lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2017-07-29-como-um-cientista-de-dados-pesquisa-o-carro-que-quer-comprar_files/figure-html/plot_fipe-1.png&#34; width=&#34;4800&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Caso tenha alguma dúvida ou sugestão sobre o post, fique à vontade para fazer um comentário ou me contatar por E-mail.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;devtools::session_info()&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  setting  value                       
##  version  R version 3.3.3 (2017-03-06)
##  system   x86_64, mingw32             
##  ui       RTerm                       
##  language (EN)                        
##  collate  Portuguese_Brazil.1252      
##  tz       America/Sao_Paulo           
##  date     2017-10-14                  
## 
##  package     * version    date       source                            
##  assertthat    0.2.0      2017-04-11 CRAN (R 3.3.3)                    
##  backports     1.1.1      2017-09-25 CRAN (R 3.3.3)                    
##  base        * 3.3.3      2017-03-06 local                             
##  bindr         0.1        2016-11-13 CRAN (R 3.3.3)                    
##  bindrcpp    * 0.2        2017-06-17 CRAN (R 3.3.3)                    
##  blogdown      0.1        2017-08-22 CRAN (R 3.3.3)                    
##  bookdown      0.5        2017-08-20 CRAN (R 3.3.3)                    
##  colorspace    1.3-2      2016-12-14 CRAN (R 3.3.2)                    
##  curl          2.8.1      2017-07-21 CRAN (R 3.3.3)                    
##  datasets    * 3.3.3      2017-03-06 local                             
##  devtools      1.13.3     2017-08-02 CRAN (R 3.3.3)                    
##  digest        0.6.12     2017-01-27 CRAN (R 3.3.2)                    
##  dplyr       * 0.7.4      2017-09-28 CRAN (R 3.3.3)                    
##  evaluate      0.10.1     2017-06-24 CRAN (R 3.3.3)                    
##  fipe        * 0.0.0.9000 2017-07-29 local                             
##  forcats     * 0.2.0      2017-01-23 CRAN (R 3.3.2)                    
##  ggplot2     * 2.2.1.9000 2017-07-15 Github (tidyverse/ggplot2@45853c7)
##  glue          1.1.1      2017-06-21 CRAN (R 3.3.3)                    
##  graphics    * 3.3.3      2017-03-06 local                             
##  grDevices   * 3.3.3      2017-03-06 local                             
##  grid          3.3.3      2017-03-06 local                             
##  gtable        0.2.0      2016-02-26 CRAN (R 3.3.2)                    
##  hms           0.3        2016-11-22 CRAN (R 3.3.2)                    
##  htmltools     0.3.6      2017-04-28 CRAN (R 3.3.3)                    
##  httr          1.3.1      2017-08-20 CRAN (R 3.3.3)                    
##  jsonlite      1.5        2017-06-01 CRAN (R 3.3.3)                    
##  knitr         1.17       2017-08-10 CRAN (R 3.3.3)                    
##  lazyeval      0.2.0      2016-06-12 CRAN (R 3.3.2)                    
##  lubridate     1.6.0      2016-09-13 CRAN (R 3.3.2)                    
##  magrittr      1.5        2014-11-22 CRAN (R 3.3.2)                    
##  memoise       1.1.0      2017-04-21 CRAN (R 3.3.3)                    
##  methods     * 3.3.3      2017-03-06 local                             
##  munsell       0.4.3      2016-02-13 CRAN (R 3.3.2)                    
##  pacman      * 0.4.6      2017-05-14 CRAN (R 3.3.3)                    
##  pkgconfig     2.0.1      2017-03-21 CRAN (R 3.3.3)                    
##  plyr          1.8.4      2016-06-08 CRAN (R 3.3.2)                    
##  purrr       * 0.2.3      2017-08-02 CRAN (R 3.3.3)                    
##  R6            2.2.2      2017-06-17 CRAN (R 3.3.3)                    
##  Rcpp          0.12.13    2017-09-28 CRAN (R 3.3.3)                    
##  readr         1.1.1      2017-05-16 CRAN (R 3.3.3)                    
##  rlang         0.1.2      2017-08-09 CRAN (R 3.3.3)                    
##  rmarkdown     1.6        2017-06-15 CRAN (R 3.3.3)                    
##  rprojroot     1.2        2017-01-16 CRAN (R 3.3.3)                    
##  scales        0.5.0      2017-08-24 CRAN (R 3.3.3)                    
##  stats       * 3.3.3      2017-03-06 local                             
##  stringi       1.1.5      2017-04-07 CRAN (R 3.3.3)                    
##  stringr     * 1.2.0      2017-02-18 CRAN (R 3.3.2)                    
##  tibble        1.3.4      2017-08-22 CRAN (R 3.3.3)                    
##  tidyr       * 0.7.1      2017-09-01 CRAN (R 3.3.3)                    
##  tidyselect    0.2.0      2017-08-30 CRAN (R 3.3.3)                    
##  tools         3.3.3      2017-03-06 local                             
##  utils       * 3.3.3      2017-03-06 local                             
##  viridisLite   0.2.0      2017-03-24 CRAN (R 3.3.3)                    
##  withr         2.0.0      2017-07-28 CRAN (R 3.3.3)                    
##  yaml          2.1.14     2016-11-12 CRAN (R 3.3.3)&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Índice de uniformidade (PV50)</title>
      <link>/indice-de-uniformidade-pv50/</link>
      <pubDate>Sun, 09 Oct 2016 00:00:00 +0000</pubDate>
      
      <guid>/indice-de-uniformidade-pv50/</guid>
      <description>&lt;p&gt;O PV50 é hoje o índice mais utilizado quando queremos expressar a uniformidade de um plantio florestal. &lt;span class=&#34;citation&#34;&gt;Hakamada (&lt;a href=&#34;#ref-Hakamada2012&#34;&gt;2012&lt;/a&gt;)&lt;/span&gt; apresentou um estudo detalhado sobre diversos índices e concluiu que o PV50 é o índice mais indicado para explicar a relação entre uniformidade, qualidade silvicultural e produtividade em plantios homogêneos de &lt;em&gt;Eucalyptus&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;O objetivo deste post é mostrar, passo a passo, como calcular este índice no R e fazer uma breve análise de seus resultados.&lt;/p&gt;
&lt;p&gt;O PV50 é a porcentagem de volume acumulado das 50% menores árvores do seu conjunto de dados, considerando as falhas de plantio e árvores mortas &lt;span class=&#34;citation&#34;&gt;(Hakamada et al. &lt;a href=&#34;#ref-Hakamada2015&#34;&gt;2015&lt;/a&gt;)&lt;/span&gt;. A expressão do índice é dada da seguinte forma:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.sciweavers.org/tex2img.php?eq=PV50%20%3D%20%5Cfrac%7B%5Csum_%7Bk%3D1%7D%5E%7B%5Cfrac%7Bn%7D%7B2%7D%7DV_%7Bij%7D%7D%7B%5Csum_%7Bk%3D1%7D%5E%7Bn%7DV_%7Bij%7D%7D&amp;bc=White&amp;fc=Black&amp;im=jpg&amp;fs=12&amp;ff=arev&amp;edit=0&#34; align=&#34;center&#34; border=&#34;0&#34; alt=&#34;PV50 = \frac{\sum_{k=1}^{\frac{n}{2}}V_{ij}}{\sum_{k=1}^{n}V_{ij}}&#34; width=&#34;139&#34; height=&#34;62&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Onde: PV50 = porcentagem acumulada do volume das 50% menores árvores plantadas; V = volume da árvore i; n = número de árvores plantadas ordenadas (da menor para a maior).&lt;/p&gt;
&lt;p&gt;Primeiro vamos entender os cálculos do índice, considerando apenas 10 árvores hipotéticas com 0,1 metros cúbicos de volume.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# carrega os pacotes necessários
if (!require(&amp;quot;pacman&amp;quot;)) install.packages(&amp;quot;pacman&amp;quot;)
pacman::p_load(readr, dplyr, ggplot2, forcats)&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# exemplo com número par
arv10 &amp;lt;- rep(0.1, 10)
str(arv10)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  num [1:10] 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Este é o referencial teórico de uniformidade, todas as árvores do mesmo tamanho. Sem precisar fazer conta, sabemos que o volume das 50% menores árvores é igual a 50% do volume total, o que equivale a um PV50 = 50.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# identifica a metade do numero de árvores
metade &amp;lt;- length(arv10)/2
metade&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 5&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# soma todas as árvores
soma_todas &amp;lt;- sum(arv10, na.rm = TRUE)
soma_todas&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 1&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# soma o valor de metade das árvores em ordem crescente
soma_metade &amp;lt;- sum(sort(arv10)[1:metade], na.rm = TRUE)
soma_metade&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 0.5&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# calcula o PV50
PV50 &amp;lt;- soma_metade / soma_todas * 100
PV50&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 50&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Agora vamos simular 11 árvores com o mesmo volume, veja o que acontece.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# exemplo com número impar
arv11 &amp;lt;- rep(0.1, 11)
str(arv11)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  num [1:11] 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 ...&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# metade do numero de árvores
metade &amp;lt;- length(arv11)/2
metade&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 5.5&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# soma todas as árvores
soma_todas &amp;lt;- sum(arv11, na.rm = TRUE)
soma_todas&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 1.1&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# soma o valor de metade das árvores em ordem crescente
soma_metade &amp;lt;- sum(sort(arv11)[1:metade], na.rm = TRUE)
soma_metade&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 0.5&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# calcula o PV50
PV50 &amp;lt;- soma_metade / soma_todas * 100
PV50&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 45.45455&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;O resultado deveria ser 50, mas como o número de árvores é impar, o R arredonda a posição 5,5 para 5 e pega até a quinta árvore no momento em que queremos somar as 50% menores. Para contornar isso, vamos calcular a soma das 50% menores árvores de uma forma diferente. Primeiro calculamos a soma acumulada e depois extraímos a média (semelhante ao modo de se calcular uma mediana).&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# vetor de soma acumulada
soma_acumulada &amp;lt;- cumsum(sort(arv11))
soma_acumulada&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  [1] 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0 1.1&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# soma a metade do vetor de soma acumulada
soma_metade &amp;lt;- mean(soma_acumulada[metade + 0L:1L], na.rm = TRUE)
soma_metade&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 0.55&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# calcula o PV50
PV50 &amp;lt;- soma_metade / soma_todas * 100
PV50&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 50&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Agora que a questão do número de árvores foi superada, podemos incluir árvores mortas, o que equivale a elementos do tipo &lt;code&gt;NA&lt;/code&gt; no R. Veja que o resultado não está consistente pois a &lt;code&gt;soma_acumulada&lt;/code&gt; ignorou as árvores mortas.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# exemplo com valores perdidos
arv11_na &amp;lt;- rep(0.1, 11)
arv11_na[c(3,4)] &amp;lt;- NA
str(arv11_na)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  num [1:11] 0.1 0.1 NA NA 0.1 0.1 0.1 0.1 0.1 0.1 ...&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# metade do numero de árvores
metade &amp;lt;- length(arv11_na)/2
metade&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 5.5&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# soma todas as árvores
soma_todas &amp;lt;- sum(arv11_na, na.rm = TRUE)
soma_todas&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 0.9&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# vetor de soma acumulada
soma_acumulada &amp;lt;- cumsum(sort(arv11_na))
soma_acumulada&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# soma a metade do vetor de soma acumulada
soma_metade &amp;lt;- mean(soma_acumulada[metade + 0L:1L], na.rm = TRUE)
soma_metade&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 0.55&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# calcula o PV50
PV50 &amp;lt;- soma_metade / soma_todas * 100
PV50&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 61.11111&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Para corrigir este o erro, temos de incluir manualmente as árvores mortas na sequência. Veja que agora o resultado está de acordo com o esperado.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# vetor de valores perdidos
mortas &amp;lt;- arv11_na[is.na(arv11_na)]
mortas&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] NA NA&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# metade do numero de árvores
metade &amp;lt;- length(arv11_na)/2
metade&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 5.5&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# soma todas as árvores
soma_todas &amp;lt;- sum(arv11_na, na.rm = TRUE)
soma_todas&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 0.9&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# vetor de soma acumulada com valores perdidos
soma_acumulada &amp;lt;- c(mortas, cumsum(sort(arv11_na)))
soma_acumulada&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  [1]  NA  NA 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# soma a metade do vetor de soma acumulada
soma_metade &amp;lt;- mean(soma_acumulada[metade + 0L:1L], na.rm = TRUE)
soma_metade&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 0.35&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# calcula o PV50
PV50 &amp;lt;- soma_metade / soma_todas * 100
PV50&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 38.88889&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Agora eu vou dar aquele passo mágico dos livros de matemática e física, em que o autor diz “é fácil notar que o resultado leva a …” e apresentar uma função que lida com as questões que mostramos acima e retorna o PV50 do nosso conjunto de dados de forma correta.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;pv50 &amp;lt;- function(x) {
  
  mortas &amp;lt;- x[is.na(x)]
  
  metade &amp;lt;- length(x)/2
  
  soma_todas &amp;lt;- sum(x, na.rm = TRUE)
  
  soma_acumulada &amp;lt;- c(mortas, cumsum(sort(x)))
  
  if (metade%%2L == 1L)
    soma_metade &amp;lt;- mean(soma_acumulada[metade], na.rm = TRUE)
  else
    soma_metade &amp;lt;- mean(soma_acumulada[metade + 0L:1L], na.rm = TRUE)
  
  z &amp;lt;- soma_metade / soma_todas * 100
  
  return(z)
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Podemos rapidamente verificar se os resultados estão consistentes fazendo alguns testes.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;a &amp;lt;- rep(10, 10)
str(a)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  num [1:10] 10 10 10 10 10 10 10 10 10 10&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;pv50(a) # Ok!&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 50&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;a1 &amp;lt;- rep(10 ,11)
str(a1)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  num [1:11] 10 10 10 10 10 10 10 10 10 10 ...&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;pv50(a1) # Ok!&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 50&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;b &amp;lt;- a
b[c(3, 7)] &amp;lt;- NA
str(b)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  num [1:10] 10 10 NA 10 10 10 NA 10 10 10&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;pv50(b) # Ok!&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 37.5&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;b1 &amp;lt;- a1
b1[c(3, 7)] &amp;lt;- NA
str(b1)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  num [1:11] 10 10 NA 10 10 10 NA 10 10 10 ...&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;pv50(b1) # Ok!&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 38.88889&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Boa, já temos uma função para calcular o PV50 e podemos aplicá-la em um conjunto de dados para podermos interpretar. Utilizaremos mais uma vez os dados do &lt;a href=&#34;www.projetotume.com&#34;&gt;Projeto TUME&lt;/a&gt;, referente ao &lt;a href=&#34;http://www.projetotume.com/tume134&#34;&gt;TUME 134&lt;/a&gt; plantado em Piracicaba-SP. O volume individual foi calculado arbitrariamente utilizando o fator de forma 0,5.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# importa o arquivo tume_55.csv
dados &amp;lt;- read_csv2(
  &amp;quot;https://github.com/italocegatta/italocegatta.github.io_source/raw/master/content/dados/tume_55.csv&amp;quot;
)

glimpse(dados)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Observations: 1,222
## Variables: 7
## $ Esp     &amp;lt;chr&amp;gt; &amp;quot;E_camaldulensis&amp;quot;, &amp;quot;E_camaldulensis&amp;quot;, &amp;quot;E_camaldulensis...
## $ I_meses &amp;lt;int&amp;gt; 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34...
## $ Parc_m2 &amp;lt;int&amp;gt; 288, 288, 288, 288, 288, 288, 288, 288, 288, 288, 288,...
## $ N_arv   &amp;lt;int&amp;gt; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16,...
## $ DAP_cm  &amp;lt;dbl&amp;gt; 5.411268, 12.254931, 3.978874, 6.429860, 9.676621, 5.6...
## $ H_m     &amp;lt;dbl&amp;gt; 7.651490, 11.424046, 5.909205, 8.572873, 10.498957, 7....
## $ Vol     &amp;lt;dbl&amp;gt; 0.008798406, 0.067375427, 0.003673747, 0.013918399, 0....&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Iremos calcular o PV50 e o volume por hectare para cada fator &lt;code&gt;Esp&lt;/code&gt; e &lt;code&gt;I_meses&lt;/code&gt; e em seguida ordenar as espécies pelo PV50.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# agrupa os dados em função de espécie e idade para 
# calcular o pv50 e o volume
dados_pv50 &amp;lt;- dados %&amp;gt;% 
  group_by(Esp, I_meses) %&amp;gt;% 
  summarise(
    Parc_m2 = mean( Parc_m2),
    PV50 = pv50(Vol),
    Vol_ha = sum(Vol, na.rm = TRUE) * (10000/Parc_m2)
  ) %&amp;gt;%
  ungroup() %&amp;gt;% 
  # ordena o fator de espécies de forma decrescente em função do pv50
  mutate(Esp = fct_reorder(Esp, -PV50))

dados_pv50&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 20 x 5
##                    Esp I_meses Parc_m2     PV50    Vol_ha
##                 &amp;lt;fctr&amp;gt;   &amp;lt;int&amp;gt;   &amp;lt;dbl&amp;gt;    &amp;lt;dbl&amp;gt;     &amp;lt;dbl&amp;gt;
##  1     E_camaldulensis      34     288 21.36325  47.50044
##  2     E_camaldulensis      46     288 14.26669  79.09417
##  3     E_camaldulensis      60     600 13.18344 110.06612
##  4     E_camaldulensis      85     288 12.70684 203.98374
##  5        E_citriodora      34     288 17.84086  46.56646
##  6        E_citriodora      46     288 16.43760  84.96252
##  7        E_citriodora      60     600 12.53474  97.00958
##  8        E_citriodora      85     288 12.73166 205.04360
##  9            E_dunnii      34     288 28.58694 103.36725
## 10            E_dunnii      46     288 29.21288 160.54057
## 11            E_dunnii      60     600 27.46026 198.47239
## 12            E_dunnii      85     288 26.39616 349.63571
## 13        E_paniculata      34     288 27.36895  46.43145
## 14        E_paniculata      46     288 24.13274  84.42312
## 15        E_paniculata      60     600 19.63065 114.81369
## 16        E_paniculata      85     288 18.21965 194.87958
## 17 E_urophylla_grandis      34     288 26.25100  85.67855
## 18 E_urophylla_grandis      46     288 24.20636 157.30295
## 19 E_urophylla_grandis      60     600 20.33734 217.30209
## 20 E_urophylla_grandis      85     288 17.89856 277.37748&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Para entendermos os dados, vamos primeiro ver o crescimento em volume de cada espécies em função do tempo (Figura &lt;a href=&#34;#fig:12-vol-idade&#34;&gt;1&lt;/a&gt;). Note que &lt;em&gt;E. dunnii&lt;/em&gt; e &lt;em&gt;E. urophylla&lt;/em&gt; x &lt;em&gt;E. grandis&lt;/em&gt; tinham crescimento muito parecido até os 60 meses de idade.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggplot(dados_pv50, aes(I_meses, Vol_ha, color = Esp)) +
  geom_point() +
  geom_line() +
  labs(
    color = &amp;quot;Espécies&amp;quot;,
    x = &amp;quot;Idade (meses)&amp;quot;,
    y = Volume~m^3~ha^-1
  ) +
  scale_color_brewer(palette = &amp;quot;Set1&amp;quot;) +
  theme_bw(base_size = 16) +
  theme(legend.justification = &amp;quot;top&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;figure&#34;&gt;&lt;span id=&#34;fig:12-vol-idade&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;/post/2016-10-09-indice-de-uniformidade-pv50_files/figure-html/12-vol-idade-1.png&#34; alt=&#34;Crescimento em volume por hectare em função da idade.&#34; width=&#34;4000&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figura  1: Crescimento em volume por hectare em função da idade.
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Agora podemos construir um gráfico que relaciona o PV50 e a idade (Figura &lt;a href=&#34;#fig:12-pv50-idade&#34;&gt;2&lt;/a&gt;). A interpretação do índice é simples, o PV50 representa a porcentagem em volume que as 50% menores árvores contribuem para o volume total. Em nossos dados, &lt;em&gt;E. dunnii&lt;/em&gt;, ao 85 meses de idade, tem um PV50 de aproximadamente 26. Isso quer dizer que aos 7 anos, as 50% menores árvores da parcela de &lt;em&gt;E. dunnii&lt;/em&gt; representam apenas 26% do volume total. Ou seja, 50% das árvores contribuem muito pouco para o volume total da parcela e isso tem um impacto direto na produtividade.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggplot(dados_pv50, aes(I_meses, PV50, color = Esp)) +
  geom_point() +
  geom_line() +
  labs(color = &amp;quot;Espécies&amp;quot;, x = &amp;quot;Idade (meses)&amp;quot;, y = &amp;quot;PV50&amp;quot;) +
  scale_color_brewer(palette = &amp;quot;Set1&amp;quot;) +
  scale_y_continuous(breaks = seq(10, 30, 2)) +
  theme_bw(base_size = 16) +
  theme(legend.justification = &amp;quot;top&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;figure&#34;&gt;&lt;span id=&#34;fig:12-pv50-idade&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;/post/2016-10-09-indice-de-uniformidade-pv50_files/figure-html/12-pv50-idade-1.png&#34; alt=&#34;Variação do PV50 por espécies em função da idade.&#34; width=&#34;4000&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figura  2: Variação do PV50 por espécies em função da idade.
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;A Figura &lt;a href=&#34;#fig:12-pv50-vol&#34;&gt;3&lt;/a&gt; mostra claramente a relação direta que há entre produção de madeira e a uniformidade ao longo do crescimento da floresta. Note também que na medida em que a idade avança, a uniformidade diminui, pois a dominância das árvores maiores sobre as menores fica cada vez mais forte.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggplot(dados_pv50, aes(Vol_ha, PV50)) +
  geom_point(aes(color = factor(I_meses))) +
  geom_smooth(method = &amp;quot;lm&amp;quot;, formula = y ~x, se = FALSE) +
  facet_wrap(~Esp, dir = &amp;quot;v&amp;quot;) +
  labs(color = &amp;quot;Idade (meses)&amp;quot;, x = Volume~m^3~ha^-1, y = &amp;quot;PV50&amp;quot;) +
  scale_color_brewer(palette = &amp;quot;Dark2&amp;quot;) +
  theme_bw(base_size = 16) +
  theme(legend.justification = &amp;quot;top&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;figure&#34;&gt;&lt;span id=&#34;fig:12-pv50-vol&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;/post/2016-10-09-indice-de-uniformidade-pv50_files/figure-html/12-pv50-vol-1.png&#34; alt=&#34;Relação entre o PV50 e volume por hectare em função da idade.&#34; width=&#34;4000&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figura  3: Relação entre o PV50 e volume por hectare em função da idade.
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Por fim, para colocar tudo em um só gráfico, podemos adicionar ao gráfico de crescimento em volume a informação do PV50 para evidenciar que as espécies mais produtivas tem PV50 elevado e que este índice consegue explicar muito bem essa relação (Figura &lt;a href=&#34;#fig:12-vol-pv50-idade&#34;&gt;4&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;Um comentário interessante é que dentre as espécies que estamos estudando, todas são de origem seminal, com exceção do &lt;em&gt;E. dunnii&lt;/em&gt;, que é um clone. Este fator explica sua produtividade e alta homogeneidade, principalmente frente ao hibrido de &lt;em&gt;E. urophylla&lt;/em&gt; x &lt;em&gt;E. grandis&lt;/em&gt;, que é seu concorrente direto. Quando estivermos analisando dados de plantios clonais, o PV50 vai expressar a qualidade silvicultural do plantio, uma vez que a base genética é a mesma em todas as plantas.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggplot(dados_pv50, aes(I_meses, Vol_ha, color = Esp)) +
  geom_point(aes(size = PV50), alpha = 0.4) +
  geom_line() +
  labs(
    color = &amp;quot;Espécies&amp;quot;,
    x = &amp;quot;Idade (meses)&amp;quot;,
    y = Volume~m^3~ha^-1
  ) +
  scale_color_brewer(palette = &amp;quot;Set1&amp;quot;) +
  theme_bw(base_size = 16) +
  theme(legend.justification = &amp;quot;top&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;figure&#34;&gt;&lt;span id=&#34;fig:12-vol-pv50-idade&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;/post/2016-10-09-indice-de-uniformidade-pv50_files/figure-html/12-vol-pv50-idade-1.png&#34; alt=&#34;Crescimento do volume em função da idade, com informação do PV50 no tamanho do ponto.&#34; width=&#34;4000&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figura  4: Crescimento do volume em função da idade, com informação do PV50 no tamanho do ponto.
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Caso tenha alguma dúvida ou sugestão sobre o post, fique à vontade para fazer um comentário ou me contatar por E-mail.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;devtools::session_info()&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  setting  value                       
##  version  R version 3.3.3 (2017-03-06)
##  system   x86_64, mingw32             
##  ui       RTerm                       
##  language (EN)                        
##  collate  Portuguese_Brazil.1252      
##  tz       America/Sao_Paulo           
##  date     2017-10-14                  
## 
##  package      * version    date       source                            
##  assertthat     0.2.0      2017-04-11 CRAN (R 3.3.3)                    
##  backports      1.1.1      2017-09-25 CRAN (R 3.3.3)                    
##  base         * 3.3.3      2017-03-06 local                             
##  bindr          0.1        2016-11-13 CRAN (R 3.3.3)                    
##  bindrcpp     * 0.2        2017-06-17 CRAN (R 3.3.3)                    
##  blogdown       0.1        2017-08-22 CRAN (R 3.3.3)                    
##  bookdown       0.5        2017-08-20 CRAN (R 3.3.3)                    
##  colorspace     1.3-2      2016-12-14 CRAN (R 3.3.2)                    
##  curl           2.8.1      2017-07-21 CRAN (R 3.3.3)                    
##  datasets     * 3.3.3      2017-03-06 local                             
##  devtools       1.13.3     2017-08-02 CRAN (R 3.3.3)                    
##  digest         0.6.12     2017-01-27 CRAN (R 3.3.2)                    
##  dplyr        * 0.7.4      2017-09-28 CRAN (R 3.3.3)                    
##  evaluate       0.10.1     2017-06-24 CRAN (R 3.3.3)                    
##  forcats      * 0.2.0      2017-01-23 CRAN (R 3.3.2)                    
##  ggplot2      * 2.2.1.9000 2017-07-15 Github (tidyverse/ggplot2@45853c7)
##  glue           1.1.1      2017-06-21 CRAN (R 3.3.3)                    
##  graphics     * 3.3.3      2017-03-06 local                             
##  grDevices    * 3.3.3      2017-03-06 local                             
##  grid           3.3.3      2017-03-06 local                             
##  gtable         0.2.0      2016-02-26 CRAN (R 3.3.2)                    
##  highr          0.6        2016-05-09 CRAN (R 3.3.3)                    
##  hms            0.3        2016-11-22 CRAN (R 3.3.2)                    
##  htmltools      0.3.6      2017-04-28 CRAN (R 3.3.3)                    
##  knitr          1.17       2017-08-10 CRAN (R 3.3.3)                    
##  labeling       0.3        2014-08-23 CRAN (R 3.3.2)                    
##  lazyeval       0.2.0      2016-06-12 CRAN (R 3.3.2)                    
##  magrittr       1.5        2014-11-22 CRAN (R 3.3.2)                    
##  memoise        1.1.0      2017-04-21 CRAN (R 3.3.3)                    
##  methods      * 3.3.3      2017-03-06 local                             
##  munsell        0.4.3      2016-02-13 CRAN (R 3.3.2)                    
##  pacman       * 0.4.6      2017-05-14 CRAN (R 3.3.3)                    
##  pkgconfig      2.0.1      2017-03-21 CRAN (R 3.3.3)                    
##  plyr           1.8.4      2016-06-08 CRAN (R 3.3.2)                    
##  R6             2.2.2      2017-06-17 CRAN (R 3.3.3)                    
##  RColorBrewer   1.1-2      2014-12-07 CRAN (R 3.3.2)                    
##  Rcpp           0.12.13    2017-09-28 CRAN (R 3.3.3)                    
##  readr        * 1.1.1      2017-05-16 CRAN (R 3.3.3)                    
##  rlang          0.1.2      2017-08-09 CRAN (R 3.3.3)                    
##  rmarkdown      1.6        2017-06-15 CRAN (R 3.3.3)                    
##  rprojroot      1.2        2017-01-16 CRAN (R 3.3.3)                    
##  scales         0.5.0      2017-08-24 CRAN (R 3.3.3)                    
##  stats        * 3.3.3      2017-03-06 local                             
##  stringi        1.1.5      2017-04-07 CRAN (R 3.3.3)                    
##  stringr        1.2.0      2017-02-18 CRAN (R 3.3.2)                    
##  tibble         1.3.4      2017-08-22 CRAN (R 3.3.3)                    
##  tools          3.3.3      2017-03-06 local                             
##  utils        * 3.3.3      2017-03-06 local                             
##  withr          2.0.0      2017-07-28 CRAN (R 3.3.3)                    
##  yaml           2.1.14     2016-11-12 CRAN (R 3.3.3)&lt;/code&gt;&lt;/pre&gt;
&lt;div id=&#34;referencias&#34; class=&#34;section level1 unnumbered&#34;&gt;
&lt;h1&gt;Referências&lt;/h1&gt;
&lt;div id=&#34;refs&#34; class=&#34;references&#34;&gt;
&lt;div id=&#34;ref-Hakamada2012&#34;&gt;
&lt;p&gt;Hakamada, Rodrigo Eiji. 2012. “Uso do inventário florestal como ferramenta de monitoramento da qualidade silvicultura em povoamentos clonais de Eucalyptus.” PhD thesis, Piracicaba: Universidade de São Paulo; Biblioteca Digital de Teses e Dissertações da Universidade de São Paulo. doi:&lt;a href=&#34;https://doi.org/10.11606/D.11.2012.tde-05072012-100431&#34;&gt;10.11606/D.11.2012.tde-05072012-100431&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;ref-Hakamada2015&#34;&gt;
&lt;p&gt;Hakamada, Rodrigo Eiji, José Luiz Stape, Cristiane Camargo Zani de Lemos, Adriano Emanuel Amaral Almeida, and Luis Fernando Silva. 2015. “Uniformidade entre árvores durante uma rotação e sua relação com a produtividade em Eucalyptus clonais.” &lt;em&gt;CERNE&lt;/em&gt; 21 (3). Universidade Federal de Lavras: 465–72. doi:&lt;a href=&#34;https://doi.org/10.1590/01047760201521031716&#34;&gt;10.1590/01047760201521031716&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
    </item>
    
  </channel>
</rss>