<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Posts on Italo Cegatta</title>
    <link>https://italocegatta.github.io/post/</link>
    <description>Recent content in Posts on Italo Cegatta</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>pt-br</language>
    <lastBuildDate>Tue, 01 Jan 2019 00:00:00 +0000</lastBuildDate>
    
        <atom:link href="https://italocegatta.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>O quão popular é o seu nome?</title>
      <link>https://italocegatta.github.io/o-quao-popular-e-o-seu-nome/</link>
      <pubDate>Tue, 01 Jan 2019 00:00:00 +0000</pubDate>
      
      <guid>https://italocegatta.github.io/o-quao-popular-e-o-seu-nome/</guid>
      <description>No Censo 2010, o IBGE incorporou no levantamento a coleta de nomes (apenas o primeiro) e sobrenome (apenas o último). Para quem é curioso por coisas sem muita utilidade prática (e eu jogo forte nesse time!), vale a pena entrar no site https://censo2010.ibge.gov.br/nomes e conferir as estatísticas do nome de interesse.
O site é legal, mas eu queria ter os dados na mão para fazer as coisas do meu jeito.</description>
      <content:encoded>
        


&lt;p&gt;No Censo 2010, o IBGE incorporou no levantamento a coleta de nomes (apenas o primeiro) e sobrenome (apenas o último). Para quem é curioso por coisas sem muita utilidade prática (e eu jogo forte nesse time!), vale a pena entrar no site &lt;a href=&#34;https://censo2010.ibge.gov.br/nomes&#34;&gt;https://censo2010.ibge.gov.br/nomes&lt;/a&gt; e conferir as estatísticas do nome de interesse.&lt;/p&gt;
&lt;p&gt;O site é legal, mas eu queria ter os dados na mão para fazer as coisas do meu jeito. Então decidi escrever um pacote no R para acessar os dados da &lt;a href=&#34;https://servicodados.ibge.gov.br/api/docs/censos/nomes?versao=2&#34;&gt;API&lt;/a&gt; que o IBGE montou para esse banco.&lt;/p&gt;
&lt;p&gt;O pacote chama &lt;code&gt;brnome&lt;/code&gt; e está disponível no meu &lt;a href=&#34;https://github.com/italocegatta/brnome&#34;&gt;Github&lt;/a&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;if (!require(&amp;quot;pacman&amp;quot;)) install.packages(&amp;quot;pacman&amp;quot;)
pacman::p_load(readr, dplyr, purrr, tidyr, ggplot2, forcats, wordcloud)
pacman::p_load_gh(&amp;quot;italocegatta/brnome&amp;quot;)
pacman::p_load_gh(&amp;quot;italocegatta/brmap&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Vamos começar com a função &lt;code&gt;brnome_freq()&lt;/code&gt; e entender a distribuição espacial e temporal (década de nascimento) do nome da minha queria e sapeca sobrinha, Eliza.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;eliza_freq &amp;lt;- brnome_freq(nome = &amp;quot;eliza&amp;quot;)

eliza_freq&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 9 x 7
##   nome  sexo  localidade_cod localidade_nome nascimento_peri~
##   &amp;lt;chr&amp;gt; &amp;lt;lgl&amp;gt; &amp;lt;chr&amp;gt;          &amp;lt;chr&amp;gt;           &amp;lt;chr&amp;gt;           
## 1 ELIZA NA    BR             Brasil          [    , 1930]    
## 2 ELIZA NA    BR             Brasil          [1930, 1940]    
## 3 ELIZA NA    BR             Brasil          [1940, 1950]    
## 4 ELIZA NA    BR             Brasil          [1950, 1960]    
## 5 ELIZA NA    BR             Brasil          [1960, 1970]    
## 6 ELIZA NA    BR             Brasil          [1970, 1980]    
## 7 ELIZA NA    BR             Brasil          [1980, 1990]    
## 8 ELIZA NA    BR             Brasil          [1990, 2000]    
## 9 ELIZA NA    BR             Brasil          [2000, 2010]    
## # ... with 2 more variables: nascimento_decada &amp;lt;int&amp;gt;, frequencia &amp;lt;int&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Notem que as colunas &lt;code&gt;sexo&lt;/code&gt; e &lt;code&gt;localidade&lt;/code&gt; estão vazias pois não foram especificadas. Significa que foi considerada a busca de homens e mulheres para todo o Brasil.&lt;/p&gt;
&lt;p&gt;Será que tem algum homem batizado com o nome Eliza? Tem, e eu não sei se foi de propósito ou se foi um erro de coleta. Fica aí o questionamento hehehehe.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;brnome_freq(nome = &amp;quot;eliza&amp;quot;, sexo = &amp;quot;m&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 9 x 7
##   nome  sexo  localidade_cod localidade_nome nascimento_peri~
##   &amp;lt;chr&amp;gt; &amp;lt;chr&amp;gt; &amp;lt;chr&amp;gt;          &amp;lt;chr&amp;gt;           &amp;lt;chr&amp;gt;           
## 1 ELIZA M     BR             Brasil          [    , 1930]    
## 2 ELIZA M     BR             Brasil          [1930, 1940]    
## 3 ELIZA M     BR             Brasil          [1940, 1950]    
## 4 ELIZA M     BR             Brasil          [1950, 1960]    
## 5 ELIZA M     BR             Brasil          [1960, 1970]    
## 6 ELIZA M     BR             Brasil          [1970, 1980]    
## 7 ELIZA M     BR             Brasil          [1980, 1990]    
## 8 ELIZA M     BR             Brasil          [1990, 2000]    
## 9 ELIZA M     BR             Brasil          [2000, 2010]    
## # ... with 2 more variables: nascimento_decada &amp;lt;int&amp;gt;, frequencia &amp;lt;int&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A pesquisa também pode ser feita para um determinado município ou estado. Neste caso, você precisa utilizar o código oficial do IBGE de localidades. Como exemplo, vamos ver os resultados para Cuiabá (&lt;code&gt;5103403&lt;/code&gt;) e Mato Grosso (&lt;code&gt;51&lt;/code&gt;).&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;brnome_freq(nome = &amp;quot;eliza&amp;quot;, localidade_cod = 5103403)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 7 x 7
##   nome  sexo  localidade_cod localidade_nome nascimento_peri~
##   &amp;lt;chr&amp;gt; &amp;lt;lgl&amp;gt;          &amp;lt;int&amp;gt; &amp;lt;chr&amp;gt;           &amp;lt;chr&amp;gt;           
## 1 ELIZA NA           5103403 Cuiabá          [1940, 1950]    
## 2 ELIZA NA           5103403 Cuiabá          [1950, 1960]    
## 3 ELIZA NA           5103403 Cuiabá          [1960, 1970]    
## 4 ELIZA NA           5103403 Cuiabá          [1970, 1980]    
## 5 ELIZA NA           5103403 Cuiabá          [1980, 1990]    
## 6 ELIZA NA           5103403 Cuiabá          [1990, 2000]    
## 7 ELIZA NA           5103403 Cuiabá          [2000, 2010]    
## # ... with 2 more variables: nascimento_decada &amp;lt;int&amp;gt;, frequencia &amp;lt;int&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;brnome_freq(nome = &amp;quot;eliza&amp;quot;, localidade_cod = 51)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 9 x 7
##   nome  sexo  localidade_cod localidade_nome nascimento_peri~
##   &amp;lt;chr&amp;gt; &amp;lt;lgl&amp;gt;          &amp;lt;int&amp;gt; &amp;lt;chr&amp;gt;           &amp;lt;chr&amp;gt;           
## 1 ELIZA NA                51 Mato Grosso     [    , 1930]    
## 2 ELIZA NA                51 Mato Grosso     [1930, 1940]    
## 3 ELIZA NA                51 Mato Grosso     [1940, 1950]    
## 4 ELIZA NA                51 Mato Grosso     [1950, 1960]    
## 5 ELIZA NA                51 Mato Grosso     [1960, 1970]    
## 6 ELIZA NA                51 Mato Grosso     [1970, 1980]    
## 7 ELIZA NA                51 Mato Grosso     [1980, 1990]    
## 8 ELIZA NA                51 Mato Grosso     [1990, 2000]    
## 9 ELIZA NA                51 Mato Grosso     [2000, 2010]    
## # ... with 2 more variables: nascimento_decada &amp;lt;int&amp;gt;, frequencia &amp;lt;int&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Para consultar os códigos das localidades, o pacote disponibiliza um dataframe auxiliar &lt;code&gt;localidades&lt;/code&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;localidades&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 5,597 x 3
##    localidade localidade_nome       tipo     
##    &amp;lt;chr&amp;gt;      &amp;lt;chr&amp;gt;                 &amp;lt;chr&amp;gt;    
##  1 1100015    Alta Floresta D&amp;#39;Oeste Município
##  2 1100023    Ariquemes             Município
##  3 1100031    Cabixi                Município
##  4 1100049    Cacoal                Município
##  5 1100056    Cerejeiras            Município
##  6 1100064    Colorado do Oeste     Município
##  7 1100072    Corumbiara            Município
##  8 1100080    Costa Marques         Município
##  9 1100098    Espigão D&amp;#39;Oeste       Município
## 10 1100106    Guajará-Mirim         Município
## # ... with 5,587 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Bom, consultas simples como está podem ser feitas diretamente pelo site do IBGE, mas podemos deixar um pouco mais complexo e pegar a frequência do nome Eliza para todos os estados do Brasil.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;eliza_estado &amp;lt;- localidades %&amp;gt;% 
  filter(tipo == &amp;quot;Estado&amp;quot;) %&amp;gt;% 
  mutate(
    freq = map(
      localidade,
      ~brnome_freq(nome = &amp;quot;Eliza&amp;quot;, localidade_cod = .x) 
    )
  ) %&amp;gt;% 
  select(freq) %&amp;gt;% 
  unnest()

eliza_estado&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 218 x 7
##    nome  sexo  localidade_cod localidade_nome nascimento_peri~
##    &amp;lt;chr&amp;gt; &amp;lt;lgl&amp;gt;          &amp;lt;int&amp;gt; &amp;lt;chr&amp;gt;           &amp;lt;chr&amp;gt;           
##  1 ELIZA NA                11 Rondônia        [1940, 1950]    
##  2 ELIZA NA                11 Rondônia        [1950, 1960]    
##  3 ELIZA NA                11 Rondônia        [1960, 1970]    
##  4 ELIZA NA                11 Rondônia        [1970, 1980]    
##  5 ELIZA NA                11 Rondônia        [1980, 1990]    
##  6 ELIZA NA                11 Rondônia        [1990, 2000]    
##  7 ELIZA NA                11 Rondônia        [2000, 2010]    
##  8 ELIZA NA                12 Acre            [1940, 1950]    
##  9 ELIZA NA                12 Acre            [1960, 1970]    
## 10 ELIZA NA                12 Acre            [1970, 1980]    
## # ... with 208 more rows, and 2 more variables: nascimento_decada &amp;lt;int&amp;gt;,
## #   frequencia &amp;lt;int&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Primeiro vamos analisar a frequência do nome pela década de nascimento somando os valores de todos os estados.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;eliza_estado %&amp;gt;% 
  group_by(nascimento_decada) %&amp;gt;% 
  summarise(frequencia = sum(frequencia)) %&amp;gt;% 
  ggplot(aes(nascimento_decada, frequencia)) +
    geom_line(size = 1) +
    geom_point(shape = 21, color = &amp;quot;white&amp;quot;, fill =  &amp;quot;#80b1d3&amp;quot;, size = 7, stroke = 2) +
    labs(x = &amp;quot;Década de nascimento&amp;quot;, y = &amp;quot;Frequência do nome Eliza&amp;quot;) +
    scale_x_continuous(breaks = seq(1900, 2020, 10)) + 
    scale_y_continuous(limits = c(0, NA), labels = scales::unit_format(unit = &amp;quot;k&amp;quot;, scale = 1e-3)) + 
    theme_bw(16)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://italocegatta.github.io/post/2019-01-01-o-quao-popular-e-o-seu-nome_files/figure-html/unnamed-chunk-8-1.svg&#34; width=&#34;960&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Também podemos ver a distribuição espacial pelos estados do Brasil.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;eliza_estado %&amp;gt;% 
  left_join(brmap_estado_simples, by = c(&amp;quot;localidade_nome&amp;quot; = &amp;quot;estado_nome&amp;quot;)) %&amp;gt;% 
  st_as_sf() %&amp;gt;% 
  ggplot(aes(fill = frequencia)) +
    geom_sf(color = &amp;quot;white&amp;quot;) +
    scale_fill_distiller(palette = &amp;quot;Purples&amp;quot;, direction = 1) +
    labs(fill = &amp;quot;Frequência do nome Eliza&amp;quot;) +
    theme_bw(16) +
    theme(legend.position = &amp;quot;bottom&amp;quot;, legend.justification = &amp;quot;right&amp;quot;) +
    guides(fill = guide_colorbar(barwidth = 15, title.position = &amp;quot;top&amp;quot;))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://italocegatta.github.io/post/2019-01-01-o-quao-popular-e-o-seu-nome_files/figure-html/unnamed-chunk-9-1.png&#34; width=&#34;960&#34; /&gt;&lt;/p&gt;
&lt;p&gt;A segunda função presente no pacote acessa o rank dos nomes mais populares por sexo, década de nascimento e localidade.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;rank_decada &amp;lt;- map_dfr(seq(1930, 2000, 10), ~brnome_rank(decada = .x))

rank_decada %&amp;gt;%
  ggplot(aes(decada, ranking, fill = frequencia, label = nome)) +
  geom_line(aes(group = nome), alpha = 0.5) +
  geom_label(color = &amp;quot;black&amp;quot;, size = 3) +
  #facet_wrap(~sexo, labeller = labeller(sexo = c(&amp;quot;F&amp;quot; = &amp;quot;Feminino&amp;quot;, &amp;quot;M&amp;quot; = &amp;quot;Masculino&amp;quot;))) +
  labs(x = &amp;quot;Décade de nascimento&amp;quot;, y = &amp;quot;Ranking&amp;quot;, fill = &amp;quot;Frequência&amp;quot;) +
  scale_x_continuous(breaks = seq(1930, 2000, 10)) +
  scale_y_reverse(breaks = 1:20) +
  scale_fill_distiller(
    palette = &amp;quot;PuBuGn&amp;quot;, direction = 1, 
    labels = scales::unit_format(unit = &amp;quot;k&amp;quot;, scale = 1e-3)
  ) +
  theme_bw() +
  theme(legend.position = &amp;quot;bottom&amp;quot;, legend.justification = &amp;quot;right&amp;quot;) +
  guides(fill = guide_colorbar(barwidth = 20, title.position = &amp;quot;top&amp;quot;))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://italocegatta.github.io/post/2019-01-01-o-quao-popular-e-o-seu-nome_files/figure-html/unnamed-chunk-10-1.svg&#34; width=&#34;960&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Para finalizar, vamos fazer um gráfico com os nomes mais frequentes em forma de nuvem de palavras.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;top_nomes &amp;lt;- bind_rows(
  brnome_rank(sexo = &amp;quot;f&amp;quot;),
  brnome_rank(sexo = &amp;quot;m&amp;quot;)
)
  
set.seed(1)
wordcloud(top_nomes$nome, top_nomes$frequencia, scale=c(8, 1))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://italocegatta.github.io/post/2019-01-01-o-quao-popular-e-o-seu-nome_files/figure-html/unnamed-chunk-11-1.svg&#34; width=&#34;960&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Caso tenha alguma dúvida ou sugestão sobre o post, fique à vontade para fazer um comentário ou me contatar por E-mail.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;sessioninfo::session_info(c(&amp;quot;readr&amp;quot;, &amp;quot;dplyr&amp;quot;, &amp;quot;purrr&amp;quot;, &amp;quot;tidyr&amp;quot;, &amp;quot;ggplot2&amp;quot;, &amp;quot;forcats&amp;quot;, &amp;quot;brmap&amp;quot;, &amp;quot;brnome&amp;quot;, &amp;quot;wordcloud&amp;quot;))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## - Session info ----------------------------------------------------------
##  setting  value                       
##  version  R version 3.5.3 (2019-03-11)
##  os       Windows 10 x64              
##  system   x86_64, mingw32             
##  ui       RTerm                       
##  language (EN)                        
##  collate  Portuguese_Brazil.1252      
##  ctype    Portuguese_Brazil.1252      
##  tz       America/Sao_Paulo           
##  date     2019-08-25                  
## 
## - Packages --------------------------------------------------------------
##  package      * version    date       lib
##  askpass        1.1        2019-01-13 [1]
##  assertthat     0.2.1      2019-03-21 [1]
##  backports      1.1.4      2019-04-10 [1]
##  BH             1.69.0-1   2019-01-07 [1]
##  brmap        * 0.1.0      2019-03-04 [1]
##  brnome       * 0.0.0.9000 2019-07-08 [1]
##  class          7.3-15     2019-01-01 [2]
##  classInt       0.4-1      2019-08-06 [1]
##  cli            1.1.0      2019-03-19 [1]
##  clipr          0.7.0      2019-07-23 [1]
##  colorspace     1.4-1      2019-03-18 [1]
##  crayon         1.3.4      2017-09-16 [1]
##  curl           4.0        2019-07-22 [1]
##  DBI            1.0.0      2018-05-02 [1]
##  digest         0.6.20     2019-07-04 [1]
##  dplyr        * 0.8.3      2019-07-04 [1]
##  e1071          1.7-2      2019-06-05 [1]
##  ellipsis       0.2.0.1    2019-07-02 [1]
##  fansi          0.4.0      2018-10-05 [1]
##  forcats      * 0.4.0      2019-02-17 [1]
##  ggplot2      * 3.2.1      2019-08-10 [1]
##  glue           1.3.1      2019-03-12 [1]
##  gtable         0.3.0      2019-03-25 [1]
##  hms            0.5.0      2019-07-09 [1]
##  httr           1.4.1      2019-08-05 [1]
##  jsonlite       1.6        2018-12-07 [1]
##  KernSmooth     2.23-15    2015-06-29 [2]
##  labeling       0.3        2014-08-23 [1]
##  lattice        0.20-38    2018-11-04 [2]
##  lazyeval       0.2.2      2019-03-15 [1]
##  magrittr       1.5        2014-11-22 [1]
##  MASS           7.3-51.1   2018-11-01 [2]
##  Matrix         1.2-17     2019-03-22 [1]
##  mgcv           1.8-28     2019-03-21 [1]
##  mime           0.7        2019-06-11 [1]
##  munsell        0.5.0      2018-06-12 [1]
##  nlme           3.1-137    2018-04-07 [2]
##  openssl        1.4.1      2019-07-18 [1]
##  pillar         1.4.2      2019-06-29 [1]
##  pkgconfig      2.0.2      2018-08-16 [1]
##  plogr          0.2.0      2018-03-25 [1]
##  plyr           1.8.4      2016-06-08 [1]
##  purrr        * 0.3.2      2019-03-15 [1]
##  R6             2.4.0      2019-02-14 [1]
##  RColorBrewer * 1.1-2      2014-12-07 [1]
##  Rcpp           1.0.2      2019-07-25 [1]
##  readr        * 1.3.1      2018-12-21 [1]
##  reshape2       1.4.3      2017-12-11 [1]
##  rlang          0.4.0      2019-06-25 [1]
##  rvest          0.3.4      2019-05-15 [1]
##  scales         1.0.0      2018-08-09 [1]
##  selectr        0.4-1      2018-04-06 [1]
##  sf           * 0.7-7      2019-07-24 [1]
##  stringi        1.4.3      2019-03-12 [1]
##  stringr        1.4.0      2019-02-10 [1]
##  sys            3.2        2019-04-23 [1]
##  tibble         2.1.3      2019-06-06 [1]
##  tidyr        * 0.8.3      2019-03-01 [1]
##  tidyselect     0.2.5      2018-10-11 [1]
##  units          0.6-3      2019-05-03 [1]
##  utf8           1.1.4      2018-05-24 [1]
##  vctrs          0.2.0      2019-07-05 [1]
##  viridisLite    0.3.0      2018-02-01 [1]
##  withr          2.1.2      2018-03-15 [1]
##  wordcloud    * 2.6        2018-08-24 [1]
##  xml2           1.2.2      2019-08-09 [1]
##  zeallot        0.1.0      2018-01-28 [1]
##  source                              
##  CRAN (R 3.5.2)                      
##  CRAN (R 3.5.3)                      
##  CRAN (R 3.5.3)                      
##  CRAN (R 3.5.2)                      
##  local                               
##  Github (italocegatta/brnome@85a10a7)
##  CRAN (R 3.5.3)                      
##  CRAN (R 3.5.3)                      
##  CRAN (R 3.5.3)                      
##  CRAN (R 3.5.3)                      
##  CRAN (R 3.5.3)                      
##  CRAN (R 3.5.1)                      
##  CRAN (R 3.5.3)                      
##  CRAN (R 3.5.1)                      
##  CRAN (R 3.5.3)                      
##  CRAN (R 3.5.3)                      
##  CRAN (R 3.5.3)                      
##  CRAN (R 3.5.3)                      
##  CRAN (R 3.5.1)                      
##  CRAN (R 3.5.2)                      
##  CRAN (R 3.5.3)                      
##  CRAN (R 3.5.3)                      
##  CRAN (R 3.5.3)                      
##  CRAN (R 3.5.3)                      
##  CRAN (R 3.5.3)                      
##  CRAN (R 3.5.2)                      
##  CRAN (R 3.5.3)                      
##  CRAN (R 3.5.0)                      
##  CRAN (R 3.5.3)                      
##  CRAN (R 3.5.3)                      
##  CRAN (R 3.5.1)                      
##  CRAN (R 3.5.3)                      
##  CRAN (R 3.5.3)                      
##  CRAN (R 3.5.3)                      
##  CRAN (R 3.5.3)                      
##  CRAN (R 3.5.1)                      
##  CRAN (R 3.5.3)                      
##  CRAN (R 3.5.3)                      
##  CRAN (R 3.5.3)                      
##  CRAN (R 3.5.1)                      
##  CRAN (R 3.5.1)                      
##  CRAN (R 3.5.1)                      
##  CRAN (R 3.5.3)                      
##  CRAN (R 3.5.2)                      
##  CRAN (R 3.5.0)                      
##  CRAN (R 3.5.3)                      
##  CRAN (R 3.5.2)                      
##  CRAN (R 3.5.1)                      
##  CRAN (R 3.5.3)                      
##  CRAN (R 3.5.3)                      
##  CRAN (R 3.5.1)                      
##  CRAN (R 3.5.1)                      
##  CRAN (R 3.5.3)                      
##  CRAN (R 3.5.3)                      
##  CRAN (R 3.5.2)                      
##  CRAN (R 3.5.3)                      
##  CRAN (R 3.5.3)                      
##  CRAN (R 3.5.3)                      
##  CRAN (R 3.5.1)                      
##  CRAN (R 3.5.3)                      
##  CRAN (R 3.5.1)                      
##  CRAN (R 3.5.3)                      
##  CRAN (R 3.5.1)                      
##  CRAN (R 3.5.1)                      
##  CRAN (R 3.5.2)                      
##  CRAN (R 3.5.3)                      
##  CRAN (R 3.5.2)                      
## 
## [1] C:/Users/Italo/Documents/R/win-library/3.5
## [2] C:/Program Files/R/R-3.5.3/library&lt;/code&gt;&lt;/pre&gt;

      </content:encoded>
    </item>
    
    <item>
      <title>Risco de incêndio pela Fórmula de Monte Alegre</title>
      <link>https://italocegatta.github.io/risco-de-incendio-pela-formula-de-monte-alegre/</link>
      <pubDate>Sun, 15 Jul 2018 00:00:00 +0000</pubDate>
      
      <guid>https://italocegatta.github.io/risco-de-incendio-pela-formula-de-monte-alegre/</guid>
      <description>No setor florestal o fogo é uma questão recorrente e preocupante. Utilizar um índice de risco ou perigo de incêndio ajuda, no mínimo, no planejamento e no alerta para quem mora no entorno de maciços florestais como parques, hortos e plantios florestais.
A Fórmula de Monte Alegre (FMA) é um índice bastante simples, foi proposta em 1972 por Soares (1972) e utiliza apenas a umidade relativa do ar às 13h e a precipitação para calcular o risco de incêndio.</description>
      <content:encoded>
        


&lt;p&gt;No setor florestal o fogo é uma questão recorrente e preocupante. Utilizar um índice de risco ou perigo de incêndio ajuda, no mínimo, no planejamento e no alerta para quem mora no entorno de maciços florestais como parques, hortos e plantios florestais.&lt;/p&gt;
&lt;p&gt;A Fórmula de Monte Alegre (FMA) é um índice bastante simples, foi proposta em 1972 por &lt;span class=&#34;citation&#34;&gt;Soares (1972)&lt;/span&gt; e utiliza apenas a umidade relativa do ar às 13h e a precipitação para calcular o risco de incêndio. É um índice que possui 5 classes de risco e é cumulativo, portanto precisa ser calculado todos os dias.&lt;/p&gt;
&lt;p&gt;O objetivo deste post é implementar a FMA utilizando dados de 1988 à 2017 da estação meteorológica convencional da &lt;a href=&#34;http://www.esalq.usp.br/departamentos/leb/postocon.html&#34;&gt;ESALQ em Piracicaba&lt;/a&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;if (!require(&amp;quot;pacman&amp;quot;)) install.packages(&amp;quot;pacman&amp;quot;)
pacman::p_load(readr, dplyr, tidyr, forcats, lubridate, ggplot2, ggridges)&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;base &amp;lt;- read_csv2(
  &amp;quot;https://raw.githubusercontent.com/italocegatta/italocegatta.github.io_source/master/content/dados/posto_esalq_dia.csv&amp;quot;,
  col_types = cols(.default = col_number(), data = col_character())
)

base&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 10,961 x 3
##    data         ppt ur_med
##    &amp;lt;chr&amp;gt;      &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt;
##  1 01/01/1988   0       62
##  2 02/01/1988   0       65
##  3 03/01/1988   0       65
##  4 04/01/1988   0       69
##  5 05/01/1988  33.9     74
##  6 06/01/1988  66       90
##  7 07/01/1988   0       78
##  8 08/01/1988   0.5     88
##  9 09/01/1988  17.1     83
## 10 10/01/1988   7.8     83
## # ... with 10,951 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;O primeiro passo é estimar a umidade relativa às 13h, uma vez que é este valor que a FMA considera para o cálculo. Utilizaremos a equação ajustada por &lt;span class=&#34;citation&#34;&gt;Alvares et al. (2014)&lt;/span&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;base_fma &amp;lt;- base %&amp;gt;%
  mutate(
    data = dmy(data),
    ur13 = (8.77 * exp(0.024 * ur_med)) - 2.943
  ) %&amp;gt;% 
  select(data, ppt, ur13)

base_fma&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 10,961 x 3
##    data         ppt  ur13
##    &amp;lt;date&amp;gt;     &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt;
##  1 1988-01-01   0    35.9
##  2 1988-01-02   0    38.8
##  3 1988-01-03   0    38.8
##  4 1988-01-04   0    43.0
##  5 1988-01-05  33.9  48.9
##  6 1988-01-06  66    73.1
##  7 1988-01-07   0    54.1
##  8 1988-01-08   0.5  69.5
##  9 1988-01-09  17.1  61.3
## 10 1988-01-10   7.8  61.3
## # ... with 10,951 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Agora vamos fazer uma breve análise dos dados brutos. Começando pela chuva, podemos calcular o número médio de dias de chuva forte e fraca neste período. Entre julho e agosto há poucas chuvas em Piracicaba e isso já sugere que neste período o risco de incêndio deve ser alto.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;base_fma %&amp;gt;%
  mutate(ano = year(data), mes = month(data)) %&amp;gt;% 
  mutate(
    d_1 = ifelse(ppt &amp;gt; 1 &amp;amp; ppt &amp;lt;= 5, 1, 0),
    d_5 = ifelse(ppt &amp;gt; 5 , 1, 0)
  ) %&amp;gt;% 
  group_by(ano, mes) %&amp;gt;% 
  summarise_at(vars(d_1, d_5), sum, na.rm = TRUE) %&amp;gt;% 
  group_by(mes) %&amp;gt;% 
  summarise_at(vars(d_1, d_5), ~round(mean(.))) %&amp;gt;% 
  ungroup() %&amp;gt;% 
  rename(`&amp;lt;5` = d_1, `&amp;gt;5` = d_5) %&amp;gt;% 
  gather(nivel, d_chuva, `&amp;lt;5`:`&amp;gt;5`) %&amp;gt;% 
  mutate(
    d_chuva = ifelse(d_chuva == 0, NA, d_chuva),
    nivel = fct_relevel(nivel, &amp;quot;&amp;lt;5&amp;quot; , &amp;quot;&amp;gt;5&amp;quot;)
  ) %&amp;gt;% 
  ggplot(aes(mes, d_chuva, fill = nivel)) +
    geom_col(alpha = 0.8) +
    labs(
      x = &amp;quot;Mês do ano&amp;quot;,
      y = &amp;quot;Nº de dias de chuva (#)&amp;quot;,
      fill = NULL
    ) +
    scale_x_continuous(breaks = 1:12, labels = format(ISOdate(2000, 1:12, 1), &amp;quot;%b&amp;quot;)) +
    scale_y_continuous(breaks = seq(0, 30, 2), expand = expand_scale(mult = c(0.01, .1))) +
    scale_fill_manual(
      values = c(&amp;quot;#4292c6&amp;quot;, &amp;quot;#084594&amp;quot;),
      labels = c(&amp;quot;Chuva fraca (&amp;lt;5 mm)&amp;quot;,&amp;quot;Chuva forte (&amp;gt;5 mm)&amp;quot;)
    ) +
    theme_bw(16) +
    theme(legend.position = &amp;quot;top&amp;quot;, panel.grid.minor.x = element_blank())&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://italocegatta.github.io/post/2018-07-15-risco-de-incendio-pela-formula-de-monte-alegre_files/figure-html/unnamed-chunk-4-1.svg&#34; width=&#34;960&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Olhando para a distribuição da umidade relativa em cada mês, podemos ver que em junho a mediana ainda está próximo dos 50% de umidade. E só em julho que os dias mais secos começam a ter mais frequência e essa tendência aumenta até setembro, depois retorna gradativamente até a mediana de 57% de umidade em dezembro.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;base_fma %&amp;gt;% 
  filter(!is.na(ur13)) %&amp;gt;% 
  mutate(mes = factor(month(data))) %&amp;gt;% 
  ggplot(aes(ur13, mes)) +
    geom_density_ridges(quantile_lines = TRUE, quantiles = 2, fill = &amp;quot;#016c59&amp;quot;, alpha = 0.9) +
    labs(x = &amp;quot;Umidade Relativa às 13h (%)&amp;quot;, y = &amp;quot;Mês do ano&amp;quot;) +
    scale_x_continuous(breaks = seq(10, 100, 10)) +
    scale_y_discrete(labels = format(ISOdate(2000, 1:12, 1), &amp;quot;%b&amp;quot;)) +
    theme_bw(16)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://italocegatta.github.io/post/2018-07-15-risco-de-incendio-pela-formula-de-monte-alegre_files/figure-html/unnamed-chunk-5-1.svg&#34; width=&#34;960&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Sobre a Fórmula de Monte Alegre, o contexto que motivou seu desenvolvimento foi bastante trágico. Em 1963 um grande incêndio atingiu o estado do Paraná, com centenas de mortes e cerca de 2 milhões de hectares de florestas queimadas. Em 1972 o Professor Ronaldo Soares, da UFPR, defendeu sua tese de mestrado propondo a Fórmula de Monte Alegre com base em registros de incêndios florestais coletados a partir de 1965 na fazenda Monte Alegre (Klabin), em Telêmaco Borba-PR.&lt;/p&gt;
&lt;p&gt;A cálculo do índice é bastante simples, basta calcular o valor FMA do dia corrente e somar com o valor do dia anterior. O FMA é calculado através da seguinte expressão:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.sciweavers.org/tex2img.php?eq=FMA%20%3D%20%20%5Csum_%7Bi%3D1%7D%5En%20%20%5Cfrac%7B100%7D%7BURi_%7B13h%7D%7D%20&amp;bc=White&amp;fc=Black&amp;im=jpg&amp;fs=12&amp;ff=arev&amp;edit=0&#34; align=&#34;center&#34; border=&#34;0&#34; alt=&#34;FMA =  \sum_{i=1}^n  \frac{100}{URi_{13h}} &#34; width=&#34;139&#34; height=&#34;62&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Entretanto é preciso aplicar restrições ao valor FMA de acordo com a chuva do dia, seguindo estes parâmetros:&lt;/p&gt;
&lt;table&gt;
&lt;colgroup&gt;
&lt;col width=&#34;14%&#34; /&gt;
&lt;col width=&#34;86%&#34; /&gt;
&lt;/colgroup&gt;
&lt;thead&gt;
&lt;tr class=&#34;header&#34;&gt;
&lt;th&gt;Precipitação&lt;/th&gt;
&lt;th&gt;Restrição&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td&gt;&amp;lt; 2,5&lt;/td&gt;
&lt;td&gt;Nenhuma&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td&gt;2,5 - 4,9&lt;/td&gt;
&lt;td&gt;0,7 * FMAi-1 + FMAi&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td&gt;5,0 - 9,9&lt;/td&gt;
&lt;td&gt;0,4 * FMAi-1 + FMAi&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td&gt;10,0 - 12,9&lt;/td&gt;
&lt;td&gt;0,2 * FMAi-1 + FMAi&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td&gt;&amp;gt; 12,9&lt;/td&gt;
&lt;td&gt;Interromper o cálculo anterior (FMAi = 0) e começar novo cálculo no dia seguinte&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;O resultado do índice é apresentado com frequência na forma de classes de risco, obedecendo estes limites:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr class=&#34;header&#34;&gt;
&lt;th&gt;FMA&lt;/th&gt;
&lt;th&gt;Grau de perigo&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td&gt;0 - 1,0&lt;/td&gt;
&lt;td&gt;Nulo&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td&gt;1,1 - 3,0&lt;/td&gt;
&lt;td&gt;Pequeno&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td&gt;3,1 - 8,0&lt;/td&gt;
&lt;td&gt;Médio&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td&gt;8,1 – 20,0&lt;/td&gt;
&lt;td&gt;Alto&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td&gt;&amp;gt; 20,0&lt;/td&gt;
&lt;td&gt;Muito alto&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Vamos agora declara as funções que vão calcular o FMA e atribuir as classes de risco aos nossos dados.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;fma &amp;lt;- function(data, ur, ppt) {
  
  # testa se os dados estão ordenados
  if (any(data != sort(data))) {
    stop(&amp;quot;data precisa estar em ordem crescente&amp;quot;)
  }

  # cria o vetor de resultado  
  n &amp;lt;- length(ur)
  fma_vec &amp;lt;- rep(NA_real_, n)
  
  for (i in seq_len(n)) {
    
    # primeiro valor eh 0   
    if (i == 1) {
      fma_vec[i] &amp;lt;- 0
      next()
    }
    
    # se dia anterior nao tem informacao, valor eh 0
    if (is.na(ur[i - 1])) {
      fma_vec[i] &amp;lt;- 0
      next()
    }
    
    # aplica restricoes da chuva
    fma_vec[i] &amp;lt;- case_when(
      ppt[i] &amp;lt; 2.5 ~ (100 / ur[i]) + fma_vec[i - 1] * 1 ,
      ppt[i] &amp;gt;= 2.5 &amp;amp; ppt[i] &amp;lt; 5  ~ (100 / ur[i]) + fma_vec[i - 1] * 0.7,
      ppt[i] &amp;gt;= 5   &amp;amp; ppt[i] &amp;lt; 10 ~ (100 / ur[i]) + fma_vec[i - 1] * 0.4,
      ppt[i] &amp;gt;= 10  &amp;amp; ppt[i] &amp;lt; 13 ~ (100 / ur[i]) + fma_vec[i - 1] * 0.2,
      ppt[i] &amp;gt;= 13 ~ 0
    )
  }
  
  fma_vec
}

fma_classe &amp;lt;- function(fma, limites = c(1, 3, 8, 20)) {
  
  classe &amp;lt;- case_when(
    fma &amp;lt;= 1 ~ &amp;quot;Nulo&amp;quot;,
    fma &amp;gt; 1 &amp;amp; fma &amp;lt;= 3 ~&amp;quot;Pequeno&amp;quot;,
    fma &amp;gt; 3 &amp;amp; fma &amp;lt;= 8 ~ &amp;quot;Médio&amp;quot;,
    fma &amp;gt; 8 &amp;amp; fma &amp;lt;= 20 ~ &amp;quot;Alto&amp;quot;,
    fma &amp;gt; 20 ~ &amp;quot;Muito Alto&amp;quot;
  )
  
  factor(classe, levels = c(&amp;quot;Nulo&amp;quot;, &amp;quot;Pequeno&amp;quot;, &amp;quot;Médio&amp;quot;, &amp;quot;Alto&amp;quot;, &amp;quot;Muito Alto&amp;quot;))
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Seguindo para o cálculo do índice, vamos criar um novo data frame com o valor FMA e as classes de riscos utilizando as funções que acabamos de criar.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;dados_fma &amp;lt;- base_fma %&amp;gt;% 
  mutate(
    fma = fma(data, ur13, ppt),
    risco = fma_classe(fma)
  )

dados_fma&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 10,961 x 5
##    data         ppt  ur13   fma risco  
##    &amp;lt;date&amp;gt;     &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;fct&amp;gt;  
##  1 1988-01-01   0    35.9  0    Nulo   
##  2 1988-01-02   0    38.8  2.58 Pequeno
##  3 1988-01-03   0    38.8  5.16 Médio  
##  4 1988-01-04   0    43.0  7.48 Médio  
##  5 1988-01-05  33.9  48.9  0    Nulo   
##  6 1988-01-06  66    73.1  0    Nulo   
##  7 1988-01-07   0    54.1  1.85 Pequeno
##  8 1988-01-08   0.5  69.5  3.29 Médio  
##  9 1988-01-09  17.1  61.3  0    Nulo   
## 10 1988-01-10   7.8  61.3  1.63 Pequeno
## # ... with 10,951 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A primeira abordagem que quero mostrar é a evolução do valor FMA ao longo do ano. Considerando o dia do ano ou dia juliano, podemos ver a evolução do valor FMA devido á ausência de chuvas fortes. O máximo dessa “corrida” de risco vai até próximo do dia 290, que corresponde ao meio de outubro.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;dados_fma %&amp;gt;% 
  mutate(
    ano = year(data),
    dia_ano = yday(data)
  ) %&amp;gt;% 
  ggplot(aes(dia_ano, factor(ano), fill = fma)) +
  geom_tile() +
  labs(x = &amp;quot;Dia do ano&amp;quot;, y = &amp;quot;Ano&amp;quot;, fill = &amp;quot;FMA&amp;quot;) +
  scale_fill_viridis_c(option = &amp;quot;viridis&amp;quot;) +
  scale_x_continuous(breaks = seq(20, 360, 20), expand = c(0, 0)) +
  theme_bw()&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://italocegatta.github.io/post/2018-07-15-risco-de-incendio-pela-formula-de-monte-alegre_files/figure-html/unnamed-chunk-8-1.png&#34; width=&#34;960&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Calculando a frequência das classes dentro de cada ano, podemos ver que predomina o risco Muito Alto, seguido do risco Alto. O risco nulo, ocorre em aproximadamente 10% dos dias do ano.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;dados_fma  %&amp;gt;% 
  filter(!is.na(risco)) %&amp;gt;% 
  group_by(ano = year(data), risco) %&amp;gt;% 
  tally() %&amp;gt;% 
  ggplot(aes(ano, n, fill = risco)) +
  geom_col(position = &amp;quot;fill&amp;quot;, alpha = 0.8) +
  labs(x = &amp;quot;Ano&amp;quot;, y = &amp;quot;Frequência&amp;quot;, fill = &amp;quot;Risco&amp;quot;) +
  scale_y_continuous(breaks = seq(0.1, 1, 0.1), labels = scales::percent) +
  scale_fill_brewer(palette = &amp;quot;Spectral&amp;quot;, direction = -1) +
  theme_bw(16)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://italocegatta.github.io/post/2018-07-15-risco-de-incendio-pela-formula-de-monte-alegre_files/figure-html/unnamed-chunk-9-1.svg&#34; width=&#34;960&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Olhando para a frequência de risco dentro dos meses, fica claro o maior risco próximo do mês de agosto, como sugeriram os gráficos de frequências de chuva e umidade relativa.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;dados_fma  %&amp;gt;% 
  filter(!is.na(risco)) %&amp;gt;% 
  group_by(mes = month(data), risco) %&amp;gt;% 
  tally() %&amp;gt;% 
  ggplot(aes(mes, n, fill = risco)) +
  geom_col(position = &amp;quot;fill&amp;quot;, alpha = 0.8) +
  labs(x = &amp;quot;Mês do ano&amp;quot;, y = &amp;quot;Frequência&amp;quot;, fill = &amp;quot;Risco&amp;quot;) +
  scale_x_continuous(breaks = 1:12, labels = format(ISOdate(2000, 1:12, 1), &amp;quot;%b&amp;quot;)) +
  scale_y_continuous(labels = scales::percent) +
  scale_fill_brewer(palette = &amp;quot;Spectral&amp;quot;, direction = -1) +
  theme_bw(16)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://italocegatta.github.io/post/2018-07-15-risco-de-incendio-pela-formula-de-monte-alegre_files/figure-html/unnamed-chunk-10-1.svg&#34; width=&#34;960&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Bom, de maneira geral os gráficos não mostraram muita coisa nova. Todo mundo sabe que nos meses mais secos do ano o risco de incêndio é maior. De fato, o índice apenas dá um respaldo quantitativo para o senso comum. Uma vez calculado o índice, é possível confrontar com dados reais de incêndios e propor novos valores para as classes de risco com o objetivo de deixá-lo mais assertivo para uma certa região.&lt;/p&gt;
&lt;p&gt;Caso tenha alguma dúvida ou sugestão sobre o post, fique à vontade para fazer um comentário ou me contatar por E-mail.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;sessioninfo::session_info(c(&amp;quot;readr&amp;quot;, &amp;quot;dplyr&amp;quot;, &amp;quot;ggplot2&amp;quot;, &amp;quot;tidyr&amp;quot;, &amp;quot;forcats&amp;quot;, &amp;quot;lubridate&amp;quot;, &amp;quot;ggridges&amp;quot;))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## - Session info ----------------------------------------------------------
##  setting  value                       
##  version  R version 3.5.3 (2019-03-11)
##  os       Windows 10 x64              
##  system   x86_64, mingw32             
##  ui       RTerm                       
##  language (EN)                        
##  collate  Portuguese_Brazil.1252      
##  ctype    Portuguese_Brazil.1252      
##  tz       America/Sao_Paulo           
##  date     2019-08-25                  
## 
## - Packages --------------------------------------------------------------
##  package      * version  date       lib source        
##  assertthat     0.2.1    2019-03-21 [1] CRAN (R 3.5.3)
##  backports      1.1.4    2019-04-10 [1] CRAN (R 3.5.3)
##  BH             1.69.0-1 2019-01-07 [1] CRAN (R 3.5.2)
##  cli            1.1.0    2019-03-19 [1] CRAN (R 3.5.3)
##  clipr          0.7.0    2019-07-23 [1] CRAN (R 3.5.3)
##  colorspace     1.4-1    2019-03-18 [1] CRAN (R 3.5.3)
##  crayon         1.3.4    2017-09-16 [1] CRAN (R 3.5.1)
##  digest         0.6.20   2019-07-04 [1] CRAN (R 3.5.3)
##  dplyr        * 0.8.3    2019-07-04 [1] CRAN (R 3.5.3)
##  ellipsis       0.2.0.1  2019-07-02 [1] CRAN (R 3.5.3)
##  fansi          0.4.0    2018-10-05 [1] CRAN (R 3.5.1)
##  forcats      * 0.4.0    2019-02-17 [1] CRAN (R 3.5.2)
##  ggplot2      * 3.2.1    2019-08-10 [1] CRAN (R 3.5.3)
##  ggridges     * 0.5.1    2018-09-27 [1] CRAN (R 3.5.2)
##  glue           1.3.1    2019-03-12 [1] CRAN (R 3.5.3)
##  gtable         0.3.0    2019-03-25 [1] CRAN (R 3.5.3)
##  hms            0.5.0    2019-07-09 [1] CRAN (R 3.5.3)
##  labeling       0.3      2014-08-23 [1] CRAN (R 3.5.0)
##  lattice        0.20-38  2018-11-04 [2] CRAN (R 3.5.3)
##  lazyeval       0.2.2    2019-03-15 [1] CRAN (R 3.5.3)
##  lubridate    * 1.7.4    2018-04-11 [1] CRAN (R 3.5.1)
##  magrittr       1.5      2014-11-22 [1] CRAN (R 3.5.1)
##  MASS           7.3-51.1 2018-11-01 [2] CRAN (R 3.5.3)
##  Matrix         1.2-17   2019-03-22 [1] CRAN (R 3.5.3)
##  mgcv           1.8-28   2019-03-21 [1] CRAN (R 3.5.3)
##  munsell        0.5.0    2018-06-12 [1] CRAN (R 3.5.1)
##  nlme           3.1-137  2018-04-07 [2] CRAN (R 3.5.3)
##  pillar         1.4.2    2019-06-29 [1] CRAN (R 3.5.3)
##  pkgconfig      2.0.2    2018-08-16 [1] CRAN (R 3.5.1)
##  plogr          0.2.0    2018-03-25 [1] CRAN (R 3.5.1)
##  plyr           1.8.4    2016-06-08 [1] CRAN (R 3.5.1)
##  purrr          0.3.2    2019-03-15 [1] CRAN (R 3.5.3)
##  R6             2.4.0    2019-02-14 [1] CRAN (R 3.5.2)
##  RColorBrewer   1.1-2    2014-12-07 [1] CRAN (R 3.5.0)
##  Rcpp           1.0.2    2019-07-25 [1] CRAN (R 3.5.3)
##  readr        * 1.3.1    2018-12-21 [1] CRAN (R 3.5.2)
##  reshape2       1.4.3    2017-12-11 [1] CRAN (R 3.5.1)
##  rlang          0.4.0    2019-06-25 [1] CRAN (R 3.5.3)
##  scales         1.0.0    2018-08-09 [1] CRAN (R 3.5.1)
##  stringi        1.4.3    2019-03-12 [1] CRAN (R 3.5.3)
##  stringr        1.4.0    2019-02-10 [1] CRAN (R 3.5.2)
##  tibble         2.1.3    2019-06-06 [1] CRAN (R 3.5.3)
##  tidyr        * 0.8.3    2019-03-01 [1] CRAN (R 3.5.3)
##  tidyselect     0.2.5    2018-10-11 [1] CRAN (R 3.5.1)
##  utf8           1.1.4    2018-05-24 [1] CRAN (R 3.5.1)
##  vctrs          0.2.0    2019-07-05 [1] CRAN (R 3.5.3)
##  viridisLite    0.3.0    2018-02-01 [1] CRAN (R 3.5.1)
##  withr          2.1.2    2018-03-15 [1] CRAN (R 3.5.1)
##  zeallot        0.1.0    2018-01-28 [1] CRAN (R 3.5.2)
## 
## [1] C:/Users/Italo/Documents/R/win-library/3.5
## [2] C:/Program Files/R/R-3.5.3/library&lt;/code&gt;&lt;/pre&gt;
&lt;div id=&#34;referencias&#34; class=&#34;section level1 unnumbered&#34;&gt;
&lt;h1&gt;Referências&lt;/h1&gt;
&lt;div id=&#34;refs&#34; class=&#34;references&#34;&gt;
&lt;div id=&#34;ref-alvares2014&#34;&gt;
&lt;p&gt;Alvares, Clayton Alcarde, Italo Ramos Cegatta, Lucas Augusto Abra Vieira, Rafaela de Freitas Pavani, Eduardo Moré Mattos, Paulo Cesar Sentelhas, José Luiz Stape, and Ronaldo Viana Soares. 2014. “Perigo de Incêndio Florestal: Aplicação Da Fórmula de Monte Alegre E Avaliação Do Histórico Para Piracicaba, Sp.” &lt;em&gt;Scientia Forestalis, Piracicaba&lt;/em&gt; 42 (104): 511–22.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;ref-soares1972&#34;&gt;
&lt;p&gt;Soares, Ronaldo Viana. 1972. “Determinação de Um ı́ndice de Perigo de Incêndio Para a Região Centro Paranaense, Brasil. Turrialba, Costa Rica, Catie/Iica,. 72 P.” PhD thesis, Tese de Mestrado.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

      </content:encoded>
    </item>
    
    <item>
      <title>Qual Estado tem mais pau-rodado?</title>
      <link>https://italocegatta.github.io/qual-estado-tem-mais-pau-rodado/</link>
      <pubDate>Sat, 24 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://italocegatta.github.io/qual-estado-tem-mais-pau-rodado/</guid>
      <description>Em Cuiabá, cidade que nasci e cresci, pau-rodado é um substantivo que define pessoas que nasceram em outro Estado mas moram em Cuiabá e ali construíram suas vidas. Aliás, Cuiabá sempre foi conhecida por ser uma Cidade super acolhedora e talvez por isso todos encaram o dito pau-rodado de uma forma engraçada e sem qualquer sentido pejorativo.
Muito bem, meu interesse com este post é analisar o comportamento dos fluxos migratórios entre Estados e assim encontrar os Estados que tem mais e menos pau-rodado em sua população residente.</description>
      <content:encoded>
        


&lt;p&gt;Em Cuiabá, cidade que nasci e cresci, &lt;em&gt;pau-rodado&lt;/em&gt; é um substantivo que define pessoas que nasceram em outro Estado mas moram em Cuiabá e ali construíram suas vidas. Aliás, Cuiabá sempre foi conhecida por ser uma Cidade super acolhedora e talvez por isso todos encaram o dito &lt;em&gt;pau-rodado&lt;/em&gt; de uma forma engraçada e sem qualquer sentido pejorativo.&lt;/p&gt;
&lt;p&gt;Muito bem, meu interesse com este post é analisar o comportamento dos fluxos migratórios entre Estados e assim encontrar os Estados que tem mais e menos &lt;em&gt;pau-rodado&lt;/em&gt; em sua população residente. Serei breve e não vamos abordar todos os Estados, mas se você tiver curiosidade poderá aproveitar o código para uma análise mais ampla.&lt;/p&gt;
&lt;p&gt;A motivação partiu de uma matéria do &lt;a href=&#34;https://www.nexojornal.com.br/grafico/2017/12/01/Fluxos-migrat%C3%B3rios-a-distribui%C3%A7%C3%A3o-da-popula%C3%A7%C3%A3o-de-cada-estado-pelo-pa%C3%ADs&#34;&gt;Nexo Jornal&lt;/a&gt; sobre este tema, porém ao nível estadual. Depois de algumas horas tentando decifrar o site do IBGE, cheguei na &lt;a href=&#34;https://sidra.ibge.gov.br/tabela/1852&#34;&gt;página&lt;/a&gt; que informa a população residente, por lugar de nascimento e unidade da federação.&lt;/p&gt;
&lt;p&gt;Então vamos começar a análise carregando os pacotes do R necessários para este post.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;if (!require(&amp;quot;pacman&amp;quot;)) install.packages(&amp;quot;pacman&amp;quot;)
pacman::p_load(readr, dplyr, tidyr, forcats, sf, geosphere, brmap, ggplot2, ggrepel, geofacet)
pacman::p_load_gh(&amp;quot;italocegatta/brmap&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Os dados originais estão disponíveis neste &lt;a href=&#34;https://sidra.ibge.gov.br/tabela/1852&#34;&gt;link&lt;/a&gt;, fiz apenas adequações porque o IBGE insiste em mesclar células nas tabelas disponibilizadas. Já nesta tabela você consegue olhar para o Estado que você mora e analisar quanto dos residentes nasceram em outros Estados. Mas o objetivo é enxergar isso de forma gráfica para ampliar a percepção dos dados.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;base &amp;lt;- read_csv2(&amp;quot;https://raw.githubusercontent.com/italocegatta/italocegatta.github.io_source/master/content/dados/pnad_2015_migracao.csv&amp;quot;)

base&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 27 x 28
##    Estado Rondônia  Acre Amazonas Roraima  Pará Amapá Tocantins Maranhão
##    &amp;lt;chr&amp;gt;     &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt;    &amp;lt;dbl&amp;gt;   &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt;     &amp;lt;dbl&amp;gt;    &amp;lt;dbl&amp;gt;
##  1 Rondô~    57.4   1.84     1.9     0.08  0.7  NA        0.02      1.02
##  2 Acre       1.54 87.9      3.89    0.02  0.17 NA        0.02      0.11
##  3 Amazo~     0.46  1.6     87.6     0.23  5.36  0.13     0.06      0.87
##  4 Rorai~     0.65  0.24     5.16   55.6   6.54  0.04     0.570    19.0 
##  5 Pará       0.03  0.02     0.49    0.02 84.6   0.19     1.07      6.89
##  6 Amapá      0.1   0.03     0.2     0.17 20.8  72.7      0.1       3.65
##  7 Tocan~     0.07  0.07     0.02   NA     2.83  0.02    69.5       8.58
##  8 Maran~     0.03  0.01     0.05   NA     1.11  0.01     0.32     92.4 
##  9 Piauí      0.04  0.02     0.04    0.05  0.28 NA        0.11      3.97
## 10 Ceará      0.03  0.04     0.11   NA     0.22  0.01     0.03      0.35
## # ... with 17 more rows, and 19 more variables: Piauí &amp;lt;dbl&amp;gt;, Ceará &amp;lt;dbl&amp;gt;,
## #   `Rio Grande do Norte` &amp;lt;dbl&amp;gt;, Paraíba &amp;lt;dbl&amp;gt;, Pernambuco &amp;lt;dbl&amp;gt;,
## #   Alagoas &amp;lt;dbl&amp;gt;, Sergipe &amp;lt;dbl&amp;gt;, Bahia &amp;lt;dbl&amp;gt;, `Minas Gerais` &amp;lt;dbl&amp;gt;,
## #   `Espírito Santo` &amp;lt;dbl&amp;gt;, `Rio de Janeiro` &amp;lt;dbl&amp;gt;, `São Paulo` &amp;lt;dbl&amp;gt;,
## #   Paraná &amp;lt;dbl&amp;gt;, `Santa Catarina` &amp;lt;dbl&amp;gt;, `Rio Grande do Sul` &amp;lt;dbl&amp;gt;, `Mato
## #   Grosso do Sul` &amp;lt;dbl&amp;gt;, `Mato Grosso` &amp;lt;dbl&amp;gt;, Goiás &amp;lt;dbl&amp;gt;, `Distrito
## #   Federal` &amp;lt;dbl&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Dados longitudinais como estes ajudam humanos a enxergar os valores de forma mais fácil, mas do ponto de vista de processamento de dados, não dá pra fazer muita coisa com os dados assim. Vamos organizá-los seguindo a filosofia do &lt;a href=&#34;https://italocegatta.github.io/o-conceito-tidy-data&#34;&gt;Tidy data&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;A nova tabela nos informa a porcentagem da população residente (coluna ‘valor’) para cada Estado, subdividindo os valores por local de nascimento. E agora vai a primeira simplificação: foram selecionados apenas os 6 Estados de nascimento mais representativos para cada Estado de residência.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;df &amp;lt;- base %&amp;gt;% 
  gather(reside, valor, -Estado) %&amp;gt;%
  select(nasce = Estado, reside, valor) %&amp;gt;% 
  replace_na(list(valor = 0)) %&amp;gt;% 
  group_by(nasce) %&amp;gt;% 
  filter(row_number(-valor) &amp;lt;= 6) %&amp;gt;% 
  ungroup()

df&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 162 x 3
##    nasce    reside   valor
##    &amp;lt;chr&amp;gt;    &amp;lt;chr&amp;gt;    &amp;lt;dbl&amp;gt;
##  1 Rondônia Rondônia 57.4 
##  2 Acre     Rondônia  1.54
##  3 Amazonas Rondônia  0.46
##  4 Acre     Acre     87.9 
##  5 Amazonas Acre      1.6 
##  6 Acre     Amazonas  3.89
##  7 Amazonas Amazonas 87.6 
##  8 Roraima  Amazonas  5.16
##  9 Roraima  Roraima  55.6 
## 10 Amazonas Pará      5.36
## # ... with 152 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Vamos nos preparar para a segunda simplificação: selecionar os extremos em termos de população que nasceu e reside no mesmo Estado. Então, RS, CE e PE são os Estados que mais tem moradores nascidos dentro do próprio Estado, enquanto RO, RR e DF tem uma parcela maior de residentes nascidos em outros Estados.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;estados_interesse &amp;lt;- df %&amp;gt;%
  filter(reside == nasce) %&amp;gt;%
  filter(row_number(-valor) &amp;lt;= 3 | row_number(valor) &amp;lt;= 3) %&amp;gt;% 
  arrange(-valor) %&amp;gt;%
  pull(nasce)

estados_interesse&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;Rio Grande do Sul&amp;quot; &amp;quot;Ceará&amp;quot;             &amp;quot;Pernambuco&amp;quot;       
## [4] &amp;quot;Rondônia&amp;quot;          &amp;quot;Roraima&amp;quot;           &amp;quot;Distrito Federal&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Preparando para o mapa, vamos pegar as coordenadas dos centroides de cada Estado.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;estado_cent &amp;lt;- brmap_estado_simples %&amp;gt;% 
  st_centroid() %&amp;gt;% 
  cbind(., st_coordinates(.)) %&amp;gt;% 
  st_set_geometry(NULL) %&amp;gt;% 
  select(estado = estado_nome, lon = X, lat = Y)

estado_cent&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##                 estado       lon        lat
## 1             Rondônia -62.84198 -10.913179
## 2                 Acre -70.47331  -9.212856
## 3             Amazonas -64.65314  -4.154180
## 4              Roraima -61.39929   2.084236
## 5                 Pará -53.06412  -3.974753
## 6                Amapá -51.95593   1.443332
## 7            Tocantins -48.32923 -10.150295
## 8             Maranhão -45.27924  -5.060364
## 9                Piauí -42.96862  -7.387507
## 10               Ceará -39.61569  -5.093333
## 11 Rio Grande do Norte -36.67345  -5.839671
## 12             Paraíba -36.83252  -7.121067
## 13          Pernambuco -37.99844  -8.326032
## 14             Alagoas -36.62489  -9.513860
## 15             Sergipe -37.44398 -10.584509
## 16               Bahia -41.72093 -12.475028
## 17        Minas Gerais -44.67342 -18.456183
## 18      Espírito Santo -40.67104 -19.575096
## 19      Rio de Janeiro -42.65244 -22.188742
## 20           São Paulo -48.73408 -22.263477
## 21              Paraná -51.61670 -24.635890
## 22      Santa Catarina -50.47486 -27.247326
## 23   Rio Grande do Sul -53.32041 -29.705543
## 24  Mato Grosso do Sul -54.84563 -20.327333
## 25         Mato Grosso -55.91218 -12.949089
## 26               Goiás -49.62337 -16.042019
## 27    Distrito Federal -47.79736 -15.780667&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;E agora, o pulo do gato. Vamos criar as linhas que ligam os Estados entre si e em seguida adicionar à tabela que informa as relações de fluxo. Portanto, para cada relação entre Estado de nascimento/residência temos uma feição de linha e o valor que representa a porcentagem de residentes.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;coord &amp;lt;- df %&amp;gt;% 
  left_join(estado_cent, by = c(&amp;quot;nasce&amp;quot; = &amp;quot;estado&amp;quot;)) %&amp;gt;% 
  left_join(estado_cent, by = c(&amp;quot;reside&amp;quot; = &amp;quot;estado&amp;quot;)) %&amp;gt;%
  filter(nasce %in% estados_interesse)

linhas &amp;lt;- gcIntermediate(
  select(coord, lon.x, lat.x), 
  select(coord, lon.y, lat.y), 
  sp = TRUE, addStartEnd = TRUE
  ) %&amp;gt;% 
  st_as_sf()

fluxo_linha &amp;lt;- coord %&amp;gt;% 
  select(nasce, reside, valor) %&amp;gt;% 
  bind_cols(linhas) %&amp;gt;% 
  left_join(estado_cent, by = c(&amp;quot;reside&amp;quot; = &amp;quot;estado&amp;quot;)) %&amp;gt;% 
  mutate(nasce = fct_relevel(nasce, estados_interesse)) %&amp;gt;% 
  st_as_sf()

fluxo_linha&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Simple feature collection with 36 features and 5 fields
## geometry type:  LINESTRING
## dimension:      XY
## bbox:           xmin: -64.65314 ymin: -29.70554 xmax: -36.62489 ymax: 2.084236
## epsg (SRID):    4326
## proj4string:    +proj=longlat +ellps=WGS84 +no_defs
## # A tibble: 36 x 6
##    nasce    reside  valor                             geometry   lon    lat
##    &amp;lt;fct&amp;gt;    &amp;lt;chr&amp;gt;   &amp;lt;dbl&amp;gt;                     &amp;lt;LINESTRING [°]&amp;gt; &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt;
##  1 Rondônia Rondôn~ 57.4  (-62.84198 -10.91318, -62.84198 -10~ -62.8 -10.9 
##  2 Roraima  Amazon~  5.16 (-61.39929 2.084236, -61.46309 1.96~ -64.7  -4.15
##  3 Roraima  Roraima 55.6  (-61.39929 2.084236, -61.39929 2.08~ -61.4   2.08
##  4 Roraima  Pará     6.54 (-61.39929 2.084236, -61.23585 1.96~ -53.1  -3.97
##  5 Roraima  Maranh~ 19.0  (-61.39929 2.084236, -61.08345 1.94~ -45.3  -5.06
##  6 Distrit~ Maranh~  4.42 (-47.79736 -15.78067, -47.74601 -15~ -45.3  -5.06
##  7 Ceará    Piauí    0.39 (-39.61569 -5.093333, -39.68117 -5.~ -43.0  -7.39
##  8 Distrit~ Piauí    5.08 (-47.79736 -15.78067, -47.69952 -15~ -43.0  -7.39
##  9 Roraima  Ceará    2.76 (-61.39929 2.084236, -60.9725 1.942~ -39.6  -5.09
## 10 Ceará    Ceará   95.8  (-39.61569 -5.093333, -39.61569 -5.~ -39.6  -5.09
## # ... with 26 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Para deixar o gráfico um pouco mais bonito, vamos dar cor ao valor que estamos estudando. Mas agora a feição será o polígono que representa o Estado de residentes.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;fluxo_poligono &amp;lt;- brmap_estado_simples %&amp;gt;% 
  left_join(df, by =  c(&amp;quot;estado_nome&amp;quot; = &amp;quot;reside&amp;quot;)) %&amp;gt;% 
  rename(reside = estado_nome) %&amp;gt;% 
  filter(nasce %in% estados_interesse) %&amp;gt;% 
  mutate(nasce = fct_relevel(nasce, estados_interesse)) %&amp;gt;% 
  select(nasce, reside, valor)

fluxo_poligono&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Simple feature collection with 36 features and 3 fields
## geometry type:  POLYGON
## dimension:      XY
## bbox:           xmin: -73.80156 ymin: -33.75077 xmax: -34.79288 ymax: 5.271841
## epsg (SRID):    4674
## proj4string:    +proj=longlat +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +no_defs
## # A tibble: 36 x 4
##    nasce       reside  valor                                       geometry
##  * &amp;lt;fct&amp;gt;       &amp;lt;chr&amp;gt;   &amp;lt;dbl&amp;gt;                                  &amp;lt;POLYGON [°]&amp;gt;
##  1 Rondônia    Rondôn~ 57.4  ((-61.58313 -8.798689, -61.5801 -8.802692, -6~
##  2 Roraima     Amazon~  5.16 ((-63.37209 2.211862, -63.35979 2.197102, -63~
##  3 Roraima     Roraima 55.6  ((-58.8955 1.227694, -58.89546 0.9047314, -58~
##  4 Roraima     Pará     6.54 ((-54.87225 2.433747, -54.87625 2.426694, -54~
##  5 Roraima     Maranh~ 19.0  ((-41.81411 -2.739309, -41.82457 -2.756218, -~
##  6 Distrito F~ Maranh~  4.42 ((-41.81411 -2.739309, -41.82457 -2.756218, -~
##  7 Ceará       Piauí    0.39 ((-41.32268 -2.92132, -41.32156 -2.935416, -4~
##  8 Distrito F~ Piauí    5.08 ((-41.32268 -2.92132, -41.32156 -2.935416, -4~
##  9 Roraima     Ceará    2.76 ((-37.25329 -4.831556, -37.44645 -4.880961, -~
## 10 Ceará       Ceará   95.8  ((-37.25329 -4.831556, -37.44645 -4.880961, -~
## # ... with 26 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Pronto, já temos todos os dados que fazer o gráfico de interesse. Lembrando que optamos por dar destaque a 6 Estados e para cada um deles, os 6 Estados de nascimento que mais representam a população de residentes. Sim, é um tanto complexo. Eu fiquei algumas horas para poder criar o código e entender o que estava processando.&lt;/p&gt;
&lt;p&gt;Como exemplo vamos interpretar as informações de Roraima: do total de residentes, 55.6% nasceram no próprio Estado de Roraima; 5.2%, 6.5% e 19% nasceram no Amazonas, Pará e Maranhão, respectivamente.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggplot() +
  geom_sf(data = brmap_estado_simples, color = &amp;quot;white&amp;quot;, fill = &amp;quot;grey80&amp;quot;, size = 0.3) +
  geom_sf(data = fluxo_poligono, aes(fill = valor), color = &amp;quot;white&amp;quot;, size = 0.3) +
  geom_sf(data = fluxo_linha, color = &amp;quot;cyan&amp;quot;, size = 0.3) +
  geom_label_repel(
    data = fluxo_linha,
    aes(lon, lat, label = round(valor, 1)),
    size = 3, segment.colour = NA
  ) +
  facet_wrap(~nasce) +
  labs(
    title = &amp;quot;População residente (% do total geral)&amp;quot;,
    subtitle = &amp;quot;PNAD/IBGE, 2015&amp;quot;,
    x = NULL, y = NULL
  ) +
  scale_fill_viridis_c(guide = FALSE) +
  coord_sf(datum = NA) +
  theme_void(16)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://italocegatta.github.io/post/2018-03-24-qual-estado-tem-mais-pau-rodado_files/figure-html/unnamed-chunk-8-1.png&#34; width=&#34;960&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Pontos interessantes:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Rondônia e Roraima retém uma proporção parecida da população dentro do próprio Estado, entretanto o pessoal que mora em Rondônia veio do Sul e Sudeste; ao passo que os moradores de Roraima vêm do AM, PA e MA.&lt;/li&gt;
&lt;li&gt;O Distrito Federal não me surpreendeu, grande parte de pessoas nasceram em GO, MG e BA.&lt;/li&gt;
&lt;li&gt;Um número expressivo de pessoas que nasceram em São Paulo e hoje moram no CE e PE… parece que o jogo virou, não é mesmo?&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Caso tenha alguma dúvida ou sugestão sobre o post, fique à vontade para fazer um comentário ou me contatar por E-mail.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;sessioninfo::session_info(c(&amp;quot;readr&amp;quot;, &amp;quot;dplyr&amp;quot;, &amp;quot;ggplot2&amp;quot;, &amp;quot;tidyr&amp;quot;, &amp;quot;forcats&amp;quot;, &amp;quot;sf&amp;quot;, &amp;quot;geosphere&amp;quot;, &amp;quot;ggrepel&amp;quot;, &amp;quot;geofacet&amp;quot;, &amp;quot;brmap&amp;quot;))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## - Session info ----------------------------------------------------------
##  setting  value                       
##  version  R version 3.5.3 (2019-03-11)
##  os       Windows 10 x64              
##  system   x86_64, mingw32             
##  ui       RTerm                       
##  language (EN)                        
##  collate  Portuguese_Brazil.1252      
##  ctype    Portuguese_Brazil.1252      
##  tz       America/Sao_Paulo           
##  date     2019-08-25                  
## 
## - Packages --------------------------------------------------------------
##  package       * version     date       lib source        
##  askpass         1.1         2019-01-13 [1] CRAN (R 3.5.2)
##  assertthat      0.2.1       2019-03-21 [1] CRAN (R 3.5.3)
##  backports       1.1.4       2019-04-10 [1] CRAN (R 3.5.3)
##  BH              1.69.0-1    2019-01-07 [1] CRAN (R 3.5.2)
##  brmap         * 0.1.0       2019-03-04 [1] local         
##  class           7.3-15      2019-01-01 [2] CRAN (R 3.5.3)
##  classInt        0.4-1       2019-08-06 [1] CRAN (R 3.5.3)
##  cli             1.1.0       2019-03-19 [1] CRAN (R 3.5.3)
##  clipr           0.7.0       2019-07-23 [1] CRAN (R 3.5.3)
##  colorspace      1.4-1       2019-03-18 [1] CRAN (R 3.5.3)
##  crayon          1.3.4       2017-09-16 [1] CRAN (R 3.5.1)
##  curl            4.0         2019-07-22 [1] CRAN (R 3.5.3)
##  DBI             1.0.0       2018-05-02 [1] CRAN (R 3.5.1)
##  digest          0.6.20      2019-07-04 [1] CRAN (R 3.5.3)
##  dplyr         * 0.8.3       2019-07-04 [1] CRAN (R 3.5.3)
##  e1071           1.7-2       2019-06-05 [1] CRAN (R 3.5.3)
##  ellipsis        0.2.0.1     2019-07-02 [1] CRAN (R 3.5.3)
##  fansi           0.4.0       2018-10-05 [1] CRAN (R 3.5.1)
##  forcats       * 0.4.0       2019-02-17 [1] CRAN (R 3.5.2)
##  geofacet      * 0.1.10      2019-03-13 [1] CRAN (R 3.5.3)
##  geogrid         0.1.1       2018-12-11 [1] CRAN (R 3.5.2)
##  geosphere     * 1.5-10      2019-05-26 [1] CRAN (R 3.5.3)
##  ggplot2       * 3.2.1       2019-08-10 [1] CRAN (R 3.5.3)
##  ggrepel       * 0.8.1       2019-05-07 [1] CRAN (R 3.5.3)
##  glue            1.3.1       2019-03-12 [1] CRAN (R 3.5.3)
##  gridExtra       2.3         2017-09-09 [1] CRAN (R 3.5.1)
##  gtable          0.3.0       2019-03-25 [1] CRAN (R 3.5.3)
##  hms             0.5.0       2019-07-09 [1] CRAN (R 3.5.3)
##  httr            1.4.1       2019-08-05 [1] CRAN (R 3.5.3)
##  imguR           1.0.3       2016-03-29 [1] CRAN (R 3.5.1)
##  jpeg            0.1-8       2014-01-23 [1] CRAN (R 3.5.0)
##  jsonlite        1.6         2018-12-07 [1] CRAN (R 3.5.2)
##  KernSmooth      2.23-15     2015-06-29 [2] CRAN (R 3.5.3)
##  labeling        0.3         2014-08-23 [1] CRAN (R 3.5.0)
##  lattice         0.20-38     2018-11-04 [2] CRAN (R 3.5.3)
##  lazyeval        0.2.2       2019-03-15 [1] CRAN (R 3.5.3)
##  magrittr        1.5         2014-11-22 [1] CRAN (R 3.5.1)
##  MASS            7.3-51.1    2018-11-01 [2] CRAN (R 3.5.3)
##  Matrix          1.2-17      2019-03-22 [1] CRAN (R 3.5.3)
##  mgcv            1.8-28      2019-03-21 [1] CRAN (R 3.5.3)
##  mime            0.7         2019-06-11 [1] CRAN (R 3.5.3)
##  munsell         0.5.0       2018-06-12 [1] CRAN (R 3.5.1)
##  nlme            3.1-137     2018-04-07 [2] CRAN (R 3.5.3)
##  openssl         1.4.1       2019-07-18 [1] CRAN (R 3.5.3)
##  pillar          1.4.2       2019-06-29 [1] CRAN (R 3.5.3)
##  pkgconfig       2.0.2       2018-08-16 [1] CRAN (R 3.5.1)
##  plogr           0.2.0       2018-03-25 [1] CRAN (R 3.5.1)
##  plyr            1.8.4       2016-06-08 [1] CRAN (R 3.5.1)
##  png             0.1-7       2013-12-03 [1] CRAN (R 3.5.0)
##  purrr           0.3.2       2019-03-15 [1] CRAN (R 3.5.3)
##  R6              2.4.0       2019-02-14 [1] CRAN (R 3.5.2)
##  RColorBrewer    1.1-2       2014-12-07 [1] CRAN (R 3.5.0)
##  Rcpp            1.0.2       2019-07-25 [1] CRAN (R 3.5.3)
##  RcppArmadillo   0.9.600.4.0 2019-07-15 [1] CRAN (R 3.5.3)
##  readr         * 1.3.1       2018-12-21 [1] CRAN (R 3.5.2)
##  reshape2        1.4.3       2017-12-11 [1] CRAN (R 3.5.1)
##  rgeos           0.5-1       2019-08-05 [1] CRAN (R 3.5.3)
##  rlang           0.4.0       2019-06-25 [1] CRAN (R 3.5.3)
##  rnaturalearth   0.1.0       2017-03-21 [1] CRAN (R 3.5.1)
##  scales          1.0.0       2018-08-09 [1] CRAN (R 3.5.1)
##  sf            * 0.7-7       2019-07-24 [1] CRAN (R 3.5.3)
##  sp              1.3-1       2018-06-05 [1] CRAN (R 3.5.1)
##  stringi         1.4.3       2019-03-12 [1] CRAN (R 3.5.3)
##  stringr         1.4.0       2019-02-10 [1] CRAN (R 3.5.2)
##  sys             3.2         2019-04-23 [1] CRAN (R 3.5.3)
##  tibble          2.1.3       2019-06-06 [1] CRAN (R 3.5.3)
##  tidyr         * 0.8.3       2019-03-01 [1] CRAN (R 3.5.3)
##  tidyselect      0.2.5       2018-10-11 [1] CRAN (R 3.5.1)
##  units           0.6-3       2019-05-03 [1] CRAN (R 3.5.3)
##  utf8            1.1.4       2018-05-24 [1] CRAN (R 3.5.1)
##  vctrs           0.2.0       2019-07-05 [1] CRAN (R 3.5.3)
##  viridisLite     0.3.0       2018-02-01 [1] CRAN (R 3.5.1)
##  withr           2.1.2       2018-03-15 [1] CRAN (R 3.5.1)
##  zeallot         0.1.0       2018-01-28 [1] CRAN (R 3.5.2)
## 
## [1] C:/Users/Italo/Documents/R/win-library/3.5
## [2] C:/Program Files/R/R-3.5.3/library&lt;/code&gt;&lt;/pre&gt;

      </content:encoded>
    </item>
    
    <item>
      <title>100 anos do posto meteorológico da ESALQ</title>
      <link>https://italocegatta.github.io/100-anos-do-posto-meteorologico-da-esalq/</link>
      <pubDate>Sat, 14 Oct 2017 00:00:00 +0000</pubDate>
      
      <guid>https://italocegatta.github.io/100-anos-do-posto-meteorologico-da-esalq/</guid>
      <description>No dia 31 de dezembro de 2016 o Posto Meteorológico da ESALQ/USP completou 100 anos de funcionamento. Em “comemoração” a este belo banco de dados, pretendo fazer alguns gráficos para analisar, sem muita pretensão, como o clima variou de lá pra cá.
No site do Posto podemos encontrar os dados nas escalas diária e mensal. Separei apenas os dados mensais para vermos aqui. Fiz algumas poucas adaptações no banco para poder pelo menos iniciar a análise.</description>
      <content:encoded>
        


&lt;p&gt;No dia 31 de dezembro de 2016 o Posto Meteorológico da &lt;a href=&#34;http://www.esalq.usp.br/departamentos/leb/posto/&#34;&gt;ESALQ/USP&lt;/a&gt; completou 100 anos de funcionamento. Em “comemoração” a este belo banco de dados, pretendo fazer alguns gráficos para analisar, sem muita pretensão, como o clima variou de lá pra cá.&lt;/p&gt;
&lt;p&gt;No site do Posto podemos encontrar os dados nas escalas diária e mensal. Separei apenas os &lt;a href=&#34;http://www.esalq.usp.br/departamentos/leb/postocon.html&#34;&gt;dados mensais&lt;/a&gt; para vermos aqui. Fiz algumas poucas adaptações no banco para poder pelo menos iniciar a análise. Não considerei nenhuma consistência e preenchimento de falhas (tem bastante, o que é completamente compreensível!).&lt;/p&gt;
&lt;p&gt;Minha primeira movimentação é criar colunas para identificar o ano e as décadas, precisaremos delas mais para frente.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;if (!require(&amp;quot;pacman&amp;quot;)) install.packages(&amp;quot;pacman&amp;quot;)
pacman::p_load(readr, dplyr, RcppRoll, lubridate, stringr, ggplot2, ggridges)&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;clima &amp;lt;- read_csv2(&amp;quot;https://raw.githubusercontent.com/italocegatta/italocegatta.github.io_source/master/content/dados/posto_esalq.csv&amp;quot;) %&amp;gt;% 
  mutate(
    data = dmy(data),
    ano = year(data),
    decada_label = cut(ano, breaks = seq(1910, 2020, by = 10), dig.lab = 100, right = FALSE),
    decada = as.numeric(str_extract(decada_label, &amp;quot;[0-9]+&amp;quot;))
  )

clima&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 1,200 x 9
##    data        prec    ur t_max t_min t_med   ano decada_label decada
##    &amp;lt;date&amp;gt;     &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;fct&amp;gt;         &amp;lt;dbl&amp;gt;
##  1 1917-01-01 296.     NA  28.1  18.3  23.2  1917 [1910,1920)    1910
##  2 1917-02-01 136.     NA  28.3  18.4  23.3  1917 [1910,1920)    1910
##  3 1917-03-01  58.9    NA  28.6  16.9  22.7  1917 [1910,1920)    1910
##  4 1917-04-01 116.     NA  26.7  13.9  20.3  1917 [1910,1920)    1910
##  5 1917-05-01  58.5    NA  22.2   8.6  15.4  1917 [1910,1920)    1910
##  6 1917-06-01  13      NA  23.3   6.3  14.8  1917 [1910,1920)    1910
##  7 1917-07-01  13.3    NA  24     7.7  15.9  1917 [1910,1920)    1910
##  8 1917-08-01   5.4    NA  26.4   7.5  16.9  1917 [1910,1920)    1910
##  9 1917-09-01  62.2    NA  27.8  12.2  20    1917 [1910,1920)    1910
## 10 1917-10-01  58.4    NA  27.6  13.8  20.7  1917 [1910,1920)    1910
## # ... with 1,190 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Vou começar pela precipitação mensal. Para visualizar a distribuição dos dados a melhor abordagem é fazer um histograma. Vamos criar um histograma com intervalo de classe de 15 mm de chuva para cada mês do ano considerando os 100 anos de dados.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;clima %&amp;gt;% 
  mutate(mes = month(data)) %&amp;gt;% 
  ggplot(aes(prec, rev(factor(mes)), height = ..density..)) +
  geom_density_ridges(stat = &amp;quot;binline&amp;quot;, binwidth = 15, fill = &amp;quot;grey20&amp;quot;, color = &amp;quot;grey90&amp;quot;) +
  labs(
    x = &amp;quot;Chuva mensal (mm)&amp;quot;,
    y = &amp;quot;Mês&amp;quot;
  ) +
  scale_fill_viridis_c() +
  scale_x_continuous(breaks = seq(0,700, 30)) +
  scale_y_discrete(labels = format(ISOdate(2000, 12:1, 1), &amp;quot;%b&amp;quot;)) +
  theme_bw(16) +
  theme(panel.grid.minor = element_blank())&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://italocegatta.github.io/post/2017-10-14-100-anos-do-posto-meteorologico-da-esalq_files/figure-html/unnamed-chunk-3-1.svg&#34; width=&#34;960&#34; /&gt;&lt;/p&gt;
&lt;p&gt;E qual a década que mais choveu? Como variou a chuva anual ao longo desses 100 anos? Primeiro precisamos calcular quanto choveu em cada década. Em seguida vamos calcular quanto choveu em cada ano e juntar as duas informações. No gráfico abaixo, representei a média da década numa linha de tendência suavizada. Notem que a seca de 2014 Não foi a maior do século, houveram outros 4 anos mais secos desde de 1917.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;prec_decada &amp;lt;- clima %&amp;gt;% 
  group_by(decada, ano) %&amp;gt;% 
  summarise(prec = sum(prec)) %&amp;gt;% 
  group_by(decada) %&amp;gt;% 
  summarise(prec = mean(prec)) 

clima %&amp;gt;% 
  group_by(decada, ano) %&amp;gt;% 
  summarise(prec = sum(prec)) %&amp;gt;% 
  ungroup() %&amp;gt;% 
  ggplot(aes(ano, prec)) +
    geom_line() +
    geom_point() +
    geom_smooth(
      data = prec_decada,
      aes(decada + 5, prec)
    ) +
    labs(
      x = &amp;quot;Ano&amp;quot;,
      y = &amp;quot;Precipitação anual (mm)&amp;quot;
    ) +
    scale_x_continuous(breaks = seq(1917, 2017, 10)) +
    theme_bw(16)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://italocegatta.github.io/post/2017-10-14-100-anos-do-posto-meteorologico-da-esalq_files/figure-html/unnamed-chunk-4-1.svg&#34; width=&#34;960&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Passando para a temperatura média, podemos construir um painel com a densidade de probabilidade para valores que variam entre 12,5 a 27,7 (amplitude dos dados).&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggplot(clima, aes(t_med)) +
  geom_density(fill = &amp;quot;cadetblue&amp;quot;, alpha = 0.8) +
  facet_wrap(~ano) +
  labs(
    x = &amp;quot;Temperatura média mensal (°C)&amp;quot;,
    y = &amp;quot;Densidade&amp;quot;
  ) +
  theme_bw(9)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://italocegatta.github.io/post/2017-10-14-100-anos-do-posto-meteorologico-da-esalq_files/figure-html/unnamed-chunk-5-1.svg&#34; width=&#34;960&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Considerando as décadas, podemos fazer um gráfico um pouco mais simples para facilitar a visualização. Agora, cada década tem sua distribuição de probabilidade. Aparentemente, a calda da direita está se deslocando para maiores temperaturas.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggplot(clima, aes(t_med, factor(decada), fill = ..x..)) +
  geom_density_ridges_gradient(show.legend = FALSE, color = &amp;quot;white&amp;quot;) +
  labs(
    x = &amp;quot;Temperatura média mensal (°C)&amp;quot;,
    y = &amp;quot;Década&amp;quot;
  ) +
  scale_fill_viridis_c() +
  theme_bw(9)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://italocegatta.github.io/post/2017-10-14-100-anos-do-posto-meteorologico-da-esalq_files/figure-html/unnamed-chunk-6-1.png&#34; width=&#34;960&#34; /&gt;&lt;/p&gt;
&lt;p&gt;E quanto a variação da temperatura nos meses do ano? Quanto podemos esperar de frio ou calor em cada mês?&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;clima %&amp;gt;% 
  mutate(mes = month(data)) %&amp;gt;% 
  ggplot(aes(t_med, rev(factor(mes)),  fill = ..x..)) +
  geom_density_ridges_gradient(color = &amp;quot;white&amp;quot;, show.legend = FALSE) +
  labs(
    x = &amp;quot;Temperatura média mensal (°C)&amp;quot;,
    y = &amp;quot;Mês&amp;quot;
  ) +
  scale_fill_viridis_c() +
  scale_x_continuous(breaks = seq(0,40, 4)) +
  scale_y_discrete(labels = format(ISOdate(2000, 12:1, 1), &amp;quot;%b&amp;quot;)) +
  theme_bw(16)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://italocegatta.github.io/post/2017-10-14-100-anos-do-posto-meteorologico-da-esalq_files/figure-html/unnamed-chunk-7-1.png&#34; width=&#34;960&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Podemos também visualizar a amplitude da temperatura máxima e mínima ao longo dos anos.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggplot(clima, aes(month(data))) +
  geom_ribbon(aes(ymax = t_max, ymin = t_min), alpha = 0.8) +
  facet_wrap(~ano) +
  labs(
    x = &amp;quot;Mês&amp;quot;,
    y = &amp;quot;Amplitude da temperatura mínima e máxima mensal (°C)&amp;quot;
  ) +
  scale_x_continuous(
    breaks = seq(1, 12, 2), 
    labels = format(ISOdate(2000, seq(1, 12, 2), 1), &amp;quot;%b&amp;quot;)
  ) +
  theme_bw(10)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://italocegatta.github.io/post/2017-10-14-100-anos-do-posto-meteorologico-da-esalq_files/figure-html/unnamed-chunk-8-1.svg&#34; width=&#34;1248&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Para finalizar, vamos calcular a média móvel de 30 anos para a temperatura média. Sem dúvida, dos anos 90 pra cá a temperatura média só vem subindo. A minha grande dúvida é: como será que a produção de alimentos e biomassa vai se comportar com essa mudança de clima? Será um grande desafio para a nossa geração, sem dúvida.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;clima_normal &amp;lt;- clima %&amp;gt;%
  filter(!is.na(t_med)) %&amp;gt;% 
  group_by(ano = year(data)) %&amp;gt;%
  summarise(t_med = mean(t_med, na.rm = TRUE)) %&amp;gt;% 
  ungroup() %&amp;gt;% 
  mutate(t_med_movel = roll_mean(t_med, 30, align = &amp;quot;right&amp;quot;, fill = NA)) %&amp;gt;% 
  filter(!is.na(t_med_movel))

ggplot(clima_normal, aes(t_med_movel, ano)) +
  geom_path() +
  geom_point(shape = 21, color = &amp;quot;white&amp;quot;, fill = &amp;quot;black&amp;quot;, alpha = 0.8, size = 4) +
    labs(
    x = &amp;quot;Média móvel da temperatura média (°C)&amp;quot;,
    y = &amp;quot;Ano&amp;quot;
  ) +
  scale_y_reverse(breaks = seq(1940, 2017, by = 5)) +
  theme_bw(16)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://italocegatta.github.io/post/2017-10-14-100-anos-do-posto-meteorologico-da-esalq_files/figure-html/unnamed-chunk-9-1.svg&#34; width=&#34;960&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Caso tenha alguma dúvida ou sugestão sobre o post, fique à vontade para fazer um comentário ou me contatar por E-mail.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;sessioninfo::session_info(c(&amp;quot;readr&amp;quot;, &amp;quot;dplyr&amp;quot;, &amp;quot;ggplot2&amp;quot;, &amp;quot;RcppRoll&amp;quot;, &amp;quot;lubridate&amp;quot;, &amp;quot;stringr&amp;quot;, &amp;quot;ggridges&amp;quot;))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## - Session info ----------------------------------------------------------
##  setting  value                       
##  version  R version 3.5.3 (2019-03-11)
##  os       Windows 10 x64              
##  system   x86_64, mingw32             
##  ui       RTerm                       
##  language (EN)                        
##  collate  Portuguese_Brazil.1252      
##  ctype    Portuguese_Brazil.1252      
##  tz       America/Sao_Paulo           
##  date     2019-08-25                  
## 
## - Packages --------------------------------------------------------------
##  package      * version  date       lib source        
##  assertthat     0.2.1    2019-03-21 [1] CRAN (R 3.5.3)
##  backports      1.1.4    2019-04-10 [1] CRAN (R 3.5.3)
##  BH             1.69.0-1 2019-01-07 [1] CRAN (R 3.5.2)
##  cli            1.1.0    2019-03-19 [1] CRAN (R 3.5.3)
##  clipr          0.7.0    2019-07-23 [1] CRAN (R 3.5.3)
##  colorspace     1.4-1    2019-03-18 [1] CRAN (R 3.5.3)
##  crayon         1.3.4    2017-09-16 [1] CRAN (R 3.5.1)
##  digest         0.6.20   2019-07-04 [1] CRAN (R 3.5.3)
##  dplyr        * 0.8.3    2019-07-04 [1] CRAN (R 3.5.3)
##  ellipsis       0.2.0.1  2019-07-02 [1] CRAN (R 3.5.3)
##  fansi          0.4.0    2018-10-05 [1] CRAN (R 3.5.1)
##  ggplot2      * 3.2.1    2019-08-10 [1] CRAN (R 3.5.3)
##  ggridges     * 0.5.1    2018-09-27 [1] CRAN (R 3.5.2)
##  glue           1.3.1    2019-03-12 [1] CRAN (R 3.5.3)
##  gtable         0.3.0    2019-03-25 [1] CRAN (R 3.5.3)
##  hms            0.5.0    2019-07-09 [1] CRAN (R 3.5.3)
##  labeling       0.3      2014-08-23 [1] CRAN (R 3.5.0)
##  lattice        0.20-38  2018-11-04 [2] CRAN (R 3.5.3)
##  lazyeval       0.2.2    2019-03-15 [1] CRAN (R 3.5.3)
##  lubridate    * 1.7.4    2018-04-11 [1] CRAN (R 3.5.1)
##  magrittr       1.5      2014-11-22 [1] CRAN (R 3.5.1)
##  MASS           7.3-51.1 2018-11-01 [2] CRAN (R 3.5.3)
##  Matrix         1.2-17   2019-03-22 [1] CRAN (R 3.5.3)
##  mgcv           1.8-28   2019-03-21 [1] CRAN (R 3.5.3)
##  munsell        0.5.0    2018-06-12 [1] CRAN (R 3.5.1)
##  nlme           3.1-137  2018-04-07 [2] CRAN (R 3.5.3)
##  pillar         1.4.2    2019-06-29 [1] CRAN (R 3.5.3)
##  pkgconfig      2.0.2    2018-08-16 [1] CRAN (R 3.5.1)
##  plogr          0.2.0    2018-03-25 [1] CRAN (R 3.5.1)
##  plyr           1.8.4    2016-06-08 [1] CRAN (R 3.5.1)
##  purrr          0.3.2    2019-03-15 [1] CRAN (R 3.5.3)
##  R6             2.4.0    2019-02-14 [1] CRAN (R 3.5.2)
##  RColorBrewer   1.1-2    2014-12-07 [1] CRAN (R 3.5.0)
##  Rcpp           1.0.2    2019-07-25 [1] CRAN (R 3.5.3)
##  RcppRoll     * 0.3.0    2018-06-05 [1] CRAN (R 3.5.2)
##  readr        * 1.3.1    2018-12-21 [1] CRAN (R 3.5.2)
##  reshape2       1.4.3    2017-12-11 [1] CRAN (R 3.5.1)
##  rlang          0.4.0    2019-06-25 [1] CRAN (R 3.5.3)
##  scales         1.0.0    2018-08-09 [1] CRAN (R 3.5.1)
##  stringi        1.4.3    2019-03-12 [1] CRAN (R 3.5.3)
##  stringr      * 1.4.0    2019-02-10 [1] CRAN (R 3.5.2)
##  tibble         2.1.3    2019-06-06 [1] CRAN (R 3.5.3)
##  tidyselect     0.2.5    2018-10-11 [1] CRAN (R 3.5.1)
##  utf8           1.1.4    2018-05-24 [1] CRAN (R 3.5.1)
##  vctrs          0.2.0    2019-07-05 [1] CRAN (R 3.5.3)
##  viridisLite    0.3.0    2018-02-01 [1] CRAN (R 3.5.1)
##  withr          2.1.2    2018-03-15 [1] CRAN (R 3.5.1)
##  zeallot        0.1.0    2018-01-28 [1] CRAN (R 3.5.2)
## 
## [1] C:/Users/Italo/Documents/R/win-library/3.5
## [2] C:/Program Files/R/R-3.5.3/library&lt;/code&gt;&lt;/pre&gt;

      </content:encoded>
    </item>
    
    <item>
      <title>Engenheiro Florestal ou Cientista de Dados?</title>
      <link>https://italocegatta.github.io/engenheiro-florestal-ou-cientista-de-dados/</link>
      <pubDate>Sun, 03 Sep 2017 00:00:00 +0000</pubDate>
      
      <guid>https://italocegatta.github.io/engenheiro-florestal-ou-cientista-de-dados/</guid>
      <description>No meio do colegial tive a sorte de ser ‘convencido’ por um amigo da família que Engenharia Florestal seria uma ótima profissão para mim. Vocês sabem que um jovem de 16 anos pouco sabe sobre o mercado de trabalho. Naquela época o único contato profissional que tive foi como menor aprendiz numa concessionária de veículos.
Chegando na ESALQ para o curso de Eng. Florestal, a primeira coisa que eu fiz foi entrar no Grupo Florestal Monte Olimpo (GFMO).</description>
      <content:encoded>
        


&lt;p&gt;No meio do colegial tive a sorte de ser ‘convencido’ por um amigo da família que Engenharia Florestal seria uma ótima profissão para mim. Vocês sabem que um jovem de 16 anos pouco sabe sobre o mercado de trabalho. Naquela época o único contato profissional que tive foi como menor aprendiz numa concessionária de veículos.&lt;/p&gt;
&lt;p&gt;Chegando na &lt;a href=&#34;http://www.esalq.usp.br/&#34;&gt;ESALQ&lt;/a&gt; para o curso de Eng. Florestal, a primeira coisa que eu fiz foi entrar no &lt;a href=&#34;http://www.gfmo.esalq.usp.br/&#34;&gt;Grupo Florestal Monte Olimpo (GFMO)&lt;/a&gt;. De certa forma foi fácil decidir que lá seria um lugar legal para começar a conhecer sobre Floresta, pois uma semana antes de começarem as aulas eu fui numa república e me falaram que “o pessoal do GFMO trabalhava demais”. “São escravos”. “Loucos”. Então, no dia 13 de março de 2012 eu comecei GFMO.&lt;/p&gt;
&lt;p&gt;Uma das minhas primeiras atividades externas como integrante do GFMO foi participar de um inventário de Pinus na Estação de Experimental de Itatinga. Foi lá que escrevi minha primeira fórmula no Excel e me mostraram que eu poderia arrastar a fórmula de uma célula para todas as outras na mesma coluna. Foi mágico.&lt;/p&gt;
&lt;p&gt;No começo do 2º semestre do curso, fui selecionado para uma bolsa de iniciação científica cujo objetivo era trabalhar com uma base de dados qualquer num software estatístico chamado R. Eu já tinha escutado sobre este software, mas não fazia ideia de como ele funcionava. No fim do ano eu já tinha montado um experimento no viveiro do GFMO, coletado os dados, processado no R e submetido um resumo que, alguns meses depois, seria meu primeiro artigo publicado.&lt;/p&gt;
&lt;p&gt;Meu primeiro ano de curso foi extremamente esclarecedor. Primeiro, o curso de Eng. Florestal tinha superado todas as minhas expectativas e tinha certeza que estava no lugar certo. Segundo, eu tinha descoberto um hobby programando no R, algo completamente inusitado para quem sabia muito pouco sobre computadores e muito menos de estatística e análise de dados.&lt;/p&gt;
&lt;p&gt;Eu não sei bem quando foi, mas no meio do curso eu já tinha certeza que queria trabalhar na área quantitativa, com dados, programação e estatística. Era muito claro para mim, eu via gráficos em tudo, tinha ideias de experimentos na aula de fisiologia, me oferecia para processar os dados dos trabalhos em grupo, passava a noite rodando exemplos de livros e apostilas sobre o R.&lt;/p&gt;
&lt;p&gt;Me formei no fim de 2016 e em seguida comecei a trabalhar na Suzano na área de Biometria e Modelagem Ecofisiológica. Hoje, todos os meus projetos estão de alguma forma relacionados ao R. Parece um sonho, meu hobby se tornou meu trabalho e principal desafio profissional.&lt;/p&gt;
&lt;p&gt;Já tem um tempo que eu encontro dificuldade em explicar o que eu faço na Suzano. Quando você fala para o seu tio que se formou em Eng. Florestal, mas que trabalha no escritório escrevendo linhas de comandos, construindo aplicativos interativos, relatórios automáticos… isso não faz muito sentido para ele. Para o cidadão, o Eng. Florestal mora na floresta, especificamente numa casa de madeira no alto de uma árvore.&lt;/p&gt;
&lt;p&gt;Surgiu recentemente uma denominação de mercado que descreve bem o que eu faço: Ciência de dados. Um Cientista de dados, profissão bastante popular nos EUA e começando a ganhar corpo no Brasil, é aquela pessoa que domina um assunto específico, sabe com aborda-lo de forma matemática e consegue programar isto dentro do computador. Para cada caso, o nível de domínio e utilização de cada um destes campos será diferente. Mas essencialmente não tem como fazer ciência de dados sem um domínio mínimo destes três pilares.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://i.imgur.com/VVTKio6.png&#34; /&gt;&lt;!-- --&gt;&lt;/p&gt;
&lt;p&gt;Mas e a Floresta? Abandonou? Felizmente não. Além de toda a minha paixão e motivação de trabalhar na área florestal, eu tenho claro que não poderia ser um cientista de dados em outro lugar, justamente por não ter o conhecimento técnico. Eu poderia migrar para a área de saúde pública, por exemplo, mas levaria um tempo para trabalhar com ciência de dados por desconhecer o setor, suas particularidades, características, processos e etc. Sem conhecimento técnico a ferramenta (estatística e programação) fica meio capenga, sem brilho, sem direção.&lt;/p&gt;
&lt;p&gt;Para o setor florestal, a profissão/perfil de cientista de dados é praticamente desconhecida, embora muitos profissionais se encaixem nesse perfil. Há muitas pessoas falando de Big Data, mas tem pouca gente transformando dados em sabedoria, em conhecimento, em produtos concretos… em ciência de verdade.&lt;/p&gt;
&lt;p&gt;Há seis anos eu estava me preparando para entrar na faculdade, mal sabia abrir o Excel e pensava que estatística era média, mediana e moda. Hoje, recém-formado, me sinto extremamente motivado a me desenvolver para resolver problemas relacionados às ciências florestais.&lt;/p&gt;

      </content:encoded>
    </item>
    
    <item>
      <title>Como um cientista de dados pesquisa o carro que quer comprar?</title>
      <link>https://italocegatta.github.io/como-um-cientista-de-dados-pesquisa-o-carro-que-quer-comprar/</link>
      <pubDate>Sat, 29 Jul 2017 00:00:00 +0000</pubDate>
      
      <guid>https://italocegatta.github.io/como-um-cientista-de-dados-pesquisa-o-carro-que-quer-comprar/</guid>
      <description>Estou naquela parte da vida em que se planeja comprar um carro. Como eu sou, acima de todos os sonhos, pão duro, decidir qual marca, modelo, versão e ano do veículo não vai ser fácil. Pensando nisso resolvi escrever o pacote fipe no R para me ajudar a tomar esta decisão. O objetivo deste post é apresentar o pacote e as funções que auxiliam na coleta das informações da tabela FIPE.</description>
      <content:encoded>
        


&lt;p&gt;Estou naquela parte da vida em que se planeja comprar um carro. Como eu sou, acima de todos os sonhos, pão duro, decidir qual marca, modelo, versão e ano do veículo não vai ser fácil. Pensando nisso resolvi escrever o pacote &lt;a href=&#34;https://cran.r-project.org/web/packages/fipe/index.html&#34;&gt;fipe&lt;/a&gt; no R para me ajudar a tomar esta decisão. O objetivo deste post é apresentar o pacote e as funções que auxiliam na coleta das informações da tabela &lt;a href=&#34;http://veiculos.fipe.org.br/&#34;&gt;FIPE&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Para aqueles que já passaram pela etapa de compra ou venda de um carro, provavelmente já consultaram a famosa tabela. Nas palavras do próprio site da FIPE:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A Tabela Fipe expressa preços médios de veículos no mercado nacional, servindo apenas como um parâmetro para negociações ou avaliações. Os preços efetivamente praticados variam em função da região, conservação, cor, acessórios ou qualquer outro fator que possa influenciar as condições de oferta e procura por um veículo específico.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;if (!require(&amp;quot;pacman&amp;quot;)) install.packages(&amp;quot;pacman&amp;quot;)
pacman::p_load(dplyr, purrr, stringr, tidyr, forcats, ggplot2, fipe)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Primeiro vou mostrar as funções e o workflow idealizado para o pacote. Queremos saber, por enquanto, o preço de uma BMW X6 M ano 2015 em julho de 2017.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# acesso aos dados no site da fipe
bmw_x6_m_2015 &amp;lt;- fipe_vehicle(
  model = &amp;quot;x6 m&amp;quot;, make = &amp;quot;bmw&amp;quot;, 
  year = 2015,  date = &amp;quot;2017-07-01&amp;quot;
)

bmw_x6_m_2015&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 1 x 5
##   model                             make  year  date        price
##   &amp;lt;chr&amp;gt;                             &amp;lt;chr&amp;gt; &amp;lt;fct&amp;gt; &amp;lt;date&amp;gt;      &amp;lt;dbl&amp;gt;
## 1 X6 M 4.4 4x4 V8 32V Bi-Turbo Aut. BMW   2015  2017-07-01 368603&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Achamos o preço do carro que eu queria. Apenas R$ 368 mil. Uma pechincha. Obviamente, saber quanto vale uma BMW X6 não faz diferença alguma no meu dia. Um abraço pra quem tem condições de comprar um carro desse sem precisar vender um rim.&lt;/p&gt;
&lt;p&gt;Agora que já conhecemos a função que pega o valor dos carros, vamos ampliar a consulta e justificar as horas que passamos aprendendo a programar. Já sabemos o preço do X6 M em julho/2017, mas e nos meses anteriores? Como foi a depreciação média do carro usado nos últimos meses? E os outros modelos X6, quanto será que estão valendo?&lt;/p&gt;
&lt;p&gt;Digamos que, agora, estas questões podem ser respondidas de forma bem rápida. Calma que eu mostro. Modificando a consulta anterior, iremos simplificar o nome do modelo para apenas x6, assim serão retornadas todas as versões do mesmo. A segunda alteração é a ausência do ano de fabricação, o que significa que serão retornados todos os anos na consulta. E por último, definimos os meses de referência para poder acompanhar a variação do preço ao longo nos anos.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;bmw_x6 &amp;lt;- fipe_vehicle(
  model = &amp;quot;x6&amp;quot;, make = &amp;quot;bmw&amp;quot;, 
  date = seq.Date(as.Date(&amp;quot;2009-01-01&amp;quot;), as.Date(&amp;quot;2017-07-01&amp;quot;), by = &amp;quot;4 months&amp;quot;)
)

bmw_x6&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 480 x 5
##    model                             make  year  date        price
##    &amp;lt;chr&amp;gt;                             &amp;lt;chr&amp;gt; &amp;lt;fct&amp;gt; &amp;lt;date&amp;gt;      &amp;lt;dbl&amp;gt;
##  1 X6 M 4.4 4x4 V8 32V Bi-Turbo Aut. BMW   0 km  2010-05-01 477030
##  2 X6 M 4.4 4x4 V8 32V Bi-Turbo Aut. BMW   0 km  2010-09-01 465300
##  3 X6 M 4.4 4x4 V8 32V Bi-Turbo Aut. BMW   0 km  2011-01-01 468543
##  4 X6 M 4.4 4x4 V8 32V Bi-Turbo Aut. BMW   0 km  2011-05-01 459500
##  5 X6 M 4.4 4x4 V8 32V Bi-Turbo Aut. BMW   0 km  2011-09-01 462000
##  6 X6 M 4.4 4x4 V8 32V Bi-Turbo Aut. BMW   0 km  2012-01-01 464510
##  7 X6 M 4.4 4x4 V8 32V Bi-Turbo Aut. BMW   0 km  2012-05-01 558789
##  8 X6 M 4.4 4x4 V8 32V Bi-Turbo Aut. BMW   0 km  2012-09-01 573333
##  9 X6 M 4.4 4x4 V8 32V Bi-Turbo Aut. BMW   0 km  2013-01-01 550000
## 10 X6 M 4.4 4x4 V8 32V Bi-Turbo Aut. BMW   0 km  2013-05-01 494950
## # ... with 470 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Lembrando que o pacote não possui nenhum banco de dados armazenado, todas as informações são consultadas no site da tabela FIPE no ato da execução da função. Se sua internet não for muito rápida, pode ser que tenha demorado um pouquinho. Mas agora temos o banco de dados desejado. Imagina coletar estes dados, na mão, pelo site oficial!?!&lt;/p&gt;
&lt;p&gt;Bom agora o pacote está apresentado. Pretendo fazer outros posts com estudos de casos mais específicos, portanto vou deixar apenas um gráfico que resume a consulta que acabamos de fazer.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;bmw_x6 %&amp;gt;%
  ggplot(aes(date, price, color = year, group = year)) +
    geom_line(color = &amp;quot;grey30&amp;quot;) +
    geom_point(size = 3) +
    facet_wrap(~model) +
    labs(
      x = &amp;quot;Mês de refêrencia&amp;quot;,
      y = &amp;quot;Valor (R$)&amp;quot;,
      color = &amp;quot;Ano do \nmodelo&amp;quot;
    ) +
    scale_y_continuous(breaks = seq(0, 700000, 50000), labels = scales::dollar_format(prefix = NULL, big.mark = &amp;quot;.&amp;quot;)) +
    scale_x_date(date_breaks = &amp;quot;1 year&amp;quot;, date_labels = &amp;quot;%b/%y&amp;quot;) +
    scale_color_viridis_d() +
    theme_bw() +
    theme(legend.position = &amp;quot;top&amp;quot;) &lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://italocegatta.github.io/post/2017-07-29-como-um-cientista-de-dados-pesquisa-o-carro-que-quer-comprar_files/figure-html/unnamed-chunk-4-1.svg&#34; width=&#34;960&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Caso tenha alguma dúvida ou sugestão sobre o post, fique à vontade para fazer um comentário ou me contatar por E-mail.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;sessioninfo::session_info(c(&amp;quot;readr&amp;quot;, &amp;quot;dplyr&amp;quot;, &amp;quot;ggplot2&amp;quot;, &amp;quot;purrr&amp;quot;, &amp;quot;stringr&amp;quot;, &amp;quot;tidyr&amp;quot;, &amp;quot;forcats&amp;quot;, &amp;quot;fipe&amp;quot;))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## - Session info ----------------------------------------------------------
##  setting  value                       
##  version  R version 3.5.3 (2019-03-11)
##  os       Windows 10 x64              
##  system   x86_64, mingw32             
##  ui       RTerm                       
##  language (EN)                        
##  collate  Portuguese_Brazil.1252      
##  ctype    Portuguese_Brazil.1252      
##  tz       America/Sao_Paulo           
##  date     2019-08-25                  
## 
## - Packages --------------------------------------------------------------
##  package      * version  date       lib source        
##  askpass        1.1      2019-01-13 [1] CRAN (R 3.5.2)
##  assertthat     0.2.1    2019-03-21 [1] CRAN (R 3.5.3)
##  backports      1.1.4    2019-04-10 [1] CRAN (R 3.5.3)
##  BH             1.69.0-1 2019-01-07 [1] CRAN (R 3.5.2)
##  cli            1.1.0    2019-03-19 [1] CRAN (R 3.5.3)
##  clipr          0.7.0    2019-07-23 [1] CRAN (R 3.5.3)
##  codetools      0.2-16   2018-12-24 [2] CRAN (R 3.5.3)
##  colorspace     1.4-1    2019-03-18 [1] CRAN (R 3.5.3)
##  crayon         1.3.4    2017-09-16 [1] CRAN (R 3.5.1)
##  curl           4.0      2019-07-22 [1] CRAN (R 3.5.3)
##  digest         0.6.20   2019-07-04 [1] CRAN (R 3.5.3)
##  dplyr        * 0.8.3    2019-07-04 [1] CRAN (R 3.5.3)
##  ellipsis       0.2.0.1  2019-07-02 [1] CRAN (R 3.5.3)
##  fansi          0.4.0    2018-10-05 [1] CRAN (R 3.5.1)
##  fipe         * 0.0.1    2019-08-25 [1] CRAN (R 3.5.3)
##  forcats      * 0.4.0    2019-02-17 [1] CRAN (R 3.5.2)
##  furrr          0.1.0    2018-05-16 [1] CRAN (R 3.5.1)
##  future         1.14.0   2019-07-02 [1] CRAN (R 3.5.3)
##  ggplot2      * 3.2.1    2019-08-10 [1] CRAN (R 3.5.3)
##  globals        0.12.4   2018-10-11 [1] CRAN (R 3.5.1)
##  glue           1.3.1    2019-03-12 [1] CRAN (R 3.5.3)
##  gtable         0.3.0    2019-03-25 [1] CRAN (R 3.5.3)
##  hms            0.5.0    2019-07-09 [1] CRAN (R 3.5.3)
##  httr           1.4.1    2019-08-05 [1] CRAN (R 3.5.3)
##  jsonlite       1.6      2018-12-07 [1] CRAN (R 3.5.2)
##  labeling       0.3      2014-08-23 [1] CRAN (R 3.5.0)
##  lattice        0.20-38  2018-11-04 [2] CRAN (R 3.5.3)
##  lazyeval       0.2.2    2019-03-15 [1] CRAN (R 3.5.3)
##  listenv        0.7.0    2018-01-21 [1] CRAN (R 3.5.1)
##  lubridate      1.7.4    2018-04-11 [1] CRAN (R 3.5.1)
##  magrittr       1.5      2014-11-22 [1] CRAN (R 3.5.1)
##  MASS           7.3-51.1 2018-11-01 [2] CRAN (R 3.5.3)
##  Matrix         1.2-17   2019-03-22 [1] CRAN (R 3.5.3)
##  mgcv           1.8-28   2019-03-21 [1] CRAN (R 3.5.3)
##  mime           0.7      2019-06-11 [1] CRAN (R 3.5.3)
##  munsell        0.5.0    2018-06-12 [1] CRAN (R 3.5.1)
##  nlme           3.1-137  2018-04-07 [2] CRAN (R 3.5.3)
##  openssl        1.4.1    2019-07-18 [1] CRAN (R 3.5.3)
##  pillar         1.4.2    2019-06-29 [1] CRAN (R 3.5.3)
##  pkgconfig      2.0.2    2018-08-16 [1] CRAN (R 3.5.1)
##  plogr          0.2.0    2018-03-25 [1] CRAN (R 3.5.1)
##  plyr           1.8.4    2016-06-08 [1] CRAN (R 3.5.1)
##  purrr        * 0.3.2    2019-03-15 [1] CRAN (R 3.5.3)
##  R6             2.4.0    2019-02-14 [1] CRAN (R 3.5.2)
##  RColorBrewer   1.1-2    2014-12-07 [1] CRAN (R 3.5.0)
##  Rcpp           1.0.2    2019-07-25 [1] CRAN (R 3.5.3)
##  readr          1.3.1    2018-12-21 [1] CRAN (R 3.5.2)
##  reshape2       1.4.3    2017-12-11 [1] CRAN (R 3.5.1)
##  rlang          0.4.0    2019-06-25 [1] CRAN (R 3.5.3)
##  scales         1.0.0    2018-08-09 [1] CRAN (R 3.5.1)
##  stringi        1.4.3    2019-03-12 [1] CRAN (R 3.5.3)
##  stringr      * 1.4.0    2019-02-10 [1] CRAN (R 3.5.2)
##  sys            3.2      2019-04-23 [1] CRAN (R 3.5.3)
##  tibble         2.1.3    2019-06-06 [1] CRAN (R 3.5.3)
##  tidyr        * 0.8.3    2019-03-01 [1] CRAN (R 3.5.3)
##  tidyselect     0.2.5    2018-10-11 [1] CRAN (R 3.5.1)
##  utf8           1.1.4    2018-05-24 [1] CRAN (R 3.5.1)
##  vctrs          0.2.0    2019-07-05 [1] CRAN (R 3.5.3)
##  viridisLite    0.3.0    2018-02-01 [1] CRAN (R 3.5.1)
##  withr          2.1.2    2018-03-15 [1] CRAN (R 3.5.1)
##  zeallot        0.1.0    2018-01-28 [1] CRAN (R 3.5.2)
## 
## [1] C:/Users/Italo/Documents/R/win-library/3.5
## [2] C:/Program Files/R/R-3.5.3/library&lt;/code&gt;&lt;/pre&gt;

      </content:encoded>
    </item>
    
    <item>
      <title>Gráficos com dimensão espacial e temporal</title>
      <link>https://italocegatta.github.io/graficos-com-dimensao-espacial-e-temporal/</link>
      <pubDate>Sat, 08 Jul 2017 00:00:00 +0000</pubDate>
      
      <guid>https://italocegatta.github.io/graficos-com-dimensao-espacial-e-temporal/</guid>
      <description>O post de hoje é sobre visualização de dados com dimensão espacial e temporal. Basicamente são gráficos que têm uma representação geográfica associada a informações que variam no tempo. Este tipo de análise é comum no meu dia a dia e por isso resolvi deixar 3 alternativas registradas aqui. O contexto que iremos abordar está relacionado ao banco de dados de focos de incêndios registrados pelo INPE no Programa Queimadas Monitoramento por Satélites.</description>
      <content:encoded>
        


&lt;p&gt;O post de hoje é sobre visualização de dados com dimensão espacial e temporal. Basicamente são gráficos que têm uma representação geográfica associada a informações que variam no tempo. Este tipo de análise é comum no meu dia a dia e por isso resolvi deixar 3 alternativas registradas aqui. O contexto que iremos abordar está relacionado ao banco de dados de focos de incêndios registrados pelo INPE no &lt;a href=&#34;http://www.inpe.br/queimadas/situacao-atual&#34;&gt;Programa Queimadas Monitoramento por Satélites&lt;/a&gt;. O site é bem interessante e apresenta algumas estatísticas úteis sobre as queimadas na América do Sul e Brasil. Iremos trabalhar com a tabela que resume os focos de incêndios por ano e Estado brasileiro.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;if (!require(&amp;quot;pacman&amp;quot;)) install.packages(&amp;quot;pacman&amp;quot;)
pacman::p_load(readr, dplyr, sf, ggplot2, ggthemes, geofacet, scales)
pacman::p_load_gh(&amp;quot;italocegatta/brmap&amp;quot;)
pacman::p_load_gh(&amp;quot;thomasp85/gganimate&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;O primeiro passo foi copiar os dados da página e organizá-los no formato &lt;a href=&#34;https://italocegatta.github.io/o-conceito-tidy-data/&#34;&gt;tidy&lt;/a&gt;. Poderíamos fazer uma análise exploratória dos dados, mas quero manter o foco em algo bem pontual: como mostrar os dados brutos de uma só vez? Ou seja, considerando a dimensão de tempo (ano), geografia (localização do estado) e variável resposta (focos) na mesma janela gráfica, de que forma poderíamos apresentar os dados?&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;focos &amp;lt;- read_csv2(&amp;quot;https://raw.githubusercontent.com/italocegatta/italocegatta.github.io_source/master/content/dados/base_incendios.csv&amp;quot;)

focos&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 162 x 3
##    sigla   ano focos
##    &amp;lt;chr&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt;
##  1 AC     2011    13
##  2 AL     2011   127
##  3 AM     2011   159
##  4 AP     2011     5
##  5 BA     2011   883
##  6 CE     2011    44
##  7 DF     2011     8
##  8 ES     2011    55
##  9 GO     2011   492
## 10 MA     2011   656
## # ... with 152 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Vamos agora adicionar a referência espacial aos dados utilizando os polígonos do pacote &lt;a href=&#34;https://github.com/italocegatta/brmap&#34;&gt;brmap&lt;/a&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;estados_focos &amp;lt;-  focos %&amp;gt;% 
  left_join(brmap_estado_simples, by = c(&amp;quot;sigla&amp;quot; = &amp;quot;estado_sigla&amp;quot;)) %&amp;gt;% 
  st_as_sf()

estados_focos&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Simple feature collection with 162 features and 6 fields
## geometry type:  POLYGON
## dimension:      XY
## bbox:           xmin: -73.99045 ymin: -33.75077 xmax: -34.79288 ymax: 5.271841
## epsg (SRID):    4674
## proj4string:    +proj=longlat +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +no_defs
## # A tibble: 162 x 7
##    sigla   ano focos estado_cod regiao_cod estado_nome
##    &amp;lt;chr&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt;      &amp;lt;int&amp;gt;      &amp;lt;int&amp;gt; &amp;lt;chr&amp;gt;      
##  1 AC     2011    13         12          1 Acre       
##  2 AL     2011   127         27          2 Alagoas    
##  3 AM     2011   159         13          1 Amazonas   
##  4 AP     2011     5         16          1 Amapá      
##  5 BA     2011   883         29          2 Bahia      
##  6 CE     2011    44         23          2 Ceará      
##  7 DF     2011     8         53          5 Distrito F~
##  8 ES     2011    55         32          3 Espírito S~
##  9 GO     2011   492         52          5 Goiás      
## 10 MA     2011   656         21          2 Maranhão   
## # ... with 152 more rows, and 1 more variable: geometry &amp;lt;POLYGON [°]&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A primeira abordagem vai utilizar o pacote &lt;a href=&#34;https://github.com/hafen/geofacet&#34;&gt;geofacet&lt;/a&gt;. Ele permite criarmos um grid de referência para orientar a função &lt;code&gt;facet_wrap&lt;/code&gt; de &lt;code&gt;ggplot2&lt;/code&gt;. O pacote já vem carregado com um grid do Brasil, o &lt;code&gt;br_grid1&lt;/code&gt;, mas você pode construir e utilizar seu próprio grid. Eu, particularmente, gosto desta representação pois é extremamente flexível e comporta uma infinidade de gráficos (linhas, pontos, barras…) e dimensões (color, shape, size…). O gráfico &lt;a href=&#34;#fig:focos-geofacet&#34;&gt;1&lt;/a&gt; está bem simples mas cumpre seu papel em facilitar a percepção da variação anual e dar uma noção da região espacial do Estado no Brasil.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggplot(estados_focos, aes(ano, focos)) +
  geom_line() +
  facet_geo(~estado_nome, grid = br_states_grid1) +
  labs(
    x = &amp;quot;Ano&amp;quot;,
    y = &amp;quot;Nº de focos de incêndios&amp;quot;
  ) +
  scale_x_continuous(breaks = 2011:2017, labels = 11:17) +
  scale_y_continuous(label = unit_format(unit = &amp;quot;k&amp;quot;, scale = 1e-3)) +
  theme_bw()&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;figure&#34;&gt;&lt;span id=&#34;fig:focos-geofacet&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;https://italocegatta.github.io/post/2017-07-08-graficos-com-dimensao-espacial-e-temporal_files/figure-html/focos-geofacet-1.svg&#34; alt=&#34;Representação em painel orientado utilizando linhas.&#34; width=&#34;960&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figura  1: Representação em painel orientado utilizando linhas.
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;A segunda abordagem é relativamente simples e intuitiva. Construiremos um mapa temático utilizando o Nº de focos como escala de cor, mas organizado em um painel que tem como base o ano de registro. O gráfico &lt;a href=&#34;#fig:focos-facet&#34;&gt;2&lt;/a&gt; apela para a dimensão de cor e instantaneamente nos informa o estado mais crítico. Especificamente para esta análise ele este tipo de gráfico é muito apropriado.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggplot(estados_focos) +
  geom_sf(aes(fill = focos), color = NA) +
  facet_wrap(~ano) +
  labs(fill = &amp;quot;Nº de focos de incêndios&amp;quot;) +
  scale_fill_viridis_c(label = unit_format(unit = &amp;quot;k&amp;quot;, scale = 1e-3)) +
  coord_sf(datum = NA) +
  theme_bw(16) +
  theme(legend.position = &amp;quot;bottom&amp;quot;, legend.justification = &amp;quot;right&amp;quot;) +
  guides(fill = guide_colorbar(barwidth = 15, title.position = &amp;quot;top&amp;quot;))&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;figure&#34;&gt;&lt;span id=&#34;fig:focos-facet&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;https://italocegatta.github.io/post/2017-07-08-graficos-com-dimensao-espacial-e-temporal_files/figure-html/focos-facet-1.png&#34; alt=&#34;Representação em painel utilizando cores.&#34; width=&#34;960&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figura  2: Representação em painel utilizando cores.
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;E por fim, nossa terceira tentativa vai unificar os painéis do gráfico &lt;a href=&#34;#fig:focos-facet&#34;&gt;2&lt;/a&gt; em um gif animado. A limitação do gráfico é que muitas vezes nossos gráficos vão para documentos estáticos como PDF e Word, inviabilizando o gif.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggplot(estados_focos) +
  geom_sf(aes(fill = focos), color = NA) +
  labs(
    title = &amp;quot;Ano: {current_frame}&amp;quot;,
    fill = &amp;quot;Nº de focos de incêndios&amp;quot;
  ) +
  scale_fill_viridis_c(label = unit_format(unit = &amp;quot;k&amp;quot;, scale = 1e-3)) +
  theme_bw(18) +
  theme(legend.position = &amp;quot;bottom&amp;quot;, legend.justification = &amp;quot;right&amp;quot;) +
  guides(fill = guide_colorbar(barwidth = 15, title.position = &amp;quot;top&amp;quot;)) +
  transition_manual(ano)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;a href=&#34;http://imgur.com/KoLpSsF&#34;&gt;&lt;img src=&#34;http://i.imgur.com/KoLpSsF.gif&#34; style=&#34;width:100%&#34; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Caso tenha alguma dúvida ou sugestão sobre o post, fique à vontade para fazer um comentário ou me contatar por E-mail.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;sessioninfo::session_info(c(&amp;quot;readr&amp;quot;, &amp;quot;dplyr&amp;quot;, &amp;quot;ggplot2&amp;quot;, &amp;quot;sf&amp;quot;, &amp;quot;geofacet&amp;quot;, &amp;quot;gganimate&amp;quot;, &amp;quot;scales&amp;quot;, &amp;quot;brmap&amp;quot;))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## - Session info ----------------------------------------------------------
##  setting  value                       
##  version  R version 3.5.3 (2019-03-11)
##  os       Windows 10 x64              
##  system   x86_64, mingw32             
##  ui       RTerm                       
##  language (EN)                        
##  collate  Portuguese_Brazil.1252      
##  ctype    Portuguese_Brazil.1252      
##  tz       America/Sao_Paulo           
##  date     2019-08-25                  
## 
## - Packages --------------------------------------------------------------
##  package       * version     date       lib source        
##  askpass         1.1         2019-01-13 [1] CRAN (R 3.5.2)
##  assertthat      0.2.1       2019-03-21 [1] CRAN (R 3.5.3)
##  backports       1.1.4       2019-04-10 [1] CRAN (R 3.5.3)
##  BH              1.69.0-1    2019-01-07 [1] CRAN (R 3.5.2)
##  brmap         * 0.1.0       2019-03-04 [1] local         
##  class           7.3-15      2019-01-01 [2] CRAN (R 3.5.3)
##  classInt        0.4-1       2019-08-06 [1] CRAN (R 3.5.3)
##  cli             1.1.0       2019-03-19 [1] CRAN (R 3.5.3)
##  clipr           0.7.0       2019-07-23 [1] CRAN (R 3.5.3)
##  colorspace      1.4-1       2019-03-18 [1] CRAN (R 3.5.3)
##  crayon          1.3.4       2017-09-16 [1] CRAN (R 3.5.1)
##  curl            4.0         2019-07-22 [1] CRAN (R 3.5.3)
##  DBI             1.0.0       2018-05-02 [1] CRAN (R 3.5.1)
##  digest          0.6.20      2019-07-04 [1] CRAN (R 3.5.3)
##  dplyr         * 0.8.3       2019-07-04 [1] CRAN (R 3.5.3)
##  e1071           1.7-2       2019-06-05 [1] CRAN (R 3.5.3)
##  ellipsis        0.2.0.1     2019-07-02 [1] CRAN (R 3.5.3)
##  fansi           0.4.0       2018-10-05 [1] CRAN (R 3.5.1)
##  farver          1.1.0       2018-11-20 [1] CRAN (R 3.5.1)
##  geofacet      * 0.1.10      2019-03-13 [1] CRAN (R 3.5.3)
##  geogrid         0.1.1       2018-12-11 [1] CRAN (R 3.5.2)
##  gganimate     * 1.0.3       2019-04-02 [1] CRAN (R 3.5.3)
##  ggplot2       * 3.2.1       2019-08-10 [1] CRAN (R 3.5.3)
##  ggrepel         0.8.1       2019-05-07 [1] CRAN (R 3.5.3)
##  glue            1.3.1       2019-03-12 [1] CRAN (R 3.5.3)
##  gridExtra       2.3         2017-09-09 [1] CRAN (R 3.5.1)
##  gtable          0.3.0       2019-03-25 [1] CRAN (R 3.5.3)
##  hms             0.5.0       2019-07-09 [1] CRAN (R 3.5.3)
##  httr            1.4.1       2019-08-05 [1] CRAN (R 3.5.3)
##  imguR           1.0.3       2016-03-29 [1] CRAN (R 3.5.1)
##  jpeg            0.1-8       2014-01-23 [1] CRAN (R 3.5.0)
##  jsonlite        1.6         2018-12-07 [1] CRAN (R 3.5.2)
##  KernSmooth      2.23-15     2015-06-29 [2] CRAN (R 3.5.3)
##  labeling        0.3         2014-08-23 [1] CRAN (R 3.5.0)
##  lattice         0.20-38     2018-11-04 [2] CRAN (R 3.5.3)
##  lazyeval        0.2.2       2019-03-15 [1] CRAN (R 3.5.3)
##  magrittr        1.5         2014-11-22 [1] CRAN (R 3.5.1)
##  MASS            7.3-51.1    2018-11-01 [2] CRAN (R 3.5.3)
##  Matrix          1.2-17      2019-03-22 [1] CRAN (R 3.5.3)
##  mgcv            1.8-28      2019-03-21 [1] CRAN (R 3.5.3)
##  mime            0.7         2019-06-11 [1] CRAN (R 3.5.3)
##  munsell         0.5.0       2018-06-12 [1] CRAN (R 3.5.1)
##  nlme            3.1-137     2018-04-07 [2] CRAN (R 3.5.3)
##  openssl         1.4.1       2019-07-18 [1] CRAN (R 3.5.3)
##  pillar          1.4.2       2019-06-29 [1] CRAN (R 3.5.3)
##  pkgconfig       2.0.2       2018-08-16 [1] CRAN (R 3.5.1)
##  plogr           0.2.0       2018-03-25 [1] CRAN (R 3.5.1)
##  plyr            1.8.4       2016-06-08 [1] CRAN (R 3.5.1)
##  png             0.1-7       2013-12-03 [1] CRAN (R 3.5.0)
##  prettyunits     1.0.2       2015-07-13 [1] CRAN (R 3.5.1)
##  progress        1.2.2       2019-05-16 [1] CRAN (R 3.5.3)
##  purrr           0.3.2       2019-03-15 [1] CRAN (R 3.5.3)
##  R6              2.4.0       2019-02-14 [1] CRAN (R 3.5.2)
##  RColorBrewer    1.1-2       2014-12-07 [1] CRAN (R 3.5.0)
##  Rcpp            1.0.2       2019-07-25 [1] CRAN (R 3.5.3)
##  RcppArmadillo   0.9.600.4.0 2019-07-15 [1] CRAN (R 3.5.3)
##  readr         * 1.3.1       2018-12-21 [1] CRAN (R 3.5.2)
##  reshape2        1.4.3       2017-12-11 [1] CRAN (R 3.5.1)
##  rgeos           0.5-1       2019-08-05 [1] CRAN (R 3.5.3)
##  rlang           0.4.0       2019-06-25 [1] CRAN (R 3.5.3)
##  rnaturalearth   0.1.0       2017-03-21 [1] CRAN (R 3.5.1)
##  scales        * 1.0.0       2018-08-09 [1] CRAN (R 3.5.1)
##  sf            * 0.7-7       2019-07-24 [1] CRAN (R 3.5.3)
##  sp              1.3-1       2018-06-05 [1] CRAN (R 3.5.1)
##  stringi         1.4.3       2019-03-12 [1] CRAN (R 3.5.3)
##  stringr         1.4.0       2019-02-10 [1] CRAN (R 3.5.2)
##  sys             3.2         2019-04-23 [1] CRAN (R 3.5.3)
##  tibble          2.1.3       2019-06-06 [1] CRAN (R 3.5.3)
##  tidyselect      0.2.5       2018-10-11 [1] CRAN (R 3.5.1)
##  tweenr          1.0.1       2018-12-14 [1] CRAN (R 3.5.2)
##  units           0.6-3       2019-05-03 [1] CRAN (R 3.5.3)
##  utf8            1.1.4       2018-05-24 [1] CRAN (R 3.5.1)
##  vctrs           0.2.0       2019-07-05 [1] CRAN (R 3.5.3)
##  viridisLite     0.3.0       2018-02-01 [1] CRAN (R 3.5.1)
##  withr           2.1.2       2018-03-15 [1] CRAN (R 3.5.1)
##  zeallot         0.1.0       2018-01-28 [1] CRAN (R 3.5.2)
## 
## [1] C:/Users/Italo/Documents/R/win-library/3.5
## [2] C:/Program Files/R/R-3.5.3/library&lt;/code&gt;&lt;/pre&gt;

      </content:encoded>
    </item>
    
    <item>
      <title>Interpolação pelo inverso do quadrado da distância</title>
      <link>https://italocegatta.github.io/interpolacao-pelo-inverso-do-quadrado-da-distancia/</link>
      <pubDate>Sun, 30 Apr 2017 00:00:00 +0000</pubDate>
      
      <guid>https://italocegatta.github.io/interpolacao-pelo-inverso-do-quadrado-da-distancia/</guid>
      <description>É comum quando temos um determinado valor distribuído espacialmente e queremos estimá-lo para um ponto específico. Existem inúmeras formas de se chegar nesta estimativa, mas quero mostrar apenas uma neste post. O objetivo é estimar o quanto choveu em Itapetininga-SP, a partir de dados de chuva de outras 6 cidades próximas. Utilizaremos para isso os dados das estações automáticas do INMET.
Primeiro, vamos importar e visualizar os dados que temos disponível.</description>
      <content:encoded>
        
&lt;script src=&#34;https://italocegatta.github.io/rmarkdown-libs/htmlwidgets/htmlwidgets.js&#34;&gt;&lt;/script&gt;
&lt;script src=&#34;https://italocegatta.github.io/rmarkdown-libs/jquery/jquery.min.js&#34;&gt;&lt;/script&gt;
&lt;link href=&#34;https://italocegatta.github.io/rmarkdown-libs/leaflet/leaflet.css&#34; rel=&#34;stylesheet&#34; /&gt;
&lt;script src=&#34;https://italocegatta.github.io/rmarkdown-libs/leaflet/leaflet.js&#34;&gt;&lt;/script&gt;
&lt;link href=&#34;https://italocegatta.github.io/rmarkdown-libs/leafletfix/leafletfix.css&#34; rel=&#34;stylesheet&#34; /&gt;
&lt;script src=&#34;https://italocegatta.github.io/rmarkdown-libs/Proj4Leaflet/proj4-compressed.js&#34;&gt;&lt;/script&gt;
&lt;script src=&#34;https://italocegatta.github.io/rmarkdown-libs/Proj4Leaflet/proj4leaflet.js&#34;&gt;&lt;/script&gt;
&lt;link href=&#34;https://italocegatta.github.io/rmarkdown-libs/rstudio_leaflet/rstudio_leaflet.css&#34; rel=&#34;stylesheet&#34; /&gt;
&lt;script src=&#34;https://italocegatta.github.io/rmarkdown-libs/leaflet-binding/leaflet.js&#34;&gt;&lt;/script&gt;


&lt;p&gt;É comum quando temos um determinado valor distribuído espacialmente e queremos estimá-lo para um ponto específico. Existem inúmeras formas de se chegar nesta estimativa, mas quero mostrar apenas uma neste post. O objetivo é estimar o quanto choveu em Itapetininga-SP, a partir de dados de chuva de outras 6 cidades próximas. Utilizaremos para isso os dados das estações automáticas do &lt;a href=&#34;http://www.inmet.gov.br/portal/index.php?r=estacoes/estacoesAutomaticas&#34;&gt;INMET&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Primeiro, vamos importar e visualizar os dados que temos disponível.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;if (!require(&amp;quot;pacman&amp;quot;)) install.packages(&amp;quot;pacman&amp;quot;)
pacman::p_load(readr, dplyr, leaflet)&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# importa o arquivo os dados de chuva
dados &amp;lt;- read_csv2(
  &amp;quot;https://raw.githubusercontent.com/italocegatta/italocegatta.github.io_source/master/content/dados/chuva_inmet.csv&amp;quot;
)

dados&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 6 x 4
##   cidade               lon   lat     p
##   &amp;lt;chr&amp;gt;              &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt;
## 1 Sorocaba           -47.6 -23.4  27  
## 2 Itapeva            -48.9 -24.0  33.4
## 3 Sao Miguel Arcanjo -48.2 -23.9  34.6
## 4 Avare              -48.9 -23.1  18.2
## 5 Piracicaba         -47.6 -22.7  30.8
## 6 Barra Bonita       -48.6 -22.5  42.8&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;O mapa a seguir mostra o total de chuva registrado pela estação meteorológica de cada cidade no dia 26/04/2017. Nosso objetivo é estimar o quanto choveu em Itapetininga utilizando a interpolação pelo inverso do quadrado da distância ou IDW (Inverse Distance Weighting).&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;leaflet(dados) %&amp;gt;% 
  addTiles() %&amp;gt;% 
  addMarkers(-48.0530600, -23.5916700) %&amp;gt;% 
  addCircleMarkers(
    ~lon, ~lat, 
    radius = ~p * 0.8, 
    label = ~as.character(p),
    popup = ~cidade,
    fillOpacity = 0.6,
    labelOptions = labelOptions(
      style = list(&amp;quot;color&amp;quot; = &amp;quot;white&amp;quot;),
      offset = c(5, -10),
      noHide = TRUE,
      textOnly = TRUE,
      direction = &amp;quot;bottom&amp;quot;
    )
  )&lt;/code&gt;&lt;/pre&gt;
&lt;div id=&#34;htmlwidget-1&#34; style=&#34;width:100%;height:500px;&#34; class=&#34;leaflet html-widget&#34;&gt;&lt;/div&gt;
&lt;script type=&#34;application/json&#34; data-for=&#34;htmlwidget-1&#34;&gt;{&#34;x&#34;:{&#34;options&#34;:{&#34;crs&#34;:{&#34;crsClass&#34;:&#34;L.CRS.EPSG3857&#34;,&#34;code&#34;:null,&#34;proj4def&#34;:null,&#34;projectedBounds&#34;:null,&#34;options&#34;:{}}},&#34;calls&#34;:[{&#34;method&#34;:&#34;addTiles&#34;,&#34;args&#34;:[&#34;//{s}.tile.openstreetmap.org/{z}/{x}/{y}.png&#34;,null,null,{&#34;minZoom&#34;:0,&#34;maxZoom&#34;:18,&#34;tileSize&#34;:256,&#34;subdomains&#34;:&#34;abc&#34;,&#34;errorTileUrl&#34;:&#34;&#34;,&#34;tms&#34;:false,&#34;noWrap&#34;:false,&#34;zoomOffset&#34;:0,&#34;zoomReverse&#34;:false,&#34;opacity&#34;:1,&#34;zIndex&#34;:1,&#34;detectRetina&#34;:false,&#34;attribution&#34;:&#34;&amp;copy; &lt;a href=\&#34;http://openstreetmap.org\&#34;&gt;OpenStreetMap&lt;\/a&gt; contributors, &lt;a href=\&#34;http://creativecommons.org/licenses/by-sa/2.0/\&#34;&gt;CC-BY-SA&lt;\/a&gt;&#34;}]},{&#34;method&#34;:&#34;addMarkers&#34;,&#34;args&#34;:[-23.59167,-48.05306,null,null,null,{&#34;interactive&#34;:true,&#34;draggable&#34;:false,&#34;keyboard&#34;:true,&#34;title&#34;:&#34;&#34;,&#34;alt&#34;:&#34;&#34;,&#34;zIndexOffset&#34;:0,&#34;opacity&#34;:1,&#34;riseOnHover&#34;:false,&#34;riseOffset&#34;:250},null,null,null,null,null,{&#34;interactive&#34;:false,&#34;permanent&#34;:false,&#34;direction&#34;:&#34;auto&#34;,&#34;opacity&#34;:1,&#34;offset&#34;:[0,0],&#34;textsize&#34;:&#34;10px&#34;,&#34;textOnly&#34;:false,&#34;className&#34;:&#34;&#34;,&#34;sticky&#34;:true},null]},{&#34;method&#34;:&#34;addCircleMarkers&#34;,&#34;args&#34;:[[-23.426035,-23.981918,-23.852022,-23.101749,-22.703132,-22.471205],[-47.585552,-48.885818,-48.164817,-48.940997,-47.623317,-48.557573],[21.6,26.72,27.68,14.56,24.64,34.24],null,null,{&#34;interactive&#34;:true,&#34;className&#34;:&#34;&#34;,&#34;stroke&#34;:true,&#34;color&#34;:&#34;#03F&#34;,&#34;weight&#34;:5,&#34;opacity&#34;:0.5,&#34;fill&#34;:true,&#34;fillColor&#34;:&#34;#03F&#34;,&#34;fillOpacity&#34;:0.6},null,null,[&#34;Sorocaba&#34;,&#34;Itapeva&#34;,&#34;Sao Miguel Arcanjo&#34;,&#34;Avare&#34;,&#34;Piracicaba&#34;,&#34;Barra Bonita&#34;],null,[&#34;27&#34;,&#34;33.4&#34;,&#34;34.6&#34;,&#34;18.2&#34;,&#34;30.8&#34;,&#34;42.8&#34;],{&#34;interactive&#34;:false,&#34;permanent&#34;:true,&#34;direction&#34;:&#34;bottom&#34;,&#34;opacity&#34;:1,&#34;offset&#34;:[5,-10],&#34;textsize&#34;:&#34;10px&#34;,&#34;textOnly&#34;:true,&#34;style&#34;:{&#34;color&#34;:&#34;white&#34;},&#34;className&#34;:&#34;&#34;,&#34;sticky&#34;:true},null]}],&#34;limits&#34;:{&#34;lat&#34;:[-23.981918,-22.471205],&#34;lng&#34;:[-48.940997,-47.585552]}},&#34;evals&#34;:[],&#34;jsHooks&#34;:[]}&lt;/script&gt;
&lt;p&gt;A expressão que define o método é dada abaixo. Basicamente considera-se o valor de cada vizinho ponderado pelo inverso da distância entre ele e o ponto de interesse. Assim, vizinhos distantes contribuem com menos peso para o valor final que vizinhos mais próximos.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://bit.ly/2oN3IlI&#34; align=&#34;center&#34; border=&#34;0&#34; alt=&#34;x_{p} =\frac{\sum_{i=1}^n(\frac{1}{d_{i}^{2}}\times x_{i})}{\sum_{i=1}^n(\frac{1}{d_{i}^{2}})}&#34; width=&#34;153&#34; height=&#34;71&#34; /&gt;&lt;/p&gt;
&lt;p&gt;onde: xp = valor interpolado; xi = valor da i-ésimo ponto vizinho; di = distância entre o i-ésimo ponto de vizinho e o ponto de interesse.&lt;/p&gt;
&lt;p&gt;Agora que já definimos o método, vamos começar os cálculos. O primeiro valor calculado será a distância entre os pontos. Utilizaremos a formula de Haversine que retorna a distâncias entre dois pontos de uma esfera a partir de suas latitudes e longitudes.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;haversine &amp;lt;- function(lon1, lat1, lon2, lat2) {
  # converte graus pra radiano
  rad &amp;lt;- pi/180
  # raio medio da terra no equador em km
  R &amp;lt;- 6378.1

  dlon &amp;lt;- (lon2 - lon1) * rad
  dlat &amp;lt;- (lat2 - lat1) * rad

  a &amp;lt;- (sin(dlat/2))^2 +
       cos(lat1 * rad) *
       cos(lat2 * rad) *
       (sin(dlon/2))^2

  c &amp;lt;- 2 * atan2(sqrt(a), sqrt(1 - a))

  d &amp;lt;- R * c 

  # distancia em km
  return(d)
}&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;dist &amp;lt;- dados %&amp;gt;%
  mutate(d_itape = haversine(lon, lat, -48.0530600, -23.5916700))

dist&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 6 x 5
##   cidade               lon   lat     p d_itape
##   &amp;lt;chr&amp;gt;              &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt;   &amp;lt;dbl&amp;gt;
## 1 Sorocaba           -47.6 -23.4  27      51.2
## 2 Itapeva            -48.9 -24.0  33.4    95.3
## 3 Sao Miguel Arcanjo -48.2 -23.9  34.6    31.1
## 4 Avare              -48.9 -23.1  18.2   106. 
## 5 Piracicaba         -47.6 -22.7  30.8   108. 
## 6 Barra Bonita       -48.6 -22.5  42.8   135.&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;O cálculo do IDW é relativamente simples, basta reproduzir a expressão do método.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;idw &amp;lt;- function(x, dist, na.rm = TRUE) {
  s1 &amp;lt;-  sum(x / dist^2, na.rm = na.rm)
  s2 &amp;lt;-  sum(1 / dist^2, na.rm = na.rm)

  return(s1 / s2)
}&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;dados_itape &amp;lt;- dist %&amp;gt;% 
  add_row(
    .,
    cidade = &amp;quot;Itapetininga&amp;quot;,
    lon = -48.0530600,
    lat = -23.5916700,
    p = round(idw(.$p, .$d_itape), 1)
  )

dados_itape&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 7 x 5
##   cidade               lon   lat     p d_itape
##   &amp;lt;chr&amp;gt;              &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt;   &amp;lt;dbl&amp;gt;
## 1 Sorocaba           -47.6 -23.4  27      51.2
## 2 Itapeva            -48.9 -24.0  33.4    95.3
## 3 Sao Miguel Arcanjo -48.2 -23.9  34.6    31.1
## 4 Avare              -48.9 -23.1  18.2   106. 
## 5 Piracicaba         -47.6 -22.7  30.8   108. 
## 6 Barra Bonita       -48.6 -22.5  42.8   135. 
## 7 Itapetininga       -48.1 -23.6  32.1    NA&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Muito bom, agora vamos retornar ao mapa e adicionar o quanto choveu em Itapetininga de acordo com a interpolação por IDW.
&lt;br&gt;
&lt;br&gt;
&lt;div id=&#34;htmlwidget-2&#34; style=&#34;width:100%;height:500px;&#34; class=&#34;leaflet html-widget&#34;&gt;&lt;/div&gt;
&lt;script type=&#34;application/json&#34; data-for=&#34;htmlwidget-2&#34;&gt;{&#34;x&#34;:{&#34;options&#34;:{&#34;crs&#34;:{&#34;crsClass&#34;:&#34;L.CRS.EPSG3857&#34;,&#34;code&#34;:null,&#34;proj4def&#34;:null,&#34;projectedBounds&#34;:null,&#34;options&#34;:{}}},&#34;calls&#34;:[{&#34;method&#34;:&#34;addTiles&#34;,&#34;args&#34;:[&#34;//{s}.tile.openstreetmap.org/{z}/{x}/{y}.png&#34;,null,null,{&#34;minZoom&#34;:0,&#34;maxZoom&#34;:18,&#34;tileSize&#34;:256,&#34;subdomains&#34;:&#34;abc&#34;,&#34;errorTileUrl&#34;:&#34;&#34;,&#34;tms&#34;:false,&#34;noWrap&#34;:false,&#34;zoomOffset&#34;:0,&#34;zoomReverse&#34;:false,&#34;opacity&#34;:1,&#34;zIndex&#34;:1,&#34;detectRetina&#34;:false,&#34;attribution&#34;:&#34;&amp;copy; &lt;a href=\&#34;http://openstreetmap.org\&#34;&gt;OpenStreetMap&lt;\/a&gt; contributors, &lt;a href=\&#34;http://creativecommons.org/licenses/by-sa/2.0/\&#34;&gt;CC-BY-SA&lt;\/a&gt;&#34;}]},{&#34;method&#34;:&#34;addCircleMarkers&#34;,&#34;args&#34;:[[-23.426035,-23.981918,-23.852022,-23.101749,-22.703132,-22.471205,-23.59167],[-47.585552,-48.885818,-48.164817,-48.940997,-47.623317,-48.557573,-48.05306],[27,33.4,34.6,18.2,30.8,42.8,32.1],null,null,{&#34;interactive&#34;:true,&#34;className&#34;:&#34;&#34;,&#34;stroke&#34;:true,&#34;color&#34;:&#34;#03F&#34;,&#34;weight&#34;:5,&#34;opacity&#34;:0.5,&#34;fill&#34;:true,&#34;fillColor&#34;:&#34;#03F&#34;,&#34;fillOpacity&#34;:0.6},null,null,[&#34;Sorocaba&#34;,&#34;Itapeva&#34;,&#34;Sao Miguel Arcanjo&#34;,&#34;Avare&#34;,&#34;Piracicaba&#34;,&#34;Barra Bonita&#34;,&#34;Itapetininga&#34;],null,[&#34;27&#34;,&#34;33.4&#34;,&#34;34.6&#34;,&#34;18.2&#34;,&#34;30.8&#34;,&#34;42.8&#34;,&#34;32.1&#34;],{&#34;interactive&#34;:false,&#34;permanent&#34;:true,&#34;direction&#34;:&#34;bottom&#34;,&#34;opacity&#34;:1,&#34;offset&#34;:[5,-10],&#34;textsize&#34;:&#34;10px&#34;,&#34;textOnly&#34;:true,&#34;style&#34;:{&#34;color&#34;:&#34;white&#34;},&#34;className&#34;:&#34;&#34;,&#34;sticky&#34;:true},null]}],&#34;limits&#34;:{&#34;lat&#34;:[-23.981918,-22.471205],&#34;lng&#34;:[-48.940997,-47.585552]}},&#34;evals&#34;:[],&#34;jsHooks&#34;:[]}&lt;/script&gt;&lt;/p&gt;
&lt;p&gt;Caso tenha alguma dúvida ou sugestão sobre o post, fique à vontade para fazer um comentário ou me contatar por E-mail.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;sessioninfo::session_info(c(&amp;quot;readr&amp;quot;, &amp;quot;dplyr&amp;quot;, &amp;quot;leaflet&amp;quot;))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## - Session info ----------------------------------------------------------
##  setting  value                       
##  version  R version 3.5.3 (2019-03-11)
##  os       Windows 10 x64              
##  system   x86_64, mingw32             
##  ui       RTerm                       
##  language (EN)                        
##  collate  Portuguese_Brazil.1252      
##  ctype    Portuguese_Brazil.1252      
##  tz       America/Sao_Paulo           
##  date     2019-08-25                  
## 
## - Packages --------------------------------------------------------------
##  package      * version  date       lib source        
##  assertthat     0.2.1    2019-03-21 [1] CRAN (R 3.5.3)
##  backports      1.1.4    2019-04-10 [1] CRAN (R 3.5.3)
##  base64enc      0.1-3    2015-07-28 [1] CRAN (R 3.5.0)
##  BH             1.69.0-1 2019-01-07 [1] CRAN (R 3.5.2)
##  cli            1.1.0    2019-03-19 [1] CRAN (R 3.5.3)
##  clipr          0.7.0    2019-07-23 [1] CRAN (R 3.5.3)
##  colorspace     1.4-1    2019-03-18 [1] CRAN (R 3.5.3)
##  crayon         1.3.4    2017-09-16 [1] CRAN (R 3.5.1)
##  crosstalk      1.0.0    2016-12-21 [1] CRAN (R 3.5.1)
##  digest         0.6.20   2019-07-04 [1] CRAN (R 3.5.3)
##  dplyr        * 0.8.3    2019-07-04 [1] CRAN (R 3.5.3)
##  ellipsis       0.2.0.1  2019-07-02 [1] CRAN (R 3.5.3)
##  fansi          0.4.0    2018-10-05 [1] CRAN (R 3.5.1)
##  ggplot2        3.2.1    2019-08-10 [1] CRAN (R 3.5.3)
##  glue           1.3.1    2019-03-12 [1] CRAN (R 3.5.3)
##  gridExtra      2.3      2017-09-09 [1] CRAN (R 3.5.1)
##  gtable         0.3.0    2019-03-25 [1] CRAN (R 3.5.3)
##  hms            0.5.0    2019-07-09 [1] CRAN (R 3.5.3)
##  htmltools      0.3.6    2017-04-28 [1] CRAN (R 3.5.1)
##  htmlwidgets    1.3      2018-09-30 [1] CRAN (R 3.5.1)
##  httpuv         1.5.1    2019-04-05 [1] CRAN (R 3.5.3)
##  jsonlite       1.6      2018-12-07 [1] CRAN (R 3.5.2)
##  labeling       0.3      2014-08-23 [1] CRAN (R 3.5.0)
##  later          0.8.0    2019-02-11 [1] CRAN (R 3.5.2)
##  lattice        0.20-38  2018-11-04 [2] CRAN (R 3.5.3)
##  lazyeval       0.2.2    2019-03-15 [1] CRAN (R 3.5.3)
##  leaflet      * 2.0.2    2018-08-27 [1] CRAN (R 3.5.1)
##  magrittr       1.5      2014-11-22 [1] CRAN (R 3.5.1)
##  markdown       1.1      2019-08-07 [1] CRAN (R 3.5.3)
##  MASS           7.3-51.1 2018-11-01 [2] CRAN (R 3.5.3)
##  Matrix         1.2-17   2019-03-22 [1] CRAN (R 3.5.3)
##  mgcv           1.8-28   2019-03-21 [1] CRAN (R 3.5.3)
##  mime           0.7      2019-06-11 [1] CRAN (R 3.5.3)
##  munsell        0.5.0    2018-06-12 [1] CRAN (R 3.5.1)
##  nlme           3.1-137  2018-04-07 [2] CRAN (R 3.5.3)
##  pillar         1.4.2    2019-06-29 [1] CRAN (R 3.5.3)
##  pkgconfig      2.0.2    2018-08-16 [1] CRAN (R 3.5.1)
##  plogr          0.2.0    2018-03-25 [1] CRAN (R 3.5.1)
##  plyr           1.8.4    2016-06-08 [1] CRAN (R 3.5.1)
##  png            0.1-7    2013-12-03 [1] CRAN (R 3.5.0)
##  promises       1.0.1    2018-04-13 [1] CRAN (R 3.5.1)
##  purrr          0.3.2    2019-03-15 [1] CRAN (R 3.5.3)
##  R6             2.4.0    2019-02-14 [1] CRAN (R 3.5.2)
##  raster         2.9-23   2019-07-11 [1] CRAN (R 3.5.3)
##  RColorBrewer   1.1-2    2014-12-07 [1] CRAN (R 3.5.0)
##  Rcpp           1.0.2    2019-07-25 [1] CRAN (R 3.5.3)
##  readr        * 1.3.1    2018-12-21 [1] CRAN (R 3.5.2)
##  reshape2       1.4.3    2017-12-11 [1] CRAN (R 3.5.1)
##  rlang          0.4.0    2019-06-25 [1] CRAN (R 3.5.3)
##  scales         1.0.0    2018-08-09 [1] CRAN (R 3.5.1)
##  shiny          1.3.2    2019-04-22 [1] CRAN (R 3.5.3)
##  sourcetools    0.1.7    2018-04-25 [1] CRAN (R 3.5.1)
##  sp             1.3-1    2018-06-05 [1] CRAN (R 3.5.1)
##  stringi        1.4.3    2019-03-12 [1] CRAN (R 3.5.3)
##  stringr        1.4.0    2019-02-10 [1] CRAN (R 3.5.2)
##  tibble         2.1.3    2019-06-06 [1] CRAN (R 3.5.3)
##  tidyselect     0.2.5    2018-10-11 [1] CRAN (R 3.5.1)
##  utf8           1.1.4    2018-05-24 [1] CRAN (R 3.5.1)
##  vctrs          0.2.0    2019-07-05 [1] CRAN (R 3.5.3)
##  viridis        0.5.1    2018-03-29 [1] CRAN (R 3.5.1)
##  viridisLite    0.3.0    2018-02-01 [1] CRAN (R 3.5.1)
##  withr          2.1.2    2018-03-15 [1] CRAN (R 3.5.1)
##  xfun           0.8      2019-06-25 [1] CRAN (R 3.5.3)
##  xtable         1.8-4    2019-04-21 [1] CRAN (R 3.5.3)
##  yaml           2.2.0    2018-07-25 [1] CRAN (R 3.5.1)
##  zeallot        0.1.0    2018-01-28 [1] CRAN (R 3.5.2)
## 
## [1] C:/Users/Italo/Documents/R/win-library/3.5
## [2] C:/Program Files/R/R-3.5.3/library&lt;/code&gt;&lt;/pre&gt;

      </content:encoded>
    </item>
    
    <item>
      <title>Download automático de imagens MODIS</title>
      <link>https://italocegatta.github.io/download-automatico-de-imagens-modis/</link>
      <pubDate>Sun, 15 Jan 2017 00:00:00 +0000</pubDate>
      
      <guid>https://italocegatta.github.io/download-automatico-de-imagens-modis/</guid>
      <description>O MODIS (MODerate resolution Imaging Spectroradiometer) faz parte de um programa da NASA para monitoramento da superfície terrestre. Os satélites Terra e Aqua fornecem informações muito interessantes para o setor agroflorestal e nos permite entender de maneira bastante eficaz a dinâmica do uso do solo e de crescimento das nossas culturas.
O MODOIS tem diversos produtos, mas neste post vamos tratar especificamente do produto MOD13Q1, que disponibiliza a cada 16 dias um raster de EVI e NDVI com resolução de 250 m.</description>
      <content:encoded>
        


&lt;p&gt;O MODIS (MODerate resolution Imaging Spectroradiometer) faz parte de um programa da NASA para monitoramento da superfície terrestre. Os satélites Terra e Aqua fornecem informações muito interessantes para o setor agroflorestal e nos permite entender de maneira bastante eficaz a dinâmica do uso do solo e de crescimento das nossas culturas.&lt;/p&gt;
&lt;p&gt;O MODOIS tem diversos &lt;a href=&#34;https://modis.gsfc.nasa.gov/data/&#34;&gt;produtos&lt;/a&gt;, mas neste post vamos tratar especificamente do produto &lt;a href=&#34;https://lpdaac.usgs.gov/dataset_discovery/modis/modis_products_table/mod13q1_v006&#34;&gt;MOD13Q1&lt;/a&gt;, que disponibiliza a cada 16 dias um raster de EVI e NDVI com resolução de 250 m. Bom, se você está acostumado com imagens de satélite/drone/vant com resolução submétrica, pode ser que no primeiro momento esta escala te assuste. Mas vale lembrar que é um serviço gratuito e de ótima qualidade.&lt;/p&gt;
&lt;p&gt;As cenas do MODIS ficam disponíveis em um &lt;a href=&#34;https://e4ftl01.cr.usgs.gov/&#34;&gt;ftp&lt;/a&gt; e navegando por lá podemos chegar na pasta do produto que nos &lt;a href=&#34;http://e4ftl01.cr.usgs.gov/MOLT/MOD13Q1.006&#34;&gt;interessa&lt;/a&gt;. Temos então imagens de satélite processadas, com correção atmosférica, sem deslocamento espacial e com regularidade. O satélite varre a terra a cada dois dias e as melhores visadas são utilizadas para compor o produto que é disponibilizado a cada 16 dias. Há casos (de baixa frequência) em que a nebulosidade é tanta que não é possível compor a informação do pixel dentro desta janela&lt;/p&gt;
&lt;p&gt;Nosso objetivo para este poste é fazer o download das cenas de forma automática, um web scraping. No R há diversos pacotes que nos auxiliam neste processo. A primeira etapa é acessar o ftp que contém as cenas e extrair as datas das cenas disponíveis.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;if (!require(&amp;quot;pacman&amp;quot;)) install.packages(&amp;quot;pacman&amp;quot;)
pacman::p_load(dplyr, xml2, rvest, httr, stringr, methods)&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# url do ftp que contém as cenas
path_root &amp;lt;- &amp;quot;http://e4ftl01.cr.usgs.gov/MOLT/MOD13Q1.006&amp;quot;

# carrega a raiz do ftp
page_root &amp;lt;- read_html(path_root)

# extrai os dias das cenas
scene_days &amp;lt;- page_root %&amp;gt;% 
 html_nodes(&amp;quot;a&amp;quot;) %&amp;gt;% 
  html_text(trim = T) %&amp;gt;%
  &amp;#39;[&amp;#39;(-c(1:7)) %&amp;gt;%
  str_replace_all(&amp;quot;\\/&amp;quot;, &amp;quot;&amp;quot;)

glimpse(scene_days)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  chr [1:448] &amp;quot;2000.02.18&amp;quot; &amp;quot;2000.03.05&amp;quot; &amp;quot;2000.03.21&amp;quot; &amp;quot;2000.04.06&amp;quot; ...&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Muito bem, temos até a data da última atualização deste post 448 cenas disponíveis. O script abaixo cria a pasta com a data da cena e coloca lá os &lt;a href=&#34;https://modis-land.gsfc.nasa.gov/MODLAND_grid.html&#34;&gt;tiles&lt;/a&gt; de seu interesse. Como exemplo vamos pegar os tiles que cobrem os estados de São Paulo e Bahia. Note que é preciso ter um cadastro para autorizar o download dos arquivos. É simples e rápido de fazer acessando este &lt;a href=&#34;https://urs.earthdata.nasa.gov/users/new/&#34;&gt;link&lt;/a&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# inicio do 1º loop - dias
for (i in seq_along(scene_days)) {
  # cria a pasta para receber os tiles
  if(!dir.exists(scene_days[i])) dir.create(scene_days[i])

  # ideintificador de iteração
  day &amp;lt;- scene_days[i]
  
  # carrega a pagina do dia da cena
  page_tiles &amp;lt;- read_html(paste(path_root, day, sep = &amp;quot;/&amp;quot;))
  
  # extrai os tiles de interesse
  path_tiles &amp;lt;- page_tiles %&amp;gt;% 
    html_nodes(&amp;quot;a&amp;quot;) %&amp;gt;% 
    html_text(trim = T) %&amp;gt;%
    &amp;#39;[&amp;#39;(str_detect(., &amp;quot;[hdf]$&amp;quot;)) %&amp;gt;% 
    &amp;#39;[&amp;#39;(str_detect(., &amp;quot;h13v11|h14v10&amp;quot;))
  
  # inicio do 2º loop - tiles
  for (j in seq_along(path_tiles)) {
    # url do tile
    path_tile &amp;lt;- paste(path_root, day, path_tiles[j], sep = &amp;quot;/&amp;quot;)

    # id do tile
    tile &amp;lt;- paste(day, path_tiles[j], sep = &amp;quot;/&amp;quot;)
    
    # download do arquivo
    if (!file.exists(tile)) {
      temp &amp;lt;- GET(path_tile, authenticate(&amp;quot;LOGIN&amp;quot;, &amp;quot;SENHA&amp;quot;))
      writeBin(content(temp, &amp;quot;raw&amp;quot;), tile)
      rm(temp)
    }
  }
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Como tudo que está neste blog, este script foi escrito para resolver um problema específico e com certeza tem muito espaço para melhoria. Os próximos passos da análise, extração dos rasters e processamento da imagem serão abordados em posts separados. No futuro, caso exista uma demanda, pode ser que as funções sejam reunidas em um pacote específico sobre isso.&lt;/p&gt;
&lt;p&gt;Caso tenha alguma dúvida ou sugestão sobre o post, fique à vontade para fazer um comentário ou me contatar por E-mail.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;sessioninfo::session_info(c(&amp;quot;dplyr&amp;quot;, &amp;quot;xml2&amp;quot;, &amp;quot;rvest&amp;quot;, &amp;quot;httr&amp;quot;, &amp;quot;stringr&amp;quot;, &amp;quot;methods&amp;quot;))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## - Session info ----------------------------------------------------------
##  setting  value                       
##  version  R version 3.5.3 (2019-03-11)
##  os       Windows 10 x64              
##  system   x86_64, mingw32             
##  ui       RTerm                       
##  language (EN)                        
##  collate  Portuguese_Brazil.1252      
##  ctype    Portuguese_Brazil.1252      
##  tz       America/Sao_Paulo           
##  date     2019-08-25                  
## 
## - Packages --------------------------------------------------------------
##  package    * version  date       lib source        
##  askpass      1.1      2019-01-13 [1] CRAN (R 3.5.2)
##  assertthat   0.2.1    2019-03-21 [1] CRAN (R 3.5.3)
##  backports    1.1.4    2019-04-10 [1] CRAN (R 3.5.3)
##  BH           1.69.0-1 2019-01-07 [1] CRAN (R 3.5.2)
##  cli          1.1.0    2019-03-19 [1] CRAN (R 3.5.3)
##  crayon       1.3.4    2017-09-16 [1] CRAN (R 3.5.1)
##  curl         4.0      2019-07-22 [1] CRAN (R 3.5.3)
##  digest       0.6.20   2019-07-04 [1] CRAN (R 3.5.3)
##  dplyr      * 0.8.3    2019-07-04 [1] CRAN (R 3.5.3)
##  ellipsis     0.2.0.1  2019-07-02 [1] CRAN (R 3.5.3)
##  fansi        0.4.0    2018-10-05 [1] CRAN (R 3.5.1)
##  glue         1.3.1    2019-03-12 [1] CRAN (R 3.5.3)
##  httr       * 1.4.1    2019-08-05 [1] CRAN (R 3.5.3)
##  jsonlite     1.6      2018-12-07 [1] CRAN (R 3.5.2)
##  magrittr     1.5      2014-11-22 [1] CRAN (R 3.5.1)
##  mime         0.7      2019-06-11 [1] CRAN (R 3.5.3)
##  openssl      1.4.1    2019-07-18 [1] CRAN (R 3.5.3)
##  pillar       1.4.2    2019-06-29 [1] CRAN (R 3.5.3)
##  pkgconfig    2.0.2    2018-08-16 [1] CRAN (R 3.5.1)
##  plogr        0.2.0    2018-03-25 [1] CRAN (R 3.5.1)
##  purrr        0.3.2    2019-03-15 [1] CRAN (R 3.5.3)
##  R6           2.4.0    2019-02-14 [1] CRAN (R 3.5.2)
##  Rcpp         1.0.2    2019-07-25 [1] CRAN (R 3.5.3)
##  rlang        0.4.0    2019-06-25 [1] CRAN (R 3.5.3)
##  rvest      * 0.3.4    2019-05-15 [1] CRAN (R 3.5.3)
##  selectr      0.4-1    2018-04-06 [1] CRAN (R 3.5.1)
##  stringi      1.4.3    2019-03-12 [1] CRAN (R 3.5.3)
##  stringr    * 1.4.0    2019-02-10 [1] CRAN (R 3.5.2)
##  sys          3.2      2019-04-23 [1] CRAN (R 3.5.3)
##  tibble       2.1.3    2019-06-06 [1] CRAN (R 3.5.3)
##  tidyselect   0.2.5    2018-10-11 [1] CRAN (R 3.5.1)
##  utf8         1.1.4    2018-05-24 [1] CRAN (R 3.5.1)
##  vctrs        0.2.0    2019-07-05 [1] CRAN (R 3.5.3)
##  xml2       * 1.2.2    2019-08-09 [1] CRAN (R 3.5.3)
##  zeallot      0.1.0    2018-01-28 [1] CRAN (R 3.5.2)
## 
## [1] C:/Users/Italo/Documents/R/win-library/3.5
## [2] C:/Program Files/R/R-3.5.3/library&lt;/code&gt;&lt;/pre&gt;

      </content:encoded>
    </item>
    
    <item>
      <title>Índice de uniformidade (PV50)</title>
      <link>https://italocegatta.github.io/indice-de-uniformidade-pv50/</link>
      <pubDate>Sun, 09 Oct 2016 00:00:00 +0000</pubDate>
      
      <guid>https://italocegatta.github.io/indice-de-uniformidade-pv50/</guid>
      <description>O PV50 é hoje o índice mais utilizado quando queremos expressar a uniformidade de um plantio florestal. Hakamada (2012) apresentou um estudo detalhado sobre diversos índices e concluiu que o PV50 é o índice mais indicado para explicar a relação entre uniformidade, qualidade silvicultural e produtividade em plantios homogêneos de Eucalyptus.
O objetivo deste post é mostrar, passo a passo, como calcular este índice no R e fazer uma breve análise de seus resultados.</description>
      <content:encoded>
        


&lt;p&gt;O PV50 é hoje o índice mais utilizado quando queremos expressar a uniformidade de um plantio florestal. &lt;span class=&#34;citation&#34;&gt;Hakamada (&lt;a href=&#34;#ref-Hakamada2012&#34;&gt;2012&lt;/a&gt;)&lt;/span&gt; apresentou um estudo detalhado sobre diversos índices e concluiu que o PV50 é o índice mais indicado para explicar a relação entre uniformidade, qualidade silvicultural e produtividade em plantios homogêneos de &lt;em&gt;Eucalyptus&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;O objetivo deste post é mostrar, passo a passo, como calcular este índice no R e fazer uma breve análise de seus resultados.&lt;/p&gt;
&lt;p&gt;O PV50 é a porcentagem de volume acumulado das 50% menores árvores do seu conjunto de dados, considerando as falhas de plantio e árvores mortas &lt;span class=&#34;citation&#34;&gt;(Hakamada et al. &lt;a href=&#34;#ref-Hakamada2015&#34;&gt;2015&lt;/a&gt;)&lt;/span&gt;. A expressão do índice é dada da seguinte forma:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.sciweavers.org/tex2img.php?eq=PV50%20%3D%20%5Cfrac%7B%5Csum_%7Bk%3D1%7D%5E%7B%5Cfrac%7Bn%7D%7B2%7D%7DV_%7Bij%7D%7D%7B%5Csum_%7Bk%3D1%7D%5E%7Bn%7DV_%7Bij%7D%7D&amp;bc=White&amp;fc=Black&amp;im=jpg&amp;fs=12&amp;ff=arev&amp;edit=0&#34; align=&#34;center&#34; border=&#34;0&#34; alt=&#34;PV50 = \frac{\sum_{k=1}^{\frac{n}{2}}V_{ij}}{\sum_{k=1}^{n}V_{ij}}&#34; width=&#34;139&#34; height=&#34;62&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Onde: PV50 = porcentagem acumulada do volume das 50% menores árvores plantadas; V = volume da árvore i; n = número de árvores plantadas ordenadas (da menor para a maior).&lt;/p&gt;
&lt;p&gt;Primeiro vamos entender os cálculos do índice, considerando apenas 10 árvores hipotéticas com 0,1 metros cúbicos de volume.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# carrega os pacotes necessários
if (!require(&amp;quot;pacman&amp;quot;)) install.packages(&amp;quot;pacman&amp;quot;)
pacman::p_load(readr, dplyr, ggplot2, forcats)&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# exemplo com número par
arv10 &amp;lt;- rep(0.1, 10)
str(arv10)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  num [1:10] 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Este é o referencial teórico de uniformidade, todas as árvores do mesmo tamanho. Sem precisar fazer conta, sabemos que o volume das 50% menores árvores é igual a 50% do volume total, o que equivale a um PV50 = 50.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# identifica a metade do numero de árvores
metade &amp;lt;- length(arv10)/2
metade&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 5&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# soma todas as árvores
soma_todas &amp;lt;- sum(arv10, na.rm = TRUE)
soma_todas&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 1&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# soma o valor de metade das árvores em ordem crescente
soma_metade &amp;lt;- sum(sort(arv10)[1:metade], na.rm = TRUE)
soma_metade&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 0.5&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# calcula o PV50
PV50 &amp;lt;- soma_metade / soma_todas * 100
PV50&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 50&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Agora vamos simular 11 árvores com o mesmo volume, veja o que acontece.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# exemplo com número impar
arv11 &amp;lt;- rep(0.1, 11)
str(arv11)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  num [1:11] 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 ...&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# metade do numero de árvores
metade &amp;lt;- length(arv11)/2
metade&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 5.5&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# soma todas as árvores
soma_todas &amp;lt;- sum(arv11, na.rm = TRUE)
soma_todas&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 1.1&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# soma o valor de metade das árvores em ordem crescente
soma_metade &amp;lt;- sum(sort(arv11)[1:metade], na.rm = TRUE)
soma_metade&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 0.5&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# calcula o PV50
PV50 &amp;lt;- soma_metade / soma_todas * 100
PV50&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 45.45455&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;O resultado deveria ser 50, mas como o número de árvores é ímpar, o R arredonda a posição 5,5 para 5 e pega até a quinta árvore no momento em que queremos somar as 50% menores. Para contornar isso, vamos calcular a soma das 50% menores árvores de uma forma diferente. Primeiro calculamos a soma acumulada e depois extraímos a média (semelhante ao modo de se calcular uma mediana).&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# vetor de soma acumulada
soma_acumulada &amp;lt;- cumsum(sort(arv11))
soma_acumulada&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  [1] 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0 1.1&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# soma a metade do vetor de soma acumulada
soma_metade &amp;lt;- mean(soma_acumulada[metade + 0L:1L], na.rm = TRUE)
soma_metade&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 0.55&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# calcula o PV50
PV50 &amp;lt;- soma_metade / soma_todas * 100
PV50&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 50&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Agora que a questão do número de árvores foi superada, podemos incluir árvores mortas, o que equivale a elementos do tipo &lt;code&gt;NA&lt;/code&gt; no R. Veja que o resultado não está consistente pois a &lt;code&gt;soma_acumulada&lt;/code&gt; ignorou as árvores mortas.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# exemplo com valores perdidos
arv11_na &amp;lt;- rep(0.1, 11)
arv11_na[c(3,4)] &amp;lt;- NA
str(arv11_na)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  num [1:11] 0.1 0.1 NA NA 0.1 0.1 0.1 0.1 0.1 0.1 ...&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# metade do numero de árvores
metade &amp;lt;- length(arv11_na)/2
metade&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 5.5&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# soma todas as árvores
soma_todas &amp;lt;- sum(arv11_na, na.rm = TRUE)
soma_todas&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 0.9&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# vetor de soma acumulada
soma_acumulada &amp;lt;- cumsum(sort(arv11_na))
soma_acumulada&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# soma a metade do vetor de soma acumulada
soma_metade &amp;lt;- mean(soma_acumulada[metade + 0L:1L], na.rm = TRUE)
soma_metade&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 0.55&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# calcula o PV50
PV50 &amp;lt;- soma_metade / soma_todas * 100
PV50&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 61.11111&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Para corrigir este o erro, temos de incluir manualmente as árvores mortas na sequência. Veja que agora o resultado está de acordo com o esperado.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# vetor de valores perdidos
mortas &amp;lt;- arv11_na[is.na(arv11_na)]
mortas&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] NA NA&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# metade do numero de árvores
metade &amp;lt;- length(arv11_na)/2
metade&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 5.5&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# soma todas as árvores
soma_todas &amp;lt;- sum(arv11_na, na.rm = TRUE)
soma_todas&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 0.9&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# vetor de soma acumulada com valores perdidos
soma_acumulada &amp;lt;- c(mortas, cumsum(sort(arv11_na)))
soma_acumulada&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  [1]  NA  NA 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# soma a metade do vetor de soma acumulada
soma_metade &amp;lt;- mean(soma_acumulada[metade + 0L:1L], na.rm = TRUE)
soma_metade&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 0.35&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# calcula o PV50
PV50 &amp;lt;- soma_metade / soma_todas * 100
PV50&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 38.88889&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Agora eu vou dar aquele passo mágico dos livros de matemática e física, em que o autor diz “é fácil notar que o resultado leva a …” e apresentar uma função que lida com as questões que mostramos acima e retorna o PV50 do nosso conjunto de dados de forma correta.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;pv50 &amp;lt;- function(x) {
  
  mortas &amp;lt;- x[is.na(x)]
  
  metade &amp;lt;- length(x)/2
  
  soma_todas &amp;lt;- sum(x, na.rm = TRUE)
  
  soma_acumulada &amp;lt;- c(mortas, cumsum(sort(x)))
  
  if (metade%%2L == 1L)
    soma_metade &amp;lt;- mean(soma_acumulada[metade], na.rm = TRUE)
  else
    soma_metade &amp;lt;- mean(soma_acumulada[metade + 0L:1L], na.rm = TRUE)
  
  z &amp;lt;- soma_metade / soma_todas * 100
  
  return(z)
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Podemos rapidamente verificar se os resultados estão consistentes fazendo alguns testes.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;a &amp;lt;- rep(10, 10)
str(a)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  num [1:10] 10 10 10 10 10 10 10 10 10 10&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;pv50(a) # Ok!&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 50&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;a1 &amp;lt;- rep(10 ,11)
str(a1)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  num [1:11] 10 10 10 10 10 10 10 10 10 10 ...&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;pv50(a1) # Ok!&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 50&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;b &amp;lt;- a
b[c(3, 7)] &amp;lt;- NA
str(b)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  num [1:10] 10 10 NA 10 10 10 NA 10 10 10&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;pv50(b) # Ok!&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 37.5&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;b1 &amp;lt;- a1
b1[c(3, 7)] &amp;lt;- NA
str(b1)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  num [1:11] 10 10 NA 10 10 10 NA 10 10 10 ...&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;pv50(b1) # Ok!&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 38.88889&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Boa, já temos uma função para calcular o PV50 e podemos aplicá-la em um conjunto de dados para podermos interpretar. Utilizaremos mais uma vez os dados do &lt;a href=&#34;www.projetotume.com&#34;&gt;Projeto TUME&lt;/a&gt;, referente ao &lt;a href=&#34;http://www.projetotume.com/tume134&#34;&gt;TUME 134&lt;/a&gt; plantado em Piracicaba-SP. O volume individual foi calculado arbitrariamente utilizando o fator de forma 0,5.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# importa o arquivo tume_55.csv
dados &amp;lt;- read_csv2(
  &amp;quot;https://github.com/italocegatta/italocegatta.github.io_source/raw/master/content/dados/tume_55.csv&amp;quot;
)

glimpse(dados)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Observations: 1,222
## Variables: 7
## $ Esp     &amp;lt;chr&amp;gt; &amp;quot;E_camaldulensis&amp;quot;, &amp;quot;E_camaldulensis&amp;quot;, &amp;quot;E_camaldulensis...
## $ I_meses &amp;lt;dbl&amp;gt; 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34...
## $ Parc_m2 &amp;lt;dbl&amp;gt; 288, 288, 288, 288, 288, 288, 288, 288, 288, 288, 288,...
## $ N_arv   &amp;lt;dbl&amp;gt; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16,...
## $ DAP_cm  &amp;lt;dbl&amp;gt; 5.411268, 12.254931, 3.978874, 6.429860, 9.676621, 5.6...
## $ H_m     &amp;lt;dbl&amp;gt; 7.651490, 11.424046, 5.909205, 8.572873, 10.498957, 7....
## $ Vol     &amp;lt;dbl&amp;gt; 0.008798406, 0.067375427, 0.003673747, 0.013918399, 0....&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Iremos calcular o PV50 e o volume por hectare para cada fator &lt;code&gt;Esp&lt;/code&gt; e &lt;code&gt;I_meses&lt;/code&gt; e em seguida ordenar as espécies pelo PV50.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# agrupa os dados em função de espécie e idade para 
# calcular o pv50 e o volume
dados_pv50 &amp;lt;- dados %&amp;gt;% 
  group_by(Esp, I_meses) %&amp;gt;% 
  summarise(
    Parc_m2 = mean( Parc_m2),
    PV50 = pv50(Vol),
    Vol_ha = sum(Vol, na.rm = TRUE) * (10000/Parc_m2)
  ) %&amp;gt;%
  ungroup() %&amp;gt;% 
  # ordena o fator de espécies de forma decrescente em função do pv50
  mutate(Esp = fct_reorder(Esp, -PV50))

dados_pv50&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 20 x 5
##    Esp                 I_meses Parc_m2  PV50 Vol_ha
##    &amp;lt;fct&amp;gt;                 &amp;lt;dbl&amp;gt;   &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt;
##  1 E_camaldulensis          34     288  21.4   47.5
##  2 E_camaldulensis          46     288  14.3   79.1
##  3 E_camaldulensis          60     600  13.2  110. 
##  4 E_camaldulensis          85     288  12.7  204. 
##  5 E_citriodora             34     288  17.8   46.6
##  6 E_citriodora             46     288  16.4   85.0
##  7 E_citriodora             60     600  12.5   97.0
##  8 E_citriodora             85     288  12.7  205. 
##  9 E_dunnii                 34     288  28.6  103. 
## 10 E_dunnii                 46     288  29.2  161. 
## 11 E_dunnii                 60     600  27.5  198. 
## 12 E_dunnii                 85     288  26.4  350. 
## 13 E_paniculata             34     288  27.4   46.4
## 14 E_paniculata             46     288  24.1   84.4
## 15 E_paniculata             60     600  19.6  115. 
## 16 E_paniculata             85     288  18.2  195. 
## 17 E_urophylla_grandis      34     288  26.3   85.7
## 18 E_urophylla_grandis      46     288  24.2  157. 
## 19 E_urophylla_grandis      60     600  20.3  217. 
## 20 E_urophylla_grandis      85     288  17.9  277.&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Para entendermos os dados, vamos primeiro ver o crescimento em volume de cada espécies em função do tempo (Figura &lt;a href=&#34;#fig:12-vol-idade&#34;&gt;1&lt;/a&gt;). Note que &lt;em&gt;E. dunnii&lt;/em&gt; e &lt;em&gt;E. urophylla&lt;/em&gt; x &lt;em&gt;E. grandis&lt;/em&gt; tinham crescimento muito parecido até os 60 meses de idade.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggplot(dados_pv50, aes(I_meses, Vol_ha, color = Esp)) +
  geom_point() +
  geom_line() +
  labs(
    color = &amp;quot;Espécies&amp;quot;,
    x = &amp;quot;Idade (meses)&amp;quot;,
    y = Volume~m^3~ha^-1
  ) +
  scale_color_brewer(palette = &amp;quot;Set1&amp;quot;) +
  theme_bw(16) +
  theme(legend.justification = &amp;quot;top&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;figure&#34;&gt;&lt;span id=&#34;fig:12-vol-idade&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;https://italocegatta.github.io/post/2016-10-09-indice-de-uniformidade-pv50_files/figure-html/12-vol-idade-1.svg&#34; alt=&#34;Crescimento em volume por hectare em função da idade.&#34; width=&#34;960&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figura  1: Crescimento em volume por hectare em função da idade.
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Agora podemos construir um gráfico que relaciona o PV50 e a idade (Figura &lt;a href=&#34;#fig:12-pv50-idade&#34;&gt;2&lt;/a&gt;). A interpretação do índice é simples, o PV50 representa a porcentagem em volume que as 50% menores árvores contribuem para o volume total. Em nossos dados, &lt;em&gt;E. dunnii&lt;/em&gt;, aos 85 meses de idade, tem um PV50 de aproximadamente 26. Isso quer dizer que aos 7 anos, as 50% menores árvores da parcela de &lt;em&gt;E. dunnii&lt;/em&gt; representam apenas 26% do volume total. Ou seja, 50% das árvores contribuem muito pouco para o volume total da parcela e isso tem um impacto direto na produtividade.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggplot(dados_pv50, aes(I_meses, PV50, color = Esp)) +
  geom_point() +
  geom_line() +
  labs(color = &amp;quot;Espécies&amp;quot;, x = &amp;quot;Idade (meses)&amp;quot;, y = &amp;quot;PV50&amp;quot;) +
  scale_color_brewer(palette = &amp;quot;Set1&amp;quot;) +
  scale_y_continuous(breaks = seq(10, 30, 2)) +
  theme_bw(16) +
  theme(legend.justification = &amp;quot;top&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;figure&#34;&gt;&lt;span id=&#34;fig:12-pv50-idade&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;https://italocegatta.github.io/post/2016-10-09-indice-de-uniformidade-pv50_files/figure-html/12-pv50-idade-1.svg&#34; alt=&#34;Variação do PV50 por espécies em função da idade.&#34; width=&#34;960&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figura  2: Variação do PV50 por espécies em função da idade.
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;A Figura &lt;a href=&#34;#fig:12-pv50-vol&#34;&gt;3&lt;/a&gt; mostra claramente a relação direta que há entre produção de madeira e a uniformidade ao longo do crescimento da floresta. Note também que na medida em que a idade avança, a uniformidade diminui, uma vez que a dominância das árvores maiores sobre as menores fica cada vez mais forte.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggplot(dados_pv50, aes(Vol_ha, PV50)) +
  geom_point(aes(color = factor(I_meses))) +
  geom_smooth(method = &amp;quot;lm&amp;quot;, formula = y ~x, se = FALSE) +
  facet_wrap(~Esp, dir = &amp;quot;v&amp;quot;) +
  labs(color = &amp;quot;Idade (meses)&amp;quot;, x = Volume~m^3~ha^-1, y = &amp;quot;PV50&amp;quot;) +
  scale_color_brewer(palette = &amp;quot;Dark2&amp;quot;) +
  theme_bw(16) +
  theme(legend.justification = &amp;quot;top&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;figure&#34;&gt;&lt;span id=&#34;fig:12-pv50-vol&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;https://italocegatta.github.io/post/2016-10-09-indice-de-uniformidade-pv50_files/figure-html/12-pv50-vol-1.svg&#34; alt=&#34;Relação entre o PV50 e volume por hectare em função da idade.&#34; width=&#34;960&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figura  3: Relação entre o PV50 e volume por hectare em função da idade.
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Por fim, para colocar tudo em um só gráfico, podemos adicionar ao gráfico de crescimento em volume a informação do PV50 para evidenciar que as espécies mais produtivas tem PV50 elevado e que este índice consegue explicar muito bem essa relação (Figura &lt;a href=&#34;#fig:12-vol-pv50-idade&#34;&gt;4&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;Um comentário interessante é que dentre as espécies que estamos estudando, todas são de origem seminal, com exceção do &lt;em&gt;E. dunnii&lt;/em&gt;, que é um clone. Este fator explica sua produtividade e alta homogeneidade, principalmente frente ao hibrido de &lt;em&gt;E. urophylla&lt;/em&gt; x &lt;em&gt;E. grandis&lt;/em&gt;, que é seu concorrente direto. Quando estivermos analisando dados de plantios clonais, o PV50 vai expressar a qualidade silvicultural do plantio, uma vez que a base genética é a mesma em todas as plantas.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggplot(dados_pv50, aes(I_meses, Vol_ha, color = Esp)) +
  geom_point(aes(size = PV50), alpha = 0.4) +
  geom_line() +
  labs(
    color = &amp;quot;Espécies&amp;quot;,
    x = &amp;quot;Idade (meses)&amp;quot;,
    y = Volume~m^3~ha^-1
  ) +
  scale_color_brewer(palette = &amp;quot;Set1&amp;quot;) +
  theme_bw(16) +
  theme(legend.justification = &amp;quot;top&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;figure&#34;&gt;&lt;span id=&#34;fig:12-vol-pv50-idade&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;https://italocegatta.github.io/post/2016-10-09-indice-de-uniformidade-pv50_files/figure-html/12-vol-pv50-idade-1.svg&#34; alt=&#34;Crescimento do volume em função da idade, com informação do PV50 no tamanho do ponto.&#34; width=&#34;960&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figura  4: Crescimento do volume em função da idade, com informação do PV50 no tamanho do ponto.
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Caso tenha alguma dúvida ou sugestão sobre o post, fique à vontade para fazer um comentário ou me contatar por E-mail.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;sessioninfo::session_info(c(&amp;quot;readr&amp;quot;, &amp;quot;dplyr&amp;quot;, &amp;quot;ggplot2&amp;quot;, &amp;quot;forcats&amp;quot;))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## - Session info ----------------------------------------------------------
##  setting  value                       
##  version  R version 3.5.3 (2019-03-11)
##  os       Windows 10 x64              
##  system   x86_64, mingw32             
##  ui       RTerm                       
##  language (EN)                        
##  collate  Portuguese_Brazil.1252      
##  ctype    Portuguese_Brazil.1252      
##  tz       America/Sao_Paulo           
##  date     2019-08-25                  
## 
## - Packages --------------------------------------------------------------
##  package      * version  date       lib source        
##  assertthat     0.2.1    2019-03-21 [1] CRAN (R 3.5.3)
##  BH             1.69.0-1 2019-01-07 [1] CRAN (R 3.5.2)
##  cli            1.1.0    2019-03-19 [1] CRAN (R 3.5.3)
##  clipr          0.7.0    2019-07-23 [1] CRAN (R 3.5.3)
##  crayon         1.3.4    2017-09-16 [1] CRAN (R 3.5.1)
##  digest         0.6.20   2019-07-04 [1] CRAN (R 3.5.3)
##  dplyr        * 0.8.3    2019-07-04 [1] CRAN (R 3.5.3)
##  ellipsis       0.2.0.1  2019-07-02 [1] CRAN (R 3.5.3)
##  fansi          0.4.0    2018-10-05 [1] CRAN (R 3.5.1)
##  forcats      * 0.4.0    2019-02-17 [1] CRAN (R 3.5.2)
##  ggplot2      * 3.2.1    2019-08-10 [1] CRAN (R 3.5.3)
##  glue           1.3.1    2019-03-12 [1] CRAN (R 3.5.3)
##  gtable         0.3.0    2019-03-25 [1] CRAN (R 3.5.3)
##  hms            0.5.0    2019-07-09 [1] CRAN (R 3.5.3)
##  labeling       0.3      2014-08-23 [1] CRAN (R 3.5.0)
##  lazyeval       0.2.2    2019-03-15 [1] CRAN (R 3.5.3)
##  magrittr       1.5      2014-11-22 [1] CRAN (R 3.5.1)
##  MASS           7.3-51.1 2018-11-01 [2] CRAN (R 3.5.3)
##  Matrix         1.2-17   2019-03-22 [1] CRAN (R 3.5.3)
##  mgcv           1.8-28   2019-03-21 [1] CRAN (R 3.5.3)
##  munsell        0.5.0    2018-06-12 [1] CRAN (R 3.5.1)
##  nlme           3.1-137  2018-04-07 [2] CRAN (R 3.5.3)
##  pillar         1.4.2    2019-06-29 [1] CRAN (R 3.5.3)
##  pkgconfig      2.0.2    2018-08-16 [1] CRAN (R 3.5.1)
##  plogr          0.2.0    2018-03-25 [1] CRAN (R 3.5.1)
##  plyr           1.8.4    2016-06-08 [1] CRAN (R 3.5.1)
##  purrr          0.3.2    2019-03-15 [1] CRAN (R 3.5.3)
##  R6             2.4.0    2019-02-14 [1] CRAN (R 3.5.2)
##  RColorBrewer   1.1-2    2014-12-07 [1] CRAN (R 3.5.0)
##  Rcpp           1.0.2    2019-07-25 [1] CRAN (R 3.5.3)
##  readr        * 1.3.1    2018-12-21 [1] CRAN (R 3.5.2)
##  reshape2       1.4.3    2017-12-11 [1] CRAN (R 3.5.1)
##  rlang          0.4.0    2019-06-25 [1] CRAN (R 3.5.3)
##  scales         1.0.0    2018-08-09 [1] CRAN (R 3.5.1)
##  stringr        1.4.0    2019-02-10 [1] CRAN (R 3.5.2)
##  tibble         2.1.3    2019-06-06 [1] CRAN (R 3.5.3)
##  tidyselect     0.2.5    2018-10-11 [1] CRAN (R 3.5.1)
##  vctrs          0.2.0    2019-07-05 [1] CRAN (R 3.5.3)
##  viridisLite    0.3.0    2018-02-01 [1] CRAN (R 3.5.1)
##  withr          2.1.2    2018-03-15 [1] CRAN (R 3.5.1)
## 
## [1] C:/Users/Italo/Documents/R/win-library/3.5
## [2] C:/Program Files/R/R-3.5.3/library&lt;/code&gt;&lt;/pre&gt;
&lt;div id=&#34;referencias&#34; class=&#34;section level1 unnumbered&#34;&gt;
&lt;h1&gt;Referências&lt;/h1&gt;
&lt;div id=&#34;refs&#34; class=&#34;references&#34;&gt;
&lt;div id=&#34;ref-Hakamada2012&#34;&gt;
&lt;p&gt;Hakamada, Rodrigo Eiji. 2012. “Uso do inventário florestal como ferramenta de monitoramento da qualidade silvicultura em povoamentos clonais de Eucalyptus.” PhD thesis, Piracicaba: Universidade de São Paulo; Biblioteca Digital de Teses e Dissertações da Universidade de São Paulo. &lt;a href=&#34;https://doi.org/10.11606/D.11.2012.tde-05072012-100431&#34;&gt;https://doi.org/10.11606/D.11.2012.tde-05072012-100431&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;ref-Hakamada2015&#34;&gt;
&lt;p&gt;Hakamada, Rodrigo Eiji, José Luiz Stape, Cristiane Camargo Zani de Lemos, Adriano Emanuel Amaral Almeida, and Luis Fernando Silva. 2015. “Uniformidade entre árvores durante uma rotação e sua relação com a produtividade em Eucalyptus clonais.” &lt;em&gt;CERNE&lt;/em&gt; 21 (3): 465–72. &lt;a href=&#34;https://doi.org/10.1590/01047760201521031716&#34;&gt;https://doi.org/10.1590/01047760201521031716&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

      </content:encoded>
    </item>
    
    <item>
      <title>ANOVA e teste de Tukey</title>
      <link>https://italocegatta.github.io/anova-e-teste-de-tukey/</link>
      <pubDate>Thu, 08 Sep 2016 00:00:00 +0000</pubDate>
      
      <guid>https://italocegatta.github.io/anova-e-teste-de-tukey/</guid>
      <description>Análise de variância (ANOVA) e testes de médias são métodos comuns em artigos científicos. Você com certeza já viu aquelas letrinhas indicando a diferença entre tratamentos em algum estudo publicado. Por mais que este método esteja entrando em desuso - há uma tendência em abandonar esse tipo de abordagem estatística - penso que ainda o veremos por muitos anos no meio científico.
Como contexto, temos um teste de 5 progênies de eucalipto e queremos avaliar se volume por hectare (nossa variável resposta), difere entre os tratamentos.</description>
      <content:encoded>
        


&lt;p&gt;Análise de variância (ANOVA) e testes de médias são métodos comuns em artigos científicos. Você com certeza já viu aquelas letrinhas indicando a diferença entre tratamentos em algum estudo publicado. Por mais que este método esteja entrando em desuso - há uma tendência em abandonar esse tipo de abordagem estatística - penso que ainda o veremos por muitos anos no meio científico.&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;Como contexto, temos um teste de 5 progênies de eucalipto e queremos avaliar se volume por hectare (nossa variável resposta), difere entre os tratamentos.&lt;/p&gt;
&lt;p&gt;Pois bem, para percebermos a dimensão dos dados e qual a variabilidade de cada tratamento, vamos criar um boxplot (Figura &lt;a href=&#34;#fig:10-boxplot&#34;&gt;1&lt;/a&gt;). Caso você queira saber um pouco mais sobre este tipo de gráfico, veja o &lt;a href=&#34;https://italocegatta.github.io/os-graficos-que-explicam-nossos-dados-boxplot&#34;&gt;post sobre ele&lt;/a&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;if (!require(&amp;quot;pacman&amp;quot;)) install.packages(&amp;quot;pacman&amp;quot;)
pacman::p_load(readr, dplyr, tibble, ggplot2, car, agricolae)&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;dados &amp;lt;- read_csv2(
  &amp;quot;https://github.com/italocegatta/italocegatta.github.io_source/raw/master/content/dados/base_progenie.csv&amp;quot;
)

dados&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 30 x 3
##    repeticao progenie volume
##        &amp;lt;dbl&amp;gt; &amp;lt;chr&amp;gt;     &amp;lt;dbl&amp;gt;
##  1         1 A           212
##  2         2 A           206
##  3         3 A           224
##  4         4 A           289
##  5         5 A           324
##  6         6 A           219
##  7         1 B           108
##  8         2 B           194
##  9         3 B           163
## 10         4 B           111
## # ... with 20 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggplot(dados, aes(progenie, volume)) +
  geom_boxplot(fill = &amp;quot;grey60&amp;quot;, alpha = 0.8) +
  theme_bw(16)&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;figure&#34;&gt;&lt;span id=&#34;fig:10-boxplot&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;https://italocegatta.github.io/post/2016-09-08-anova-e-teste-de-tukey_files/figure-html/10-boxplot-1.svg&#34; alt=&#34;Variabilidade do volume por hectare de cada tratamento.&#34; width=&#34;960&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figura  1: Variabilidade do volume por hectare de cada tratamento.
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;A ANOVA é um método bastante consolidado no meio acadêmico. Basicamente, este método informa se existe um tratamento discrepante dentre os demais. Entretanto, ele exige que algumas premissas sejam atendidas, como: distribuição normal dos resíduos e homogeneidade de variância.&lt;/p&gt;
&lt;p&gt;Primeiro, vamos utilizar o teste de Levene para verificar se há homogeneidade de variância, ou homocedasticidade. Como o p-valor é maior que 5% não temos evidência significativa para rejeitar a hipótese nula de homogeneidade, ou seja, nossos dados tem homogeneidade de variância.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;leveneTest(volume ~ factor(progenie), data=dados)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Levene&amp;#39;s Test for Homogeneity of Variance (center = median)
##       Df F value  Pr(&amp;gt;F)  
## group  4  2.4677 0.07086 .
##       25                  
## ---
## Signif. codes:  0 &amp;#39;***&amp;#39; 0.001 &amp;#39;**&amp;#39; 0.01 &amp;#39;*&amp;#39; 0.05 &amp;#39;.&amp;#39; 0.1 &amp;#39; &amp;#39; 1&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;O segundo pressuposto é a normalidade dos resíduos. Utilizaremos o teste de Shapiro-Wilk cuja hipótese nula é a de que os dados seguem uma distribuição normal. Como o p-valor é superior ao limite de 5%, podemos aceitar a hipótese nula e considerar nossos dados normais.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;anova &amp;lt;-  aov(volume ~ progenie, data=dados)

shapiro.test(resid(anova))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 
##  Shapiro-Wilk normality test
## 
## data:  resid(anova)
## W = 0.96097, p-value = 0.3279&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Uma vez que os pressupostos foram atendidos, seguiremos para a ANOVA. Note que, caso os testes de Levene e Shapiro-Wilk resultassem em um p-valor significante, ou seja, menor que 5%, teríamos que utilizar outro método estatístico para analisar nossos dados. Nesse caso, uma alternativa é utilizar testes não-paramétricos, uma vez que eles não exigem os pressupostos que acabamos de testar.&lt;/p&gt;
&lt;p&gt;Nossa ANOVA resultou em um p-valor menor que 5%, portanto, temos evidências de que ao menos um tratamento se diferencia dos demais. Isso já é uma resposta, mas pouco acrescenta à nossa pesquisa pois queremos saber quem é este tratamento discrepante. Ou melhor, queremos poder comparar os tratamentos entre si e verificar quais são estatisticamente iguais ou diferentes.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;summary(anova)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##             Df Sum Sq Mean Sq F value   Pr(&amp;gt;F)    
## progenie     4  86726   21681    8.89 0.000131 ***
## Residuals   25  60974    2439                     
## ---
## Signif. codes:  0 &amp;#39;***&amp;#39; 0.001 &amp;#39;**&amp;#39; 0.01 &amp;#39;*&amp;#39; 0.05 &amp;#39;.&amp;#39; 0.1 &amp;#39; &amp;#39; 1&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Para esta abordagem existem alguns testes de médias e cada um tem uma particularidade, mas de longe o mais utilizado é o de Tukey.&lt;/p&gt;
&lt;p&gt;A interpretação do teste de Tukey é simples. Após determinarmos a diferença mínima significativa (ou Honest Significant Difference - HSD), podemos julgar se as médias são iguais ou não. Em termos práticos, esse valor nos dá uma margem de igualdade, pois se a diferença entre dois tratamentos for maior do que isso, os médias são diferentes.&lt;/p&gt;
&lt;p&gt;A análise começa sempre pela maior média, no nosso caso a progênie A (245, 66). Com uma continha rápida, a média do tratamento A menos a diferença mínima significativa &lt;code&gt;245,66 - 83,73 = 161,93&lt;/code&gt;, aceitaremos que um tratamento é igual ao A se a média dele for maior que 161,93. O tratamento subsequente (o segundo do ranking) é a progênie D e como sua média é maior que 161,93 podemos dizer que ela é estatisticamente igual a progênie A.&lt;/p&gt;
&lt;p&gt;As próximas comparações seguem a mesma lógica. Quando registramos que duas médias são iguais, nós as rotulamos com a mesma letra para facilitar a identificação. Veja no fim do output as letras evidenciando a igualdade entre os tratamentos.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;tukey &amp;lt;- HSD.test(anova, &amp;quot;progenie&amp;quot;)

tukey&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## $statistics
##    MSerror Df     Mean       CV      MSD
##   2438.953 25 165.7667 29.79233 83.73866
## 
## $parameters
##    test   name.t ntr StudentizedRange alpha
##   Tukey progenie   5         4.153363  0.05
## 
## $means
##     volume      std r Min Max    Q25   Q50    Q75
## A 245.6667 48.78798 6 206 324 213.75 221.5 272.75
## B 159.6667 49.47996 6 108 236 119.75 154.5 186.25
## C  80.5000 15.60449 6  63 100  70.00  76.5  93.50
## D 190.1667 75.37484 6 100 267 121.75 207.0 251.75
## E 152.8333 37.96534 6 106 210 133.75 141.5 175.50
## 
## $comparison
## NULL
## 
## $groups
##     volume groups
## A 245.6667      a
## D 190.1667     ab
## B 159.6667     bc
## E 152.8333     bc
## C  80.5000      c
## 
## attr(,&amp;quot;class&amp;quot;)
## [1] &amp;quot;group&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Para deixar mais visual ainda, podemos construir um gráfico de barras com a média de cada tratamento e adicionar a sua letra correspondente ao teste de Tukey (Figura &lt;a href=&#34;#fig:10-barras-tukey&#34;&gt;2&lt;/a&gt;).&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;tukey$groups %&amp;gt;% 
  rownames_to_column(var = &amp;quot;trt&amp;quot;) %&amp;gt;% 
  mutate(trt = reorder(trt, -volume, mean)) %&amp;gt;% 
  ggplot(aes(trt, volume)) +
    geom_col(alpha = 0.8, color = &amp;quot;black&amp;quot;) +
    geom_text(aes(label = groups), vjust = 1.8, size = 9, color = &amp;quot;white&amp;quot;) +
    labs(x = &amp;quot;Progênies&amp;quot;, y = &amp;quot;Médias&amp;quot;) +
    theme_bw(16)&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;figure&#34;&gt;&lt;span id=&#34;fig:10-barras-tukey&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;https://italocegatta.github.io/post/2016-09-08-anova-e-teste-de-tukey_files/figure-html/10-barras-tukey-1.svg&#34; alt=&#34;Médias dos tratamentos. As letras indicam médias estatisticamente iguais pelo teste de Tukey a 5% de significância.&#34; width=&#34;960&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figura  2: Médias dos tratamentos. As letras indicam médias estatisticamente iguais pelo teste de Tukey a 5% de significância.
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Caso tenha alguma dúvida ou sugestão sobre o post, fique à vontade para fazer um comentário ou me contatar por E-mail.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;sessioninfo::session_info(c(&amp;quot;readr&amp;quot;, &amp;quot;dplyr&amp;quot;, &amp;quot;tibble&amp;quot;, &amp;quot;ggplot2&amp;quot;, &amp;quot;car&amp;quot;, &amp;quot;agricolae&amp;quot;))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## - Session info ----------------------------------------------------------
##  setting  value                       
##  version  R version 3.5.3 (2019-03-11)
##  os       Windows 10 x64              
##  system   x86_64, mingw32             
##  ui       RTerm                       
##  language (EN)                        
##  collate  Portuguese_Brazil.1252      
##  ctype    Portuguese_Brazil.1252      
##  tz       America/Sao_Paulo           
##  date     2019-08-25                  
## 
## - Packages --------------------------------------------------------------
##  package      * version   date       lib source        
##  abind          1.4-5     2016-07-21 [1] CRAN (R 3.5.0)
##  agricolae    * 1.3-1     2019-04-04 [1] CRAN (R 3.5.3)
##  AlgDesign      1.1-7.3   2014-10-15 [1] CRAN (R 3.5.2)
##  assertthat     0.2.1     2019-03-21 [1] CRAN (R 3.5.3)
##  backports      1.1.4     2019-04-10 [1] CRAN (R 3.5.3)
##  BH             1.69.0-1  2019-01-07 [1] CRAN (R 3.5.2)
##  boot           1.3-20    2017-08-06 [2] CRAN (R 3.5.3)
##  car          * 3.0-3     2019-05-27 [1] CRAN (R 3.5.3)
##  carData      * 3.0-2     2018-09-30 [1] CRAN (R 3.5.2)
##  cellranger     1.1.0     2016-07-27 [1] CRAN (R 3.5.1)
##  class          7.3-15    2019-01-01 [2] CRAN (R 3.5.3)
##  classInt       0.4-1     2019-08-06 [1] CRAN (R 3.5.3)
##  cli            1.1.0     2019-03-19 [1] CRAN (R 3.5.3)
##  clipr          0.7.0     2019-07-23 [1] CRAN (R 3.5.3)
##  cluster        2.0.7-1   2018-04-13 [2] CRAN (R 3.5.3)
##  coda           0.19-3    2019-07-05 [1] CRAN (R 3.5.3)
##  colorspace     1.4-1     2019-03-18 [1] CRAN (R 3.5.3)
##  combinat       0.0-8     2012-10-29 [1] CRAN (R 3.5.2)
##  crayon         1.3.4     2017-09-16 [1] CRAN (R 3.5.1)
##  curl           4.0       2019-07-22 [1] CRAN (R 3.5.3)
##  data.table     1.12.2    2019-04-07 [1] CRAN (R 3.5.3)
##  DBI            1.0.0     2018-05-02 [1] CRAN (R 3.5.1)
##  deldir         0.1-23    2019-07-31 [1] CRAN (R 3.5.3)
##  digest         0.6.20    2019-07-04 [1] CRAN (R 3.5.3)
##  dplyr        * 0.8.3     2019-07-04 [1] CRAN (R 3.5.3)
##  e1071          1.7-2     2019-06-05 [1] CRAN (R 3.5.3)
##  ellipsis       0.2.0.1   2019-07-02 [1] CRAN (R 3.5.3)
##  expm           0.999-4   2019-03-21 [1] CRAN (R 3.5.3)
##  fansi          0.4.0     2018-10-05 [1] CRAN (R 3.5.1)
##  forcats        0.4.0     2019-02-17 [1] CRAN (R 3.5.2)
##  foreign        0.8-71    2018-07-20 [2] CRAN (R 3.5.3)
##  gdata          2.18.0    2017-06-06 [1] CRAN (R 3.5.2)
##  ggplot2      * 3.2.1     2019-08-10 [1] CRAN (R 3.5.3)
##  glue           1.3.1     2019-03-12 [1] CRAN (R 3.5.3)
##  gmodels        2.18.1    2018-06-25 [1] CRAN (R 3.5.2)
##  gtable         0.3.0     2019-03-25 [1] CRAN (R 3.5.3)
##  gtools         3.8.1     2018-06-26 [1] CRAN (R 3.5.2)
##  haven          2.1.1     2019-07-04 [1] CRAN (R 3.5.3)
##  highr          0.8       2019-03-20 [1] CRAN (R 3.5.3)
##  hms            0.5.0     2019-07-09 [1] CRAN (R 3.5.3)
##  htmltools      0.3.6     2017-04-28 [1] CRAN (R 3.5.1)
##  httpuv         1.5.1     2019-04-05 [1] CRAN (R 3.5.3)
##  jsonlite       1.6       2018-12-07 [1] CRAN (R 3.5.2)
##  KernSmooth     2.23-15   2015-06-29 [2] CRAN (R 3.5.3)
##  klaR           0.6-14    2018-03-19 [1] CRAN (R 3.5.2)
##  labeling       0.3       2014-08-23 [1] CRAN (R 3.5.0)
##  labelled       2.2.1     2019-05-26 [1] CRAN (R 3.5.3)
##  later          0.8.0     2019-02-11 [1] CRAN (R 3.5.2)
##  lattice        0.20-38   2018-11-04 [2] CRAN (R 3.5.3)
##  lazyeval       0.2.2     2019-03-15 [1] CRAN (R 3.5.3)
##  LearnBayes     2.15.1    2018-03-18 [1] CRAN (R 3.5.2)
##  lme4           1.1-21    2019-03-05 [1] CRAN (R 3.5.3)
##  magrittr       1.5       2014-11-22 [1] CRAN (R 3.5.1)
##  maptools       0.9-5     2019-02-18 [1] CRAN (R 3.5.2)
##  MASS           7.3-51.1  2018-11-01 [2] CRAN (R 3.5.3)
##  Matrix         1.2-17    2019-03-22 [1] CRAN (R 3.5.3)
##  MatrixModels   0.4-1     2015-08-22 [1] CRAN (R 3.5.2)
##  mgcv           1.8-28    2019-03-21 [1] CRAN (R 3.5.3)
##  mime           0.7       2019-06-11 [1] CRAN (R 3.5.3)
##  miniUI         0.1.1.1   2018-05-18 [1] CRAN (R 3.5.2)
##  minqa          1.2.4     2014-10-09 [1] CRAN (R 3.5.1)
##  munsell        0.5.0     2018-06-12 [1] CRAN (R 3.5.1)
##  nlme           3.1-137   2018-04-07 [2] CRAN (R 3.5.3)
##  nloptr         1.2.1     2018-10-03 [1] CRAN (R 3.5.1)
##  nnet           7.3-12    2016-02-02 [2] CRAN (R 3.5.3)
##  openxlsx       4.1.0.1   2019-05-28 [1] CRAN (R 3.5.3)
##  pbkrtest       0.4-7     2017-03-15 [1] CRAN (R 3.5.2)
##  pillar         1.4.2     2019-06-29 [1] CRAN (R 3.5.3)
##  pkgconfig      2.0.2     2018-08-16 [1] CRAN (R 3.5.1)
##  plogr          0.2.0     2018-03-25 [1] CRAN (R 3.5.1)
##  plyr           1.8.4     2016-06-08 [1] CRAN (R 3.5.1)
##  prettyunits    1.0.2     2015-07-13 [1] CRAN (R 3.5.1)
##  progress       1.2.2     2019-05-16 [1] CRAN (R 3.5.3)
##  promises       1.0.1     2018-04-13 [1] CRAN (R 3.5.1)
##  purrr          0.3.2     2019-03-15 [1] CRAN (R 3.5.3)
##  quantreg       5.51      2019-08-07 [1] CRAN (R 3.5.3)
##  questionr      0.7.0     2018-11-26 [1] CRAN (R 3.5.2)
##  R6             2.4.0     2019-02-14 [1] CRAN (R 3.5.2)
##  RColorBrewer   1.1-2     2014-12-07 [1] CRAN (R 3.5.0)
##  Rcpp           1.0.2     2019-07-25 [1] CRAN (R 3.5.3)
##  RcppEigen      0.3.3.5.0 2018-11-24 [1] CRAN (R 3.5.1)
##  readr        * 1.3.1     2018-12-21 [1] CRAN (R 3.5.2)
##  readxl         1.3.1     2019-03-13 [1] CRAN (R 3.5.3)
##  rematch        1.0.1     2016-04-21 [1] CRAN (R 3.5.1)
##  reshape2       1.4.3     2017-12-11 [1] CRAN (R 3.5.1)
##  rio            0.5.16    2018-11-26 [1] CRAN (R 3.5.2)
##  rlang          0.4.0     2019-06-25 [1] CRAN (R 3.5.3)
##  rstudioapi     0.10      2019-03-19 [1] CRAN (R 3.5.3)
##  scales         1.0.0     2018-08-09 [1] CRAN (R 3.5.1)
##  sf             0.7-7     2019-07-24 [1] CRAN (R 3.5.3)
##  shiny          1.3.2     2019-04-22 [1] CRAN (R 3.5.3)
##  sourcetools    0.1.7     2018-04-25 [1] CRAN (R 3.5.1)
##  sp             1.3-1     2018-06-05 [1] CRAN (R 3.5.1)
##  SparseM        1.77      2017-04-23 [1] CRAN (R 3.5.2)
##  spData         0.3.0     2019-01-07 [1] CRAN (R 3.5.2)
##  spdep          1.1-2     2019-04-05 [1] CRAN (R 3.5.3)
##  stringi        1.4.3     2019-03-12 [1] CRAN (R 3.5.3)
##  stringr        1.4.0     2019-02-10 [1] CRAN (R 3.5.2)
##  tibble       * 2.1.3     2019-06-06 [1] CRAN (R 3.5.3)
##  tidyselect     0.2.5     2018-10-11 [1] CRAN (R 3.5.1)
##  units          0.6-3     2019-05-03 [1] CRAN (R 3.5.3)
##  utf8           1.1.4     2018-05-24 [1] CRAN (R 3.5.1)
##  vctrs          0.2.0     2019-07-05 [1] CRAN (R 3.5.3)
##  viridisLite    0.3.0     2018-02-01 [1] CRAN (R 3.5.1)
##  withr          2.1.2     2018-03-15 [1] CRAN (R 3.5.1)
##  xtable         1.8-4     2019-04-21 [1] CRAN (R 3.5.3)
##  zeallot        0.1.0     2018-01-28 [1] CRAN (R 3.5.2)
##  zip            2.0.3     2019-07-03 [1] CRAN (R 3.5.3)
## 
## [1] C:/Users/Italo/Documents/R/win-library/3.5
## [2] C:/Program Files/R/R-3.5.3/library&lt;/code&gt;&lt;/pre&gt;

      </content:encoded>
    </item>
    
    <item>
      <title>Ajuste de um modelo linear para vários fatores</title>
      <link>https://italocegatta.github.io/ajuste-de-um-modelo-linear-para-varios-fatores/</link>
      <pubDate>Sat, 27 Aug 2016 00:00:00 +0000</pubDate>
      
      <guid>https://italocegatta.github.io/ajuste-de-um-modelo-linear-para-varios-fatores/</guid>
      <description>Ajustar um modelo linear ou não linear é algo relativamente simples no R. Mas em muitos casos precisamos ajustá-lo para vários fatores e dependendo da quantidade isso se torna uma tarefa chata. Se você, assim como eu, já precisou fazer isso no Excel, sabe o que é perder mais que uma tarde copiando e colando informações entres abas e planilhas.
Mas felizmente existe uma máxima muito interessante entre programadores que é:</description>
      <content:encoded>
        


&lt;p&gt;Ajustar um modelo linear ou não linear é algo relativamente simples no R. Mas em muitos casos precisamos ajustá-lo para vários fatores e dependendo da quantidade isso se torna uma tarefa chata. Se você, assim como eu, já precisou fazer isso no Excel, sabe o que é perder mais que uma tarde copiando e colando informações entres abas e planilhas.&lt;br /&gt;
&lt;!-- more --&gt;&lt;/p&gt;
&lt;p&gt;Mas felizmente existe uma máxima muito interessante entre programadores que é:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Don’t Repeat Yourself (DRY)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Depois que eu percebi o quanto a repetição humana gera erros, abracei totalmente o conceito DRY. Acreditem, vocês serão muito mais felizes e eficientes deixando o computador fazer as tarefas repetitivas e chatas.&lt;/p&gt;
&lt;p&gt;Para exemplificar, vamos fazer algo muito comum nas ciências florestais, que é predizer as alturas das árvores. Medir a altura da árvore é uma atividade laboriosa, e há muito tempo se sabe que a altura total das árvores possui alta correlação com o seu diâmetro.&lt;/p&gt;
&lt;p&gt;Utilizaremos mais uma vez os dados do &lt;a href=&#34;www.projetotume.com&#34;&gt;Projeto TUME&lt;/a&gt;, referente a medição de 24 meses do TUME 55 plantado no Mato Grosso do Sul.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;if (!require(&amp;quot;pacman&amp;quot;)) install.packages(&amp;quot;pacman&amp;quot;)
pacman::p_load(readr, dplyr, tidyr, broom, purrr, ggplot2)&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;dados &amp;lt;- read_csv2(
  &amp;quot;https://github.com/italocegatta/italocegatta.github.io_source/raw/master/content/dados/tume_55_24.csv&amp;quot;
)

dados&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 1,881 x 9
##    N_tume I_meses Esp          Parc_m2 N_arv DAP_cm   H_m   Cod  Cod2
##     &amp;lt;dbl&amp;gt;   &amp;lt;dbl&amp;gt; &amp;lt;chr&amp;gt;          &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt;
##  1     55      24 E_botryoides     600     1    4.1   6.5    NA    NA
##  2     55      24 E_botryoides     600     2    9.7   8      NA    NA
##  3     55      24 E_botryoides     600     3   NA    NA       5    NA
##  4     55      24 E_botryoides     600     4    7.6   7.5     2    NA
##  5     55      24 E_botryoides     600     5    3.8   5      NA    NA
##  6     55      24 E_botryoides     600     6   NA    NA       1    NA
##  7     55      24 E_botryoides     600     7   12.6   9       6    NA
##  8     55      24 E_botryoides     600     8   NA    NA       1    NA
##  9     55      24 E_botryoides     600     9    7     8      NA    NA
## 10     55      24 E_botryoides     600    10    7.5   7.5    NA    NA
## # ... with 1,871 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Nosso objetivo é simples: ajustar um modelo hipsométrico para cada espécie e em seguida predizer as alturas das árvores. A Figura &lt;a href=&#34;#fig:9-dap-h&#34;&gt;1&lt;/a&gt; mostra a relação que teríamos se fosse ajustado apenas um modelo para todas as espécies.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggplot(dados, aes(DAP_cm, H_m)) +
  geom_point(alpha=0.4) +
  geom_smooth(method=&amp;quot;lm&amp;quot;) +
  theme_bw(16)&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;figure&#34;&gt;&lt;span id=&#34;fig:9-dap-h&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;https://italocegatta.github.io/post/2016-08-27-ajuste-de-um-modelo-linear-para-varios-fatores_files/figure-html/9-dap-h-1.svg&#34; alt=&#34;Relação entre o diâmetro e a altura sem distinção de espécie.&#34; width=&#34;960&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figura  1: Relação entre o diâmetro e a altura sem distinção de espécie.
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Mas na prática, a relação diâmetro-altura é diferente entre espécie, como pode ser notado na Figura &lt;a href=&#34;#fig:9-dap-h-spp&#34;&gt;2&lt;/a&gt;. Talvez fique mais evidente a diferença observando os coeficientes dos modelos que serão ajustados a seguir.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggplot(dados, aes(DAP_cm, H_m)) +
  geom_point(alpha=0.4) +
  geom_smooth(method=&amp;quot;lm&amp;quot;) +
  facet_wrap(~Esp) +
  theme_bw(16)&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;figure&#34;&gt;&lt;span id=&#34;fig:9-dap-h-spp&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;https://italocegatta.github.io/post/2016-08-27-ajuste-de-um-modelo-linear-para-varios-fatores_files/figure-html/9-dap-h-spp-1.svg&#34; alt=&#34;Relação entre o diâmetro e a altura por espécie.&#34; width=&#34;960&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figura  2: Relação entre o diâmetro e a altura por espécie.
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;A primeira etapa é entender que um data.frame pode conter vários tipos de elementos, como números, caracteres, listas e também outros data.frames. Para isso utilizaremos a função &lt;code&gt;nest()&lt;/code&gt; do pacote &lt;code&gt;tidyr&lt;/code&gt; e aninharemos os dados em função das espécies.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;dados %&amp;gt;%
  group_by(Esp) %&amp;gt;% 
  nest()&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 24 x 2
##    Esp                     data             
##    &amp;lt;chr&amp;gt;                   &amp;lt;list&amp;gt;           
##  1 E_botryoides            &amp;lt;tibble [80 x 8]&amp;gt;
##  2 E_brassiana             &amp;lt;tibble [80 x 8]&amp;gt;
##  3 E_camaldulensis         &amp;lt;tibble [80 x 8]&amp;gt;
##  4 E_citriodora            &amp;lt;tibble [80 x 8]&amp;gt;
##  5 E_cloeziana             &amp;lt;tibble [51 x 8]&amp;gt;
##  6 E_dunnii_urophylla      &amp;lt;tibble [80 x 8]&amp;gt;
##  7 E_exserta               &amp;lt;tibble [80 x 8]&amp;gt;
##  8 E_grandis_AT            &amp;lt;tibble [80 x 8]&amp;gt;
##  9 E_grandis_camaldulensis &amp;lt;tibble [80 x 8]&amp;gt;
## 10 E_grandis_CH            &amp;lt;tibble [80 x 8]&amp;gt;
## # ... with 14 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Agora podemos ajustar um modelo de regressão para cada espécie utilizando a função &lt;code&gt;map&lt;/code&gt;,do pacote &lt;code&gt;purrr&lt;/code&gt;. Podemos ainda extrair as informações desses modelos com as funções &lt;code&gt;glance&lt;/code&gt;, &lt;code&gt;tidy&lt;/code&gt; e &lt;code&gt;augment&lt;/code&gt;, do pacote &lt;code&gt;broom&lt;/code&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;dados_modl &amp;lt;- dados %&amp;gt;%
  group_by(Esp) %&amp;gt;% 
  nest() %&amp;gt;% 
  mutate(
    ajuste = data %&amp;gt;% map(~ lm(log(H_m) ~ I(1/DAP_cm), data = .)),
    resumo = map(ajuste, glance),
    coef = map(ajuste, tidy),
    resid = map(ajuste, augment)
  )

dados_modl&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 24 x 6
##    Esp             data         ajuste resumo       coef       resid       
##    &amp;lt;chr&amp;gt;           &amp;lt;list&amp;gt;       &amp;lt;list&amp;gt; &amp;lt;list&amp;gt;       &amp;lt;list&amp;gt;     &amp;lt;list&amp;gt;      
##  1 E_botryoides    &amp;lt;tibble [80~ &amp;lt;lm&amp;gt;   &amp;lt;tibble [1 ~ &amp;lt;tibble [~ &amp;lt;tibble [66~
##  2 E_brassiana     &amp;lt;tibble [80~ &amp;lt;lm&amp;gt;   &amp;lt;tibble [1 ~ &amp;lt;tibble [~ &amp;lt;tibble [61~
##  3 E_camaldulensis &amp;lt;tibble [80~ &amp;lt;lm&amp;gt;   &amp;lt;tibble [1 ~ &amp;lt;tibble [~ &amp;lt;tibble [78~
##  4 E_citriodora    &amp;lt;tibble [80~ &amp;lt;lm&amp;gt;   &amp;lt;tibble [1 ~ &amp;lt;tibble [~ &amp;lt;tibble [69~
##  5 E_cloeziana     &amp;lt;tibble [51~ &amp;lt;lm&amp;gt;   &amp;lt;tibble [1 ~ &amp;lt;tibble [~ &amp;lt;tibble [31~
##  6 E_dunnii_uroph~ &amp;lt;tibble [80~ &amp;lt;lm&amp;gt;   &amp;lt;tibble [1 ~ &amp;lt;tibble [~ &amp;lt;tibble [72~
##  7 E_exserta       &amp;lt;tibble [80~ &amp;lt;lm&amp;gt;   &amp;lt;tibble [1 ~ &amp;lt;tibble [~ &amp;lt;tibble [71~
##  8 E_grandis_AT    &amp;lt;tibble [80~ &amp;lt;lm&amp;gt;   &amp;lt;tibble [1 ~ &amp;lt;tibble [~ &amp;lt;tibble [78~
##  9 E_grandis_cama~ &amp;lt;tibble [80~ &amp;lt;lm&amp;gt;   &amp;lt;tibble [1 ~ &amp;lt;tibble [~ &amp;lt;tibble [69~
## 10 E_grandis_CH    &amp;lt;tibble [80~ &amp;lt;lm&amp;gt;   &amp;lt;tibble [1 ~ &amp;lt;tibble [~ &amp;lt;tibble [69~
## # ... with 14 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Da mesma forma que aninhamos os dados por espécie, podemos retorná-los para o formato original, mas agora mostrando apenas as informações que realmente interessam.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;dados_modl %&amp;gt;%
  select(Esp, resumo) %&amp;gt;% 
  unnest(resumo)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 24 x 12
##    Esp   r.squared adj.r.squared  sigma statistic  p.value    df logLik
##    &amp;lt;chr&amp;gt;     &amp;lt;dbl&amp;gt;         &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt;     &amp;lt;dbl&amp;gt;    &amp;lt;dbl&amp;gt; &amp;lt;int&amp;gt;  &amp;lt;dbl&amp;gt;
##  1 E_bo~     0.787         0.783 0.136      236.  3.85e-23     2   38.9
##  2 E_br~     0.703         0.698 0.160      140.  3.26e-17     2   26.2
##  3 E_ca~     0.719         0.716 0.128      195.  1.14e-22     2   50.8
##  4 E_ci~     0.602         0.596 0.102      101.  4.98e-15     2   60.4
##  5 E_cl~     0.260         0.234 0.167       10.2 3.42e- 3     2   12.5
##  6 E_du~     0.720         0.716 0.161      180.  5.03e-21     2   30.3
##  7 E_ex~     0.590         0.584 0.196       99.2 5.52e-15     2   16.1
##  8 E_gr~     0.747         0.744 0.0772     225.  2.12e-24     2   90.1
##  9 E_gr~     0.829         0.827 0.161      325.  2.11e-27     2   29.2
## 10 E_gr~     0.776         0.773 0.105      233.  1.75e-23     2   58.8
## # ... with 14 more rows, and 4 more variables: AIC &amp;lt;dbl&amp;gt;, BIC &amp;lt;dbl&amp;gt;,
## #   deviance &amp;lt;dbl&amp;gt;, df.residual &amp;lt;int&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;dados_modl %&amp;gt;%
  select(Esp, coef ) %&amp;gt;% 
  unnest(coef)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 48 x 6
##    Esp             term        estimate std.error statistic  p.value
##    &amp;lt;chr&amp;gt;           &amp;lt;chr&amp;gt;          &amp;lt;dbl&amp;gt;     &amp;lt;dbl&amp;gt;     &amp;lt;dbl&amp;gt;    &amp;lt;dbl&amp;gt;
##  1 E_botryoides    (Intercept)     2.63    0.0422     62.3  5.04e-59
##  2 E_botryoides    I(1/DAP_cm)    -4.13    0.269     -15.4  3.85e-23
##  3 E_brassiana     (Intercept)     2.01    0.0511     39.4  4.39e-44
##  4 E_brassiana     I(1/DAP_cm)    -2.37    0.201     -11.8  3.26e-17
##  5 E_camaldulensis (Intercept)     2.73    0.0461     59.2  2.33e-65
##  6 E_camaldulensis I(1/DAP_cm)    -4.79    0.343     -14.0  1.14e-22
##  7 E_citriodora    (Intercept)     2.55    0.0551     46.3  1.31e-52
##  8 E_citriodora    I(1/DAP_cm)    -3.80    0.378     -10.1  4.98e-15
##  9 E_cloeziana     (Intercept)     2.32    0.116      20.1  1.50e-18
## 10 E_cloeziana     I(1/DAP_cm)    -2.84    0.892      -3.19 3.42e- 3
## # ... with 38 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;dados_modl %&amp;gt;%
  select(Esp, resid) %&amp;gt;% 
  unnest(resid)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 1,633 x 11
##    Esp   .rownames log.H_m. I.1.DAP_cm. .fitted .se.fit   .resid   .hat
##    &amp;lt;chr&amp;gt; &amp;lt;chr&amp;gt;        &amp;lt;dbl&amp;gt;       &amp;lt;dbl&amp;gt;   &amp;lt;dbl&amp;gt;   &amp;lt;dbl&amp;gt;    &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt;
##  1 E_bo~ 1             1.87      0.244     1.63  0.0317  0.246   0.0539
##  2 E_bo~ 2             2.08      0.103     2.21  0.0201 -0.128   0.0217
##  3 E_bo~ 4             2.01      0.132     2.09  0.0171 -0.0751  0.0158
##  4 E_bo~ 5             1.61      0.263     1.55  0.0361  0.0628  0.0702
##  5 E_bo~ 7             2.20      0.0794    2.31  0.0242 -0.108   0.0315
##  6 E_bo~ 9             2.08      0.143     2.04  0.0168  0.0360  0.0152
##  7 E_bo~ 10            2.01      0.133     2.08  0.0170 -0.0678  0.0156
##  8 E_bo~ 13            1.61      0.167     1.95  0.0178 -0.336   0.0171
##  9 E_bo~ 14            2.30      0.0980    2.23  0.0209  0.0741  0.0234
## 10 E_bo~ 15            2.14      0.120     2.14  0.0180  0.00425 0.0173
## # ... with 1,623 more rows, and 3 more variables: .sigma &amp;lt;dbl&amp;gt;,
## #   .cooksd &amp;lt;dbl&amp;gt;, .std.resid &amp;lt;dbl&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Após o ajuste do modelo, temos de predizer as alturas. O único adendo para esse comando é que precisamos fazer em duas etapas, uma utilizando a função &lt;code&gt;predict&lt;/code&gt; e outra para trazer o valor predito para a escala natural, pois o modelo foi ajustado na escala logarítmica.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;dados_pred &amp;lt;- dados_modl %&amp;gt;% 
  mutate(
    hpred = map2(ajuste, data, predict),
    hpred = map(hpred, exp)
  ) %&amp;gt;%
  select(Esp, data, hpred)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Por fim, temos de volta um data.frame com as alturas preditas. Por mais que o ajuste tenha ficado razoável, na prática a construção de modelos de relação hipsométrica envolvem outras etapas e um maior rigor em termos estatísticos.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;dados_compl &amp;lt;- dados_pred %&amp;gt;%
  unnest(hpred, data)

dados_compl&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 1,881 x 10
##    Esp          hpred N_tume I_meses Parc_m2 N_arv DAP_cm   H_m   Cod  Cod2
##    &amp;lt;chr&amp;gt;        &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt;   &amp;lt;dbl&amp;gt;   &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt;
##  1 E_botryoides  5.08     55      24     600     1    4.1   6.5    NA    NA
##  2 E_botryoides  9.09     55      24     600     2    9.7   8      NA    NA
##  3 E_botryoides NA        55      24     600     3   NA    NA       5    NA
##  4 E_botryoides  8.08     55      24     600     4    7.6   7.5     2    NA
##  5 E_botryoides  4.70     55      24     600     5    3.8   5      NA    NA
##  6 E_botryoides NA        55      24     600     6   NA    NA       1    NA
##  7 E_botryoides 10.0      55      24     600     7   12.6   9       6    NA
##  8 E_botryoides NA        55      24     600     8   NA    NA       1    NA
##  9 E_botryoides  7.72     55      24     600     9    7     8      NA    NA
## 10 E_botryoides  8.03     55      24     600    10    7.5   7.5    NA    NA
## # ... with 1,871 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Caso tenha alguma dúvida ou sugestão sobre o post, fique à vontade para fazer um comentário ou me contatar por E-mail.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;sessioninfo::session_info(c(&amp;quot;readr&amp;quot;, &amp;quot;dplyr&amp;quot;, &amp;quot;ggplot2&amp;quot;, &amp;quot;tidyr&amp;quot;, &amp;quot;broom&amp;quot;, &amp;quot;purrr&amp;quot;))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## - Session info ----------------------------------------------------------
##  setting  value                       
##  version  R version 3.5.3 (2019-03-11)
##  os       Windows 10 x64              
##  system   x86_64, mingw32             
##  ui       RTerm                       
##  language (EN)                        
##  collate  Portuguese_Brazil.1252      
##  ctype    Portuguese_Brazil.1252      
##  tz       America/Sao_Paulo           
##  date     2019-08-25                  
## 
## - Packages --------------------------------------------------------------
##  package      * version  date       lib source        
##  assertthat     0.2.1    2019-03-21 [1] CRAN (R 3.5.3)
##  backports      1.1.4    2019-04-10 [1] CRAN (R 3.5.3)
##  BH             1.69.0-1 2019-01-07 [1] CRAN (R 3.5.2)
##  broom        * 0.5.2    2019-04-07 [1] CRAN (R 3.5.3)
##  cli            1.1.0    2019-03-19 [1] CRAN (R 3.5.3)
##  clipr          0.7.0    2019-07-23 [1] CRAN (R 3.5.3)
##  colorspace     1.4-1    2019-03-18 [1] CRAN (R 3.5.3)
##  crayon         1.3.4    2017-09-16 [1] CRAN (R 3.5.1)
##  digest         0.6.20   2019-07-04 [1] CRAN (R 3.5.3)
##  dplyr        * 0.8.3    2019-07-04 [1] CRAN (R 3.5.3)
##  ellipsis       0.2.0.1  2019-07-02 [1] CRAN (R 3.5.3)
##  fansi          0.4.0    2018-10-05 [1] CRAN (R 3.5.1)
##  generics       0.0.2    2018-11-29 [1] CRAN (R 3.5.2)
##  ggplot2      * 3.2.1    2019-08-10 [1] CRAN (R 3.5.3)
##  glue           1.3.1    2019-03-12 [1] CRAN (R 3.5.3)
##  gtable         0.3.0    2019-03-25 [1] CRAN (R 3.5.3)
##  hms            0.5.0    2019-07-09 [1] CRAN (R 3.5.3)
##  labeling       0.3      2014-08-23 [1] CRAN (R 3.5.0)
##  lattice        0.20-38  2018-11-04 [2] CRAN (R 3.5.3)
##  lazyeval       0.2.2    2019-03-15 [1] CRAN (R 3.5.3)
##  magrittr       1.5      2014-11-22 [1] CRAN (R 3.5.1)
##  MASS           7.3-51.1 2018-11-01 [2] CRAN (R 3.5.3)
##  Matrix         1.2-17   2019-03-22 [1] CRAN (R 3.5.3)
##  mgcv           1.8-28   2019-03-21 [1] CRAN (R 3.5.3)
##  munsell        0.5.0    2018-06-12 [1] CRAN (R 3.5.1)
##  nlme           3.1-137  2018-04-07 [2] CRAN (R 3.5.3)
##  pillar         1.4.2    2019-06-29 [1] CRAN (R 3.5.3)
##  pkgconfig      2.0.2    2018-08-16 [1] CRAN (R 3.5.1)
##  plogr          0.2.0    2018-03-25 [1] CRAN (R 3.5.1)
##  plyr           1.8.4    2016-06-08 [1] CRAN (R 3.5.1)
##  purrr        * 0.3.2    2019-03-15 [1] CRAN (R 3.5.3)
##  R6             2.4.0    2019-02-14 [1] CRAN (R 3.5.2)
##  RColorBrewer   1.1-2    2014-12-07 [1] CRAN (R 3.5.0)
##  Rcpp           1.0.2    2019-07-25 [1] CRAN (R 3.5.3)
##  readr        * 1.3.1    2018-12-21 [1] CRAN (R 3.5.2)
##  reshape2       1.4.3    2017-12-11 [1] CRAN (R 3.5.1)
##  rlang          0.4.0    2019-06-25 [1] CRAN (R 3.5.3)
##  scales         1.0.0    2018-08-09 [1] CRAN (R 3.5.1)
##  stringi        1.4.3    2019-03-12 [1] CRAN (R 3.5.3)
##  stringr        1.4.0    2019-02-10 [1] CRAN (R 3.5.2)
##  tibble         2.1.3    2019-06-06 [1] CRAN (R 3.5.3)
##  tidyr        * 0.8.3    2019-03-01 [1] CRAN (R 3.5.3)
##  tidyselect     0.2.5    2018-10-11 [1] CRAN (R 3.5.1)
##  utf8           1.1.4    2018-05-24 [1] CRAN (R 3.5.1)
##  vctrs          0.2.0    2019-07-05 [1] CRAN (R 3.5.3)
##  viridisLite    0.3.0    2018-02-01 [1] CRAN (R 3.5.1)
##  withr          2.1.2    2018-03-15 [1] CRAN (R 3.5.1)
##  zeallot        0.1.0    2018-01-28 [1] CRAN (R 3.5.2)
## 
## [1] C:/Users/Italo/Documents/R/win-library/3.5
## [2] C:/Program Files/R/R-3.5.3/library&lt;/code&gt;&lt;/pre&gt;

      </content:encoded>
    </item>
    
    <item>
      <title>Análise de componentes principais</title>
      <link>https://italocegatta.github.io/analise-de-componentes-principais/</link>
      <pubDate>Mon, 01 Aug 2016 00:00:00 +0000</pubDate>
      
      <guid>https://italocegatta.github.io/analise-de-componentes-principais/</guid>
      <description>Quando temos dados multivariados, a análise de componentes principais (PCA) é um recurso muito interessante e relativamente simples, em termos de conceito teórico e interpretação prática. Para exemplificar, vamos trabalhar com os dados climáticos de algumas cidades brasileiras. Os dados climáticos foram compilados a partir de estações automáticas do INMET.
No R, temos a facilidade de poder fazer o cálculo dos componentes principais e logo em seguida poder apresentá-los em gráficos elegantes e de fácil entendimento.</description>
      <content:encoded>
        


&lt;p&gt;Quando temos dados multivariados, a análise de componentes principais (PCA) é um recurso muito interessante e relativamente simples, em termos de conceito teórico e interpretação prática. Para exemplificar, vamos trabalhar com os dados climáticos de algumas cidades brasileiras. Os dados climáticos foram compilados a partir de estações automáticas do &lt;a href=&#34;http://www.inmet.gov.br/portal/index.php?r=estacoes/estacoesautomaticas&#34;&gt;INMET&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;No R, temos a facilidade de poder fazer o cálculo dos componentes principais e logo em seguida poder apresentá-los em gráficos elegantes e de fácil entendimento. O Objetivo deste post é apresentar uma rápida demonstração de como rodar um PCA e gerar os gráficos derivados.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;if (!require(&amp;quot;pacman&amp;quot;)) install.packages(&amp;quot;pacman&amp;quot;)
pacman::p_load(readr, dplyr, ggplot2, ggrepel)
pacman::p_load_gh(&amp;quot;vqv/ggbiplot&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;dados &amp;lt;- read_csv2(
  &amp;quot;https://github.com/italocegatta/italocegatta.github.io_source/raw/master/content/dados/base_clima.csv&amp;quot;
)

print(dados, n=31)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 31 x 6
##    Cidade             Koppen  Tmed   PPT   ETP   DEF
##    &amp;lt;chr&amp;gt;              &amp;lt;chr&amp;gt;  &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt;
##  1 Bom Despacho       Cwa     22.6  802. 1112. 238. 
##  2 Niquelandia        Aw      24.6  562. 1372. 656. 
##  3 Arapoti            Cfb     18.5 1367   670.  25.4
##  4 Rio Verde          Aw      23.3 1245. 1196. 425. 
##  5 Belo Oriente       Aw      22.6 1054. 1105. 125. 
##  6 Guanhaes           Cwa     20.6  818.  866  188. 
##  7 Eldorado do Sul    Cfa     20.6 1787.  859.  10.7
##  8 Sao Gabriel        Cfa     20.2 1783.  927.   2.8
##  9 Inhambupe          As      24.2  715. 1318. 607. 
## 10 Botucatu           Cfb     21.9 1013. 1030  184. 
## 11 Estrela do Sul     Cwa     23.4 1134. 1208. 206. 
## 12 Buri               Cfa     20.0 1404.  805    3.6
## 13 Inocencia          Am      24.5 1020. 1375. 389. 
## 14 Chapadao do Sul    Am      22.6 1027. 1098. 326. 
## 15 Aracruz            Aw      23.9  849. 1277. 336. 
## 16 Tres Lagoas        Aw      25.2  944. 1502. 538. 
## 17 Tres Marias        Aw      22.2  811. 1052. 405. 
## 18 Peixe              Aw      26.3 1208. 1630. 674. 
## 19 Mogi Guacu         Cwa     22.4  924. 1100. 210. 
## 20 Brejinho de Nazare Aw      25.9 1507. 1563. 496. 
## 21 Monte Dourado      Am      27.4 2529. 1821. 530. 
## 22 Otacilio Costa     Cfb     16.9 2092.  548.   0  
## 23 Telemaco Borba     Cfa     18.5 1367   670.  28  
## 24 Borebi             Cfa     22.1  948. 1058. 201. 
## 25 Coracao de Jesus   As      23.9  413. 1275. 744. 
## 26 Antonio Olinto     Cfb     17.7 1740.  616.   0  
## 27 Tres Barras        Cfb     17.3 1123.  581   16.5
## 28 Urbano Santos      Aw      27.0 1438. 1750. 935  
## 29 Eunapolis          Am      22.9 1419. 1128.  31.2
## 30 Itagimirim         Aw      25.2  491. 1460. 870. 
## 31 Bocaiuva           Aw      23.9  413. 1276. 642.&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A análise de componentes principais nos mostra o quanto cada grupo de variáveis explicam a variabilidade total dados. No nosso caso, o primeiro componente responde por 72% da variabilidade e tem efeito quase que igual da temperatura (Tmed), evapotranspiração (ETP) e déficit hídrico (DEF). O segundo componente é majoritariamente o efeito da chuva (PPT). Juntos, os dois componentes explicam 95% dos dados.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;pca &amp;lt;- select(dados, Tmed:DEF) %&amp;gt;%
  princomp(cor = T)

summary(pca); loadings(pca)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Importance of components:
##                           Comp.1    Comp.2     Comp.3       Comp.4
## Standard deviation     1.7007490 0.9709348 0.40137904 0.0602784852
## Proportion of Variance 0.7231368 0.2356786 0.04027628 0.0009083739
## Cumulative Proportion  0.7231368 0.9588153 0.99909163 1.0000000000&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 
## Loadings:
##      Comp.1 Comp.2 Comp.3 Comp.4
## Tmed  0.567  0.201  0.437  0.668
## PPT  -0.241  0.933 -0.251       
## ETP   0.561  0.284  0.261 -0.732
## DEF   0.553        -0.823       
## 
##                Comp.1 Comp.2 Comp.3 Comp.4
## SS loadings      1.00   1.00   1.00   1.00
## Proportion Var   0.25   0.25   0.25   0.25
## Cumulative Var   0.25   0.50   0.75   1.00&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A Figura &lt;a href=&#34;#fig:8-pca&#34;&gt;1&lt;/a&gt; ajuda-nos a visualizar a disposição das cidades em função dos dois principais componentes. Se analisarmos por quadrantes, podemos agrupar as cidades de clima semelhante e ainda verificar a relação com as variáveis de clima. As setas indicam o efeito positivo ou negativo da variável. Por exemplo, o quadrante Q4 é caracterizado por valores altos de chuva e praticamente nenhum deficit hídrico. No oposto, temos o Q2 com baixa precipitação e alto déficit hídrico.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggbiplot(pca) +
  geom_point() +
  geom_vline(xintercept = 0, size = 1.2, linetype = 6) +
  geom_hline(yintercept = 0, size = 1.2, linetype = 6) +
  geom_label_repel(aes(label = dados$Cidade), size = 3, nudge_x = .2) +
  annotate(
    &amp;quot;text&amp;quot;,
    x = c(-2, 2, 2, -2),
    y = c(2, 2, -2, -2), 
    label = paste0(&amp;quot;Q&amp;quot;, 1:4), size = 6
  ) +
  lims(x = c(-2,2), y = c(-2,2)) +
  theme_bw()&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;figure&#34;&gt;&lt;span id=&#34;fig:8-pca&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;https://italocegatta.github.io/post/2016-08-01-analise-de-componentes-principais_files/figure-html/8-pca-1.svg&#34; alt=&#34;Representação gráfica dos componentes principais.&#34; width=&#34;768&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figura  1: Representação gráfica dos componentes principais.
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Como também temos a informação do clima Koppen, podemos colorir o gráfico em função deste atributo (Figura &lt;a href=&#34;#fig:8-pca-koppen&#34;&gt;2&lt;/a&gt;).&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggbiplot(pca) +
  geom_point(aes(color = dados$Koppen)) +
  geom_vline(xintercept = 0, size = 1.2, linetype = 6) +
  geom_hline(yintercept = 0, size = 1.2, linetype = 6) +
  geom_label_repel(
    aes(color = dados$Koppen, label = dados$Cidade),
    size = 3, nudge_x = .2, show.legend = F
  ) +
  lims(x = c(-2,2), y = c(-2,2)) +
  scale_color_brewer(&amp;quot;Clima Koppen&amp;quot;, palette = &amp;quot;Dark2&amp;quot;) +
  theme_bw()+
  theme(legend.position = &amp;quot;top&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;figure&#34;&gt;&lt;span id=&#34;fig:8-pca-koppen&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;https://italocegatta.github.io/post/2016-08-01-analise-de-componentes-principais_files/figure-html/8-pca-koppen-1.svg&#34; alt=&#34;Representação gráfica dos componentes principais com classificação Koppen.&#34; width=&#34;768&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figura  2: Representação gráfica dos componentes principais com classificação Koppen.
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Caso tenha alguma dúvida ou sugestão sobre o post, fique à vontade para fazer um comentário ou me contatar por E-mail.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;sessioninfo::session_info(c(&amp;quot;readr&amp;quot;, &amp;quot;dplyr&amp;quot;, &amp;quot;ggplot2&amp;quot;, &amp;quot;ggrepel&amp;quot;, &amp;quot;ggbiplot&amp;quot;))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## - Session info ----------------------------------------------------------
##  setting  value                       
##  version  R version 3.5.3 (2019-03-11)
##  os       Windows 10 x64              
##  system   x86_64, mingw32             
##  ui       RTerm                       
##  language (EN)                        
##  collate  Portuguese_Brazil.1252      
##  ctype    Portuguese_Brazil.1252      
##  tz       America/Sao_Paulo           
##  date     2019-08-25                  
## 
## - Packages --------------------------------------------------------------
##  package      * version  date       lib source                       
##  assertthat     0.2.1    2019-03-21 [1] CRAN (R 3.5.3)               
##  backports      1.1.4    2019-04-10 [1] CRAN (R 3.5.3)               
##  BH             1.69.0-1 2019-01-07 [1] CRAN (R 3.5.2)               
##  cli            1.1.0    2019-03-19 [1] CRAN (R 3.5.3)               
##  clipr          0.7.0    2019-07-23 [1] CRAN (R 3.5.3)               
##  colorspace     1.4-1    2019-03-18 [1] CRAN (R 3.5.3)               
##  crayon         1.3.4    2017-09-16 [1] CRAN (R 3.5.1)               
##  digest         0.6.20   2019-07-04 [1] CRAN (R 3.5.3)               
##  dplyr        * 0.8.3    2019-07-04 [1] CRAN (R 3.5.3)               
##  ellipsis       0.2.0.1  2019-07-02 [1] CRAN (R 3.5.3)               
##  fansi          0.4.0    2018-10-05 [1] CRAN (R 3.5.1)               
##  ggbiplot     * 0.55     2018-12-31 [1] Github (vqv/ggbiplot@7325e88)
##  ggplot2      * 3.2.1    2019-08-10 [1] CRAN (R 3.5.3)               
##  ggrepel      * 0.8.1    2019-05-07 [1] CRAN (R 3.5.3)               
##  glue           1.3.1    2019-03-12 [1] CRAN (R 3.5.3)               
##  gtable         0.3.0    2019-03-25 [1] CRAN (R 3.5.3)               
##  hms            0.5.0    2019-07-09 [1] CRAN (R 3.5.3)               
##  labeling       0.3      2014-08-23 [1] CRAN (R 3.5.0)               
##  lattice        0.20-38  2018-11-04 [2] CRAN (R 3.5.3)               
##  lazyeval       0.2.2    2019-03-15 [1] CRAN (R 3.5.3)               
##  magrittr       1.5      2014-11-22 [1] CRAN (R 3.5.1)               
##  MASS           7.3-51.1 2018-11-01 [2] CRAN (R 3.5.3)               
##  Matrix         1.2-17   2019-03-22 [1] CRAN (R 3.5.3)               
##  mgcv           1.8-28   2019-03-21 [1] CRAN (R 3.5.3)               
##  munsell        0.5.0    2018-06-12 [1] CRAN (R 3.5.1)               
##  nlme           3.1-137  2018-04-07 [2] CRAN (R 3.5.3)               
##  pillar         1.4.2    2019-06-29 [1] CRAN (R 3.5.3)               
##  pkgconfig      2.0.2    2018-08-16 [1] CRAN (R 3.5.1)               
##  plogr          0.2.0    2018-03-25 [1] CRAN (R 3.5.1)               
##  plyr         * 1.8.4    2016-06-08 [1] CRAN (R 3.5.1)               
##  purrr          0.3.2    2019-03-15 [1] CRAN (R 3.5.3)               
##  R6             2.4.0    2019-02-14 [1] CRAN (R 3.5.2)               
##  RColorBrewer   1.1-2    2014-12-07 [1] CRAN (R 3.5.0)               
##  Rcpp           1.0.2    2019-07-25 [1] CRAN (R 3.5.3)               
##  readr        * 1.3.1    2018-12-21 [1] CRAN (R 3.5.2)               
##  reshape2       1.4.3    2017-12-11 [1] CRAN (R 3.5.1)               
##  rlang          0.4.0    2019-06-25 [1] CRAN (R 3.5.3)               
##  scales       * 1.0.0    2018-08-09 [1] CRAN (R 3.5.1)               
##  stringi        1.4.3    2019-03-12 [1] CRAN (R 3.5.3)               
##  stringr        1.4.0    2019-02-10 [1] CRAN (R 3.5.2)               
##  tibble         2.1.3    2019-06-06 [1] CRAN (R 3.5.3)               
##  tidyselect     0.2.5    2018-10-11 [1] CRAN (R 3.5.1)               
##  utf8           1.1.4    2018-05-24 [1] CRAN (R 3.5.1)               
##  vctrs          0.2.0    2019-07-05 [1] CRAN (R 3.5.3)               
##  viridisLite    0.3.0    2018-02-01 [1] CRAN (R 3.5.1)               
##  withr          2.1.2    2018-03-15 [1] CRAN (R 3.5.1)               
##  zeallot        0.1.0    2018-01-28 [1] CRAN (R 3.5.2)               
## 
## [1] C:/Users/Italo/Documents/R/win-library/3.5
## [2] C:/Program Files/R/R-3.5.3/library&lt;/code&gt;&lt;/pre&gt;

      </content:encoded>
    </item>
    
    <item>
      <title>Os gráficos que explicam nossos dados (histograma)</title>
      <link>https://italocegatta.github.io/os-graficos-que-explicam-nossos-dados-histograma/</link>
      <pubDate>Fri, 15 Jul 2016 00:00:00 +0000</pubDate>
      
      <guid>https://italocegatta.github.io/os-graficos-que-explicam-nossos-dados-histograma/</guid>
      <description>Histogramas são usados para mostrar a frequência com que uma variável ocorre. Isto é muito interessante para mostrar qual a distribuição dos seus dados e podemos apresentar em forma de frequência absoluta, relativa, percentual e acumulada. Para exemplificar este tipo gráfico, vamos utilizar os dados de inventário de uma propriedade fictícia na Amazônia. Estes dados são meramente ilustrativos e não tem valor real. O objetivo aqui é apresentar algumas particularidades da construção de gráficos de barras no R e facilitar a vida de quem quer abandonar os gráficos do Excel.</description>
      <content:encoded>
        


&lt;p&gt;Histogramas são usados para mostrar a frequência com que uma variável ocorre. Isto é muito interessante para mostrar qual a distribuição dos seus dados e podemos apresentar em forma de frequência absoluta, relativa, percentual e acumulada. Para exemplificar este tipo gráfico, vamos utilizar os dados de inventário de uma propriedade fictícia na Amazônia. Estes dados são meramente ilustrativos e não tem valor real. O objetivo aqui é apresentar algumas particularidades da construção de gráficos de barras no R e facilitar a vida de quem quer abandonar os gráficos do Excel.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;if (!require(&amp;quot;pacman&amp;quot;)) install.packages(&amp;quot;pacman&amp;quot;)
pacman::p_load(readr, dplyr, ggplot2)&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;dados &amp;lt;- read_csv2(
  &amp;quot;https://raw.githubusercontent.com/italocegatta/italocegatta.github.io_source/master/content/dados/base_amazonia.csv&amp;quot;
)

dados&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 276 x 7
##    Especie       Nome_cientifico         Comercial   DAP  HCom Volume    QF
##    &amp;lt;chr&amp;gt;         &amp;lt;chr&amp;gt;                   &amp;lt;chr&amp;gt;     &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt;
##  1 NAO IDENTIFI~ Nao Identificada        Nao          20    10   0.23     2
##  2 EMBIRA        Lecythidaceae           Nao          34    13   0.83     1
##  3 NAO IDENTIFI~ Nao Identificada        Nao          18     6   0.11     1
##  4 SUCUPIRA      Leguminosae-Papilionoi~ Nao          18     7   0.13     1
##  5 CANELA        Lauraceae               Nao          24    10   0.32     1
##  6 TACHI         Lecythidaceae           Sim          21    10   0.25     1
##  7 ENVIRA CAJU   Annonaceae              Nao          20    11   0.25     2
##  8 JUTAI         Leguminosae-Caesalpini~ Nao          38    13   1.04     2
##  9 CATUABA       Vochysiaceae            Sim          57    13   2.32     1
## 10 NAO IDENTIFI~ Nao Identificada        Nao          22     7   0.19     2
## # ... with 266 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Primeiro vamos ver qual a distribuição dos indivíduos em classes de diâmetro. A Figura &lt;a href=&#34;#fig:7-hist-dap&#34;&gt;1&lt;/a&gt; mostra a frequência de indivíduos em classes de diâmetro de 10 cm. Visivelmente, podemos ver que a faixa de diâmetro mais frequente está entre 15 e 35 cm (centro de classe 20 e 30 cm, respectivamente).&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggplot(dados, aes(DAP)) +
  geom_histogram(binwidth = 10, color =&amp;quot; black&amp;quot;, alpha = 0.8) +
  labs(x = &amp;quot;Diâmetro (cm)&amp;quot;, y = &amp;quot;Frequência (arv/ha)&amp;quot;) +
  scale_x_continuous(breaks = seq(0, 100, 10)) +
  theme_bw(16)&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;figure&#34;&gt;&lt;span id=&#34;fig:7-hist-dap&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;https://italocegatta.github.io/post/2016-07-15-os-graficos-que-explicam-nossos-dados-histograma_files/figure-html/7-hist-dap-1.svg&#34; alt=&#34;Histograma com a frequência absoluta por classes de diâmetro.&#34; width=&#34;960&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figura  1: Histograma com a frequência absoluta por classes de diâmetro.
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Mas, e quanto às espécies comerciais? Como elas estão distribuídas? A Figura &lt;a href=&#34;#fig:7-hist-dap-comerc&#34;&gt;2&lt;/a&gt; faz esta diferenciação. E lembre-se, no manejo florestal da Amazônia só é permitido a exploração de árvores com diâmetro maior que 50 cm.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggplot(dados, aes(DAP, fill = Comercial)) +
  geom_histogram(binwidth = 10, color =&amp;quot; black&amp;quot;, alpha = 0.8) +
  labs(
    x = &amp;quot;Diâmetro (cm)&amp;quot;, y = &amp;quot;Frequência (arv/ha)&amp;quot;,
    fill = &amp;quot;Comercial?&amp;quot;
  ) +
  scale_x_continuous(breaks = seq(0, 100,10)) +
  scale_fill_hue(labels = c(&amp;quot;Não&amp;quot;, &amp;quot;Sim&amp;quot;)) +
  theme_bw(16)&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;figure&#34;&gt;&lt;span id=&#34;fig:7-hist-dap-comerc&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;https://italocegatta.github.io/post/2016-07-15-os-graficos-que-explicam-nossos-dados-histograma_files/figure-html/7-hist-dap-comerc-1.svg&#34; alt=&#34;Histograma com a frequência absoluta por classes de diâmetro e separação pelo fator de árvores de interesse comercial.&#34; width=&#34;960&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figura  2: Histograma com a frequência absoluta por classes de diâmetro e separação pelo fator de árvores de interesse comercial.
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Vamos melhorar um pouco mais a informação sob o ponto de vista da exploração: qual a frequência de indivíduos que são de interesse comercial e tem diâmetro mais que 50 cm? (Figura &lt;a href=&#34;#fig:7-hist-vol-exp&#34;&gt;3&lt;/a&gt;).&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggplot(dados, aes(Volume, fill = DAP &amp;gt; 50 &amp;amp; Comercial == &amp;quot;Sim&amp;quot;)) +
  geom_histogram(binwidth = 0.5, color =&amp;quot; black&amp;quot;, alpha = 0.8) +
  labs(
    x = Volume~individual~(m^3~arv^-1), y = &amp;quot;Frequência (arv/ha)&amp;quot;,
    fill = &amp;quot;Pode explorar?&amp;quot;
  ) +
  scale_y_continuous(breaks = seq(0, 150, 20)) +
  scale_x_continuous(breaks = seq(0, 10, 0.5)) +
  scale_fill_hue(labels = c(&amp;quot;Não&amp;quot;, &amp;quot;Sim&amp;quot;)) +
  theme_bw(16)&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;figure&#34;&gt;&lt;span id=&#34;fig:7-hist-vol-exp&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;https://italocegatta.github.io/post/2016-07-15-os-graficos-que-explicam-nossos-dados-histograma_files/figure-html/7-hist-vol-exp-1.svg&#34; alt=&#34;Histograma com a frequência absoluta por classes de volume individual e separação pelo fator de árvores de interesse comercial e diâmetro maior que 50 cm.&#34; width=&#34;960&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figura  3: Histograma com a frequência absoluta por classes de volume individual e separação pelo fator de árvores de interesse comercial e diâmetro maior que 50 cm.
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Se quisermos ainda apresentar o gráfico em termos das frequências relativas, podemos fazer a seguinte modificação, conforme a Figura &lt;a href=&#34;#fig:7-hist-vol-exp-rel&#34;&gt;4&lt;/a&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggplot(dados, aes(Volume, fill = DAP &amp;gt; 50 &amp;amp; Comercial == &amp;quot;Sim&amp;quot;)) +
  geom_histogram(
    aes(y = ..count../sum(..count..)),
    binwidth = 0.5, color =&amp;quot; black&amp;quot;, alpha = 0.8
  ) +
  labs(
    x = Volume~individual~(m^3~arv^-1), y = &amp;quot;Frequência (arv/ha)&amp;quot;,
    fill = &amp;quot;Pode explorar?&amp;quot;
  ) +
  scale_y_continuous(breaks = seq(0, .5, 0.05), labels = scales::percent) +
  scale_x_continuous(breaks = seq(0, 10, 0.5)) +
  scale_fill_hue(labels = c(&amp;quot;Não&amp;quot;, &amp;quot;Sim&amp;quot;)) +
  theme_bw(16)&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;figure&#34;&gt;&lt;span id=&#34;fig:7-hist-vol-exp-rel&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;https://italocegatta.github.io/post/2016-07-15-os-graficos-que-explicam-nossos-dados-histograma_files/figure-html/7-hist-vol-exp-rel-1.svg&#34; alt=&#34;Histograma com a frequência relativa por classes de volume individual e separação pelo fator de árvores de interesse comercial e diâmetro maior que 50 cm.&#34; width=&#34;960&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figura  4: Histograma com a frequência relativa por classes de volume individual e separação pelo fator de árvores de interesse comercial e diâmetro maior que 50 cm.
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Caso tenha alguma dúvida ou sugestão sobre o post, fique à vontade para fazer um comentário ou me contatar por E-mail.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;sessioninfo::session_info(c(&amp;quot;readr&amp;quot;, &amp;quot;dplyr&amp;quot;, &amp;quot;ggplot2&amp;quot;))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## - Session info ----------------------------------------------------------
##  setting  value                       
##  version  R version 3.5.3 (2019-03-11)
##  os       Windows 10 x64              
##  system   x86_64, mingw32             
##  ui       RTerm                       
##  language (EN)                        
##  collate  Portuguese_Brazil.1252      
##  ctype    Portuguese_Brazil.1252      
##  tz       America/Sao_Paulo           
##  date     2019-08-25                  
## 
## - Packages --------------------------------------------------------------
##  package      * version  date       lib source        
##  assertthat     0.2.1    2019-03-21 [1] CRAN (R 3.5.3)
##  backports      1.1.4    2019-04-10 [1] CRAN (R 3.5.3)
##  BH             1.69.0-1 2019-01-07 [1] CRAN (R 3.5.2)
##  cli            1.1.0    2019-03-19 [1] CRAN (R 3.5.3)
##  clipr          0.7.0    2019-07-23 [1] CRAN (R 3.5.3)
##  colorspace     1.4-1    2019-03-18 [1] CRAN (R 3.5.3)
##  crayon         1.3.4    2017-09-16 [1] CRAN (R 3.5.1)
##  digest         0.6.20   2019-07-04 [1] CRAN (R 3.5.3)
##  dplyr        * 0.8.3    2019-07-04 [1] CRAN (R 3.5.3)
##  ellipsis       0.2.0.1  2019-07-02 [1] CRAN (R 3.5.3)
##  fansi          0.4.0    2018-10-05 [1] CRAN (R 3.5.1)
##  ggplot2      * 3.2.1    2019-08-10 [1] CRAN (R 3.5.3)
##  glue           1.3.1    2019-03-12 [1] CRAN (R 3.5.3)
##  gtable         0.3.0    2019-03-25 [1] CRAN (R 3.5.3)
##  hms            0.5.0    2019-07-09 [1] CRAN (R 3.5.3)
##  labeling       0.3      2014-08-23 [1] CRAN (R 3.5.0)
##  lattice        0.20-38  2018-11-04 [2] CRAN (R 3.5.3)
##  lazyeval       0.2.2    2019-03-15 [1] CRAN (R 3.5.3)
##  magrittr       1.5      2014-11-22 [1] CRAN (R 3.5.1)
##  MASS           7.3-51.1 2018-11-01 [2] CRAN (R 3.5.3)
##  Matrix         1.2-17   2019-03-22 [1] CRAN (R 3.5.3)
##  mgcv           1.8-28   2019-03-21 [1] CRAN (R 3.5.3)
##  munsell        0.5.0    2018-06-12 [1] CRAN (R 3.5.1)
##  nlme           3.1-137  2018-04-07 [2] CRAN (R 3.5.3)
##  pillar         1.4.2    2019-06-29 [1] CRAN (R 3.5.3)
##  pkgconfig      2.0.2    2018-08-16 [1] CRAN (R 3.5.1)
##  plogr          0.2.0    2018-03-25 [1] CRAN (R 3.5.1)
##  plyr           1.8.4    2016-06-08 [1] CRAN (R 3.5.1)
##  purrr          0.3.2    2019-03-15 [1] CRAN (R 3.5.3)
##  R6             2.4.0    2019-02-14 [1] CRAN (R 3.5.2)
##  RColorBrewer   1.1-2    2014-12-07 [1] CRAN (R 3.5.0)
##  Rcpp           1.0.2    2019-07-25 [1] CRAN (R 3.5.3)
##  readr        * 1.3.1    2018-12-21 [1] CRAN (R 3.5.2)
##  reshape2       1.4.3    2017-12-11 [1] CRAN (R 3.5.1)
##  rlang          0.4.0    2019-06-25 [1] CRAN (R 3.5.3)
##  scales         1.0.0    2018-08-09 [1] CRAN (R 3.5.1)
##  stringi        1.4.3    2019-03-12 [1] CRAN (R 3.5.3)
##  stringr        1.4.0    2019-02-10 [1] CRAN (R 3.5.2)
##  tibble         2.1.3    2019-06-06 [1] CRAN (R 3.5.3)
##  tidyselect     0.2.5    2018-10-11 [1] CRAN (R 3.5.1)
##  utf8           1.1.4    2018-05-24 [1] CRAN (R 3.5.1)
##  vctrs          0.2.0    2019-07-05 [1] CRAN (R 3.5.3)
##  viridisLite    0.3.0    2018-02-01 [1] CRAN (R 3.5.1)
##  withr          2.1.2    2018-03-15 [1] CRAN (R 3.5.1)
##  zeallot        0.1.0    2018-01-28 [1] CRAN (R 3.5.2)
## 
## [1] C:/Users/Italo/Documents/R/win-library/3.5
## [2] C:/Program Files/R/R-3.5.3/library&lt;/code&gt;&lt;/pre&gt;

      </content:encoded>
    </item>
    
    <item>
      <title>Os gráficos que explicam nossos dados (heatmap)</title>
      <link>https://italocegatta.github.io/os-graficos-que-explicam-nossos-dados-heatmap/</link>
      <pubDate>Sat, 09 Jul 2016 00:00:00 +0000</pubDate>
      
      <guid>https://italocegatta.github.io/os-graficos-que-explicam-nossos-dados-heatmap/</guid>
      <description>O heatmap é um gráfico muito útil para identificar padrões, principalmente quando temos muitas variáveis no gráfico. Essencialmente o heatmap necessita de 3 variáveis: uma variável resposta e duas outras variáveis para compor os eixos x e y. Não há restrição quanto ao tipo de variável, qualquer uma delas podem ser quantitativa ou qualitativa. Talvez esse seja o trunfo do heatmap, essa flexibilidade quanto a natureza das variáveis nos permite utilizá-lo em diversos momentos e substituir gráficos mais tradicionais quando eles não dão conta do recado.</description>
      <content:encoded>
        


&lt;p&gt;O heatmap é um gráfico muito útil para identificar padrões, principalmente quando temos muitas variáveis no gráfico. Essencialmente o heatmap necessita de 3 variáveis: uma variável resposta e duas outras variáveis para compor os eixos x e y. Não há restrição quanto ao tipo de variável, qualquer uma delas podem ser quantitativa ou qualitativa. Talvez esse seja o trunfo do heatmap, essa flexibilidade quanto a natureza das variáveis nos permite utilizá-lo em diversos momentos e substituir gráficos mais tradicionais quando eles não dão conta do recado.&lt;/p&gt;
&lt;p&gt;Vamos trabalhar com os dados do &lt;a href=&#34;http://www.projetotume.com/&#34;&gt;Projeto TUME&lt;/a&gt;, especificamente com o TUME 0, plantado na Estação Experimental de Itatinga. O TUME é um projeto muito interessante e possui informações importantes sobre plantios de &lt;em&gt;Eucalyptus&lt;/em&gt; no Brasil, vale a pena visitar o site e aproveitar o conteúdo disponível.&lt;/p&gt;
&lt;p&gt;Vamos primeiro carregar os dados e fazer algumas alterações. Para auxiliar na ordem dos fatores no gráfico vamos adicionar um atributo na coluna &lt;code&gt;Esp&lt;/code&gt; informando a ordem crescente das espécies em função da altura dominante. Em seguida, apenas por conveniência, converti a idade dos inventários de meses para anos.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;if (!require(&amp;quot;pacman&amp;quot;)) install.packages(&amp;quot;pacman&amp;quot;)
pacman::p_load(readr, dplyr, ggplot2)&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;dados &amp;lt;- read_csv2(
  &amp;quot;https://github.com/italocegatta/italocegatta.github.io_source/raw/master/content/dados/tume0.csv&amp;quot;
)

# Cria um fator com o atributo para a variável Esp que informa a ordem crescente
# das espécies em função da altura dominante.
dados &amp;lt;- dados %&amp;gt;% 
  mutate(
    Esp = reorder(Esp, Hdom, function(x) max(x)),
    Idade = round(I_meses/12,1)
  )
dados&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 138 x 16
##    N_tume Esp   I_meses Parc_m2 DAPmed DAPsd  Hmed   Hsd  Hdom N_fuste
##     &amp;lt;dbl&amp;gt; &amp;lt;fct&amp;gt;   &amp;lt;dbl&amp;gt;   &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt;   &amp;lt;dbl&amp;gt;
##  1      0 Clon~      52   1426.   11.4   1.4  16.5   1.3  17.8    1789
##  2      0 Clon~      52   1426.   10.2   1.4  15.9   1.4  16.6    1662
##  3      0 Clon~      52   1426.   10.7   1.6  15     1.3  16.1    1824
##  4      0 E_be~      52   1426.    9     2.7   9.8   2.3  13      1494
##  5      0 E_bo~      52   1426.    9.1   4.3  10.8   3.4  15.3    1368
##  6      0 E_ca~      52   1426.    8.3   2.9   8.3   2.3  11.8    1557
##  7      0 E_ci~      52   1426.    8     3.5   8.3   2.8  12       954
##  8      0 E_cl~      52    929.    7.5   2.5   7     2     9.6    1367
##  9      0 E_de~      52   1426.   10.6   2.9  11.3   1.8  13.4    1087
## 10      0 E_du~      52   1426.    6.7   3.7   6.1   2.4  10.3     779
## # ... with 128 more rows, and 6 more variables: Sobr &amp;lt;dbl&amp;gt;, G &amp;lt;dbl&amp;gt;,
## #   V &amp;lt;dbl&amp;gt;, IMA &amp;lt;dbl&amp;gt;, B &amp;lt;dbl&amp;gt;, Idade &amp;lt;dbl&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Se fizermos a seguinte pergunta: qual gráfico podemos utilizar para mostrar o crescimento da altura dominantes dos materiais? Penso que a resposta rápida seria, um gráfico de linhas! Ok, vamos tentar, veja a Figura &lt;a href=&#34;#fig:6-linhas&#34;&gt;1&lt;/a&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggplot(dados, aes(Idade, Hdom, color = Esp)) +
  geom_line(size=1.5) +
  labs(
    x = &amp;quot;Idade (anos)&amp;quot;, y = &amp;quot;Altura dominante (m)&amp;quot;,
    color = &amp;quot;Materiais genéticos&amp;quot;
  ) +
  scale_color_viridis_d(direction = -1) +
  theme_bw(16) +
  guides(col = guide_legend(ncol = 1, reverse = TRUE))&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;figure&#34;&gt;&lt;span id=&#34;fig:6-linhas&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;https://italocegatta.github.io/post/2016-07-09-os-graficos-que-explicam-nossos-dados-heatmap_files/figure-html/6-linhas-1.svg&#34; alt=&#34;Aumento da altura dominante utilizando gráficos de linhas.&#34; width=&#34;960&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figura  1: Aumento da altura dominante utilizando gráficos de linhas.
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Muito bem, o gráfico consegue mostrar a tendência e o padrão de crescimento. Mas se alguém perguntar sobre o &lt;em&gt;Eucaluptus dunnii&lt;/em&gt;, capaz de demorarmos um tempo para encontrar a linha correspondente. Capaz ainda de não conseguirmos distinguir entre uma cor e outra. Essa é uma limitação do gráfico de linhas, quanto temos muitos fatores na legenda fica difícil a distinção entre eles. E quando se tem uma restrição de cor e o gráfico precisa estar em escala de cinza? Esquece! Há quem tente utilizar símbolos ou tipos de traços para distinguir os fatores, mesmo assim, não é uma tarefa fácil.&lt;/p&gt;
&lt;p&gt;É neste momento que podemos nos aproveitar do heatmap. Agora a intensidade de cor indica a variável resposta (Figura &lt;a href=&#34;#fig:6-heatmap-cont&#34;&gt;2&lt;/a&gt;). Veja que fica mais fácil acompanhar o crescimento de uma espécie em especial.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggplot(dados, aes(factor(Idade), Esp, fill = Hdom)) +
  geom_tile(color = &amp;quot;grey90&amp;quot;) +
  labs(
    x = &amp;quot;Idade (anos)&amp;quot;, y = &amp;quot;Altura dominante (m)&amp;quot;,
    fill = &amp;quot;Materiais genéticos&amp;quot;
  ) +
  scale_fill_viridis_c(direction = -1) +
  theme_bw(16) +
  guides(col = guide_legend(reverse = TRUE))&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;figure&#34;&gt;&lt;span id=&#34;fig:6-heatmap-cont&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;https://italocegatta.github.io/post/2016-07-09-os-graficos-que-explicam-nossos-dados-heatmap_files/figure-html/6-heatmap-cont-1.svg&#34; alt=&#34;Aumento da altura dominante utilizando heatmap com escala de cor contínua.&#34; width=&#34;960&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figura  2: Aumento da altura dominante utilizando heatmap com escala de cor contínua.
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Se for do interesse controlar a escala de cor em intervalos e classes, a alteração é simples (Figura &lt;a href=&#34;#fig:6-heatmap-discr&#34;&gt;3&lt;/a&gt;). Se reduzirmos as classes de cor, perdemos resolução na escala da variável resposta. Dependendo do objetivo do gráfico isso pode ser bom ou ruim. Neste caso, escolhi intervalos de 2 metros, pois achei mais adequado.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggplot(dados, aes(factor(Idade), Esp, fill = cut(Hdom, breaks = seq(0, 40, 2)))) +
  geom_tile(color = &amp;quot;grey90&amp;quot;) +
  labs(
    x = &amp;quot;Idade (anos)&amp;quot;, y = &amp;quot;Materiais genéticos&amp;quot;,
    fill = &amp;quot;Altura dominante (m)&amp;quot;
  ) +
  scale_fill_viridis_d(direction = -1) +
  theme_bw(16) +
  guides(col = guide_legend(reverse = TRUE))&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;figure&#34;&gt;&lt;span id=&#34;fig:6-heatmap-discr&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;https://italocegatta.github.io/post/2016-07-09-os-graficos-que-explicam-nossos-dados-heatmap_files/figure-html/6-heatmap-discr-1.svg&#34; alt=&#34;Aumento da altura dominante utilizando heatmap com escala de cor discreta.&#34; width=&#34;960&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figura  3: Aumento da altura dominante utilizando heatmap com escala de cor discreta.
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Se quisermos deixar explícito o valor da variável resposta podemos indicá-la no gráfico, como na Figura &lt;a href=&#34;#fig:6-heatmap-discr-label&#34;&gt;4&lt;/a&gt;. Eu particularmente acho que fica muito poluído, mas em alguns casos pode ser interessante.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggplot(dados, aes(factor(Idade), Esp, fill = cut(Hdom, breaks = seq(0, 40, 2)))) +
  geom_tile(color = &amp;quot;grey90&amp;quot;) +
  geom_text(aes(label = Hdom), color = &amp;quot;white&amp;quot;, fontface = &amp;quot;bold&amp;quot;) +
  labs(
    x = &amp;quot;Idade (anos)&amp;quot;, y = &amp;quot;Materiais genéticos&amp;quot;,
    fill = &amp;quot;Altura dominante (m)&amp;quot;
  ) +
  scale_fill_viridis_d(direction = -1, end = 0.92) +
  theme_bw(16) +
  guides(col = guide_legend(reverse = TRUE))&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;figure&#34;&gt;&lt;span id=&#34;fig:6-heatmap-discr-label&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;https://italocegatta.github.io/post/2016-07-09-os-graficos-que-explicam-nossos-dados-heatmap_files/figure-html/6-heatmap-discr-label-1.svg&#34; alt=&#34;Aumento da altura dominante utilizando heatmap com escala de cor discreta e informação do valor no grid.&#34; width=&#34;960&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figura  4: Aumento da altura dominante utilizando heatmap com escala de cor discreta e informação do valor no grid.
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Note que o eixo x é uma variável temporal, entretanto o gráfico não dá a escala entre os anos. Um observador desatento pode achar que as medições ocorreram em intervalos regulares, mas isso não é verdade. Essa é uma desvantagem do heatmap. Quando as variáveis dos eixos são numéricas e representam uma escala comparativa, este atributo fica comprometido.&lt;/p&gt;
&lt;p&gt;Caso tenha alguma dúvida ou sugestão sobre o post, fique à vontade para fazer um comentário ou me contatar por E-mail.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;sessioninfo::session_info(c(&amp;quot;readr&amp;quot;, &amp;quot;dplyr&amp;quot;, &amp;quot;ggplot2&amp;quot;))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## - Session info ----------------------------------------------------------
##  setting  value                       
##  version  R version 3.5.3 (2019-03-11)
##  os       Windows 10 x64              
##  system   x86_64, mingw32             
##  ui       RTerm                       
##  language (EN)                        
##  collate  Portuguese_Brazil.1252      
##  ctype    Portuguese_Brazil.1252      
##  tz       America/Sao_Paulo           
##  date     2019-08-25                  
## 
## - Packages --------------------------------------------------------------
##  package      * version  date       lib source        
##  assertthat     0.2.1    2019-03-21 [1] CRAN (R 3.5.3)
##  backports      1.1.4    2019-04-10 [1] CRAN (R 3.5.3)
##  BH             1.69.0-1 2019-01-07 [1] CRAN (R 3.5.2)
##  cli            1.1.0    2019-03-19 [1] CRAN (R 3.5.3)
##  clipr          0.7.0    2019-07-23 [1] CRAN (R 3.5.3)
##  colorspace     1.4-1    2019-03-18 [1] CRAN (R 3.5.3)
##  crayon         1.3.4    2017-09-16 [1] CRAN (R 3.5.1)
##  digest         0.6.20   2019-07-04 [1] CRAN (R 3.5.3)
##  dplyr        * 0.8.3    2019-07-04 [1] CRAN (R 3.5.3)
##  ellipsis       0.2.0.1  2019-07-02 [1] CRAN (R 3.5.3)
##  fansi          0.4.0    2018-10-05 [1] CRAN (R 3.5.1)
##  ggplot2      * 3.2.1    2019-08-10 [1] CRAN (R 3.5.3)
##  glue           1.3.1    2019-03-12 [1] CRAN (R 3.5.3)
##  gtable         0.3.0    2019-03-25 [1] CRAN (R 3.5.3)
##  hms            0.5.0    2019-07-09 [1] CRAN (R 3.5.3)
##  labeling       0.3      2014-08-23 [1] CRAN (R 3.5.0)
##  lattice        0.20-38  2018-11-04 [2] CRAN (R 3.5.3)
##  lazyeval       0.2.2    2019-03-15 [1] CRAN (R 3.5.3)
##  magrittr       1.5      2014-11-22 [1] CRAN (R 3.5.1)
##  MASS           7.3-51.1 2018-11-01 [2] CRAN (R 3.5.3)
##  Matrix         1.2-17   2019-03-22 [1] CRAN (R 3.5.3)
##  mgcv           1.8-28   2019-03-21 [1] CRAN (R 3.5.3)
##  munsell        0.5.0    2018-06-12 [1] CRAN (R 3.5.1)
##  nlme           3.1-137  2018-04-07 [2] CRAN (R 3.5.3)
##  pillar         1.4.2    2019-06-29 [1] CRAN (R 3.5.3)
##  pkgconfig      2.0.2    2018-08-16 [1] CRAN (R 3.5.1)
##  plogr          0.2.0    2018-03-25 [1] CRAN (R 3.5.1)
##  plyr           1.8.4    2016-06-08 [1] CRAN (R 3.5.1)
##  purrr          0.3.2    2019-03-15 [1] CRAN (R 3.5.3)
##  R6             2.4.0    2019-02-14 [1] CRAN (R 3.5.2)
##  RColorBrewer   1.1-2    2014-12-07 [1] CRAN (R 3.5.0)
##  Rcpp           1.0.2    2019-07-25 [1] CRAN (R 3.5.3)
##  readr        * 1.3.1    2018-12-21 [1] CRAN (R 3.5.2)
##  reshape2       1.4.3    2017-12-11 [1] CRAN (R 3.5.1)
##  rlang          0.4.0    2019-06-25 [1] CRAN (R 3.5.3)
##  scales         1.0.0    2018-08-09 [1] CRAN (R 3.5.1)
##  stringi        1.4.3    2019-03-12 [1] CRAN (R 3.5.3)
##  stringr        1.4.0    2019-02-10 [1] CRAN (R 3.5.2)
##  tibble         2.1.3    2019-06-06 [1] CRAN (R 3.5.3)
##  tidyselect     0.2.5    2018-10-11 [1] CRAN (R 3.5.1)
##  utf8           1.1.4    2018-05-24 [1] CRAN (R 3.5.1)
##  vctrs          0.2.0    2019-07-05 [1] CRAN (R 3.5.3)
##  viridisLite    0.3.0    2018-02-01 [1] CRAN (R 3.5.1)
##  withr          2.1.2    2018-03-15 [1] CRAN (R 3.5.1)
##  zeallot        0.1.0    2018-01-28 [1] CRAN (R 3.5.2)
## 
## [1] C:/Users/Italo/Documents/R/win-library/3.5
## [2] C:/Program Files/R/R-3.5.3/library&lt;/code&gt;&lt;/pre&gt;

      </content:encoded>
    </item>
    
    <item>
      <title>Os gráficos que explicam nossos dados (barras)</title>
      <link>https://italocegatta.github.io/os-graficos-que-explicam-nossos-dados-barras/</link>
      <pubDate>Sat, 14 May 2016 00:00:00 +0000</pubDate>
      
      <guid>https://italocegatta.github.io/os-graficos-que-explicam-nossos-dados-barras/</guid>
      <description>Este é o segundo post de uma série que estou fazendo sobre tipos de gráficos. Falamos um pouco sobre o boxplot e agora vamos ao gráfico de barras.
Gráficos de barras são muito úteis para podermos comparar fatores. Quando estão um ao lado do outro a comparação é feita rapidamente, já que as barras dão a noção de escala. Normalmente as barras informam um resumo (i. e. média, soma ou contagem), mas podemos ainda adicionar uma barra de erro ou desvio e deixar o gráfico mais detalhado.</description>
      <content:encoded>
        


&lt;p&gt;Este é o segundo post de uma série que estou fazendo sobre tipos de gráficos. Falamos um pouco sobre o &lt;a href=&#34;https://italocegatta.github.io/os-graficos-que-explicam-nossos-dados-boxplot&#34;&gt;boxplot&lt;/a&gt; e agora vamos ao gráfico de barras.&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;Gráficos de barras são muito úteis para podermos comparar fatores. Quando estão um ao lado do outro a comparação é feita rapidamente, já que as barras dão a noção de escala. Normalmente as barras informam um resumo (i. e. média, soma ou contagem), mas podemos ainda adicionar uma barra de erro ou desvio e deixar o gráfico mais detalhado.&lt;/p&gt;
&lt;p&gt;Continuaremos com o banco de dados apresentado no post sobre &lt;a href=&#34;https://italocegatta.github.io/o-conceito-tidy-data.html&#34;&gt;tidy data&lt;/a&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;if (!require(&amp;quot;pacman&amp;quot;)) install.packages(&amp;quot;pacman&amp;quot;)
pacman::p_load(readr, dplyr, ggplot2)&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;dados &amp;lt;- read_csv2(
  &amp;quot;https://github.com/italocegatta/italocegatta.github.io_source/raw/master/content/dados/base_vespa.csv&amp;quot;
)

dados&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 2,100 x 5
##    Tratamento Individuo Coleta Local   Galhas
##    &amp;lt;chr&amp;gt;          &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt; &amp;lt;chr&amp;gt;    &amp;lt;dbl&amp;gt;
##  1 Actara d1          1      1 Peciolo      1
##  2 Actara d1          2      1 Peciolo     NA
##  3 Actara d1          3      1 Peciolo     NA
##  4 Actara d1          4      1 Peciolo     NA
##  5 Actara d1          5      1 Peciolo     NA
##  6 Actara d1          6      1 Peciolo     NA
##  7 Actara d1          7      1 Peciolo     NA
##  8 Actara d1          8      1 Peciolo     NA
##  9 Actara d1          9      1 Peciolo     NA
## 10 Actara d1         10      1 Peciolo     NA
## # ... with 2,090 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;div id=&#34;basico&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Básico&lt;/h2&gt;
&lt;p&gt;A primeira sequência de gráficos está relacionada ao total de galhas encontradas nas mudas de cada tratamento. Nessa comparação, temos de considerar tratamentos como fatores e os locais onde a galha foi encontrada como níveis do fator local. Essa distinção vai nos ajuda a escolher a melhor forma de construir um gráfico de acordo com o que queremos mostrar.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# seleciona apenas as Coletas de numero 5, em seguida monta um fator de 
# agrupamento em função de Tratamento. Aplica a soma de todas as
# observações (Galhas) de acordo com o fator de agrupamento.

total_trat &amp;lt;- dados %&amp;gt;%
  filter(Coleta == 5) %&amp;gt;%
  group_by(Tratamento) %&amp;gt;%
  summarise(Galhas = sum(Galhas, na.rm=T))

total_trat&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 7 x 2
##   Tratamento  Galhas
##   &amp;lt;chr&amp;gt;        &amp;lt;dbl&amp;gt;
## 1 Actara d1       73
## 2 Actara d2       57
## 3 Actara d3       30
## 4 Evidence d1     27
## 5 Evidence d2     21
## 6 Evidence d3     12
## 7 Testemunha      77&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Agora já podemos fazer o primeiro gráfico simples e básico (Figura &lt;a href=&#34;#fig:5-bar-basico&#34;&gt;1&lt;/a&gt;).&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggplot(total_trat, aes(Tratamento, Galhas)) +
  geom_col(alpha = 0.8) +
  theme_bw(16)&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;figure&#34;&gt;&lt;span id=&#34;fig:5-bar-basico&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;https://italocegatta.github.io/post/2016-05-14-os-graficos-que-explicam-nossos-dados-barras_files/figure-html/5-bar-basico-1.svg&#34; alt=&#34;Número total de galhas de cada tratamento.&#34; width=&#34;960&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figura  1: Número total de galhas de cada tratamento.
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Mas ainda temos a variável &lt;code&gt;Local&lt;/code&gt;, certo? Podemos apresentá-la sem muito esforço.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;total_trat_local &amp;lt;- dados %&amp;gt;%
  filter(Coleta == 5) %&amp;gt;%
  group_by(Tratamento, Local) %&amp;gt;%
  summarise(Galhas = sum(Galhas, na.rm=T))

total_trat_local&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 21 x 3
## # Groups:   Tratamento [7]
##    Tratamento  Local   Galhas
##    &amp;lt;chr&amp;gt;       &amp;lt;chr&amp;gt;    &amp;lt;dbl&amp;gt;
##  1 Actara d1   Caule       13
##  2 Actara d1   Nervura     19
##  3 Actara d1   Peciolo     41
##  4 Actara d2   Caule       10
##  5 Actara d2   Nervura      9
##  6 Actara d2   Peciolo     38
##  7 Actara d3   Caule        7
##  8 Actara d3   Nervura      6
##  9 Actara d3   Peciolo     17
## 10 Evidence d1 Caule        6
## # ... with 11 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggplot(total_trat_local, aes(Tratamento, Galhas, fill = Local)) +
  geom_col(alpha = 0.8) +
  scale_fill_brewer(palette = &amp;quot;Dark2&amp;quot;) +
  theme_bw(16)&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;figure&#34;&gt;&lt;span id=&#34;fig:5-bar-local&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;https://italocegatta.github.io/post/2016-05-14-os-graficos-que-explicam-nossos-dados-barras_files/figure-html/5-bar-local-1.svg&#34; alt=&#34;Número total de galhas de cada tratamento em diferentes locais - níveis agrupados.&#34; width=&#34;960&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figura  2: Número total de galhas de cada tratamento em diferentes locais - níveis agrupados.
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;No caso da Figura &lt;a href=&#34;#fig:5-bar-local&#34;&gt;2&lt;/a&gt;, à primeira vista comparamos as barras (fatores) e depois as cores (níveis). Podemos dar mais evidência aos níveis, transformando-os em barras como na Figura &lt;a href=&#34;#fig:5-bar-local-dodge&#34;&gt;3&lt;/a&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggplot(total_trat_local, aes(Tratamento, Galhas, fill = Local)) +
  geom_col(alpha = 0.8, position = &amp;quot;dodge&amp;quot;) +
  scale_fill_brewer(palette = &amp;quot;Dark2&amp;quot;) +
  theme_bw(16)&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;figure&#34;&gt;&lt;span id=&#34;fig:5-bar-local-dodge&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;https://italocegatta.github.io/post/2016-05-14-os-graficos-que-explicam-nossos-dados-barras_files/figure-html/5-bar-local-dodge-1.svg&#34; alt=&#34;Número total de galhas de cada tratamento em diferentes locais - níveis lado a lados.&#34; width=&#34;960&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figura  3: Número total de galhas de cada tratamento em diferentes locais - níveis lado a lados.
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Como alternativa, podemos subdividir os níveis em painéis e deixar o gráfico mais balanceado, ou seja, sem concentrar a informação em fatores ou níveis (Figura &lt;a href=&#34;#fig:5-bar-local-facet&#34;&gt;4&lt;/a&gt;).&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggplot(total_trat_local, aes(Tratamento, Galhas )) +
  geom_col(alpha = 0.8, position = &amp;quot;dodge&amp;quot;) +
  facet_wrap(~Local) +
  theme_bw(16) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1))&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;figure&#34;&gt;&lt;span id=&#34;fig:5-bar-local-facet&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;https://italocegatta.github.io/post/2016-05-14-os-graficos-que-explicam-nossos-dados-barras_files/figure-html/5-bar-local-facet-1.svg&#34; alt=&#34;Número total de galhas de cada tratamento em diferentes locais - níveis em painel.&#34; width=&#34;960&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figura  4: Número total de galhas de cada tratamento em diferentes locais - níveis em painel.
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Note que nos 3 gráficos anteriores o banco de dados para formação do gráfico é o mesmo, mas cada um dá ênfase em um aspecto diferente. A parte boa é que podemos modificá-los de acordo com o nosso interesse de uma forma rápida e bem simples.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;adicionando-valores-as-barras&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Adicionando valores às barras&lt;/h2&gt;
&lt;p&gt;Se quisermos adicionar o valor de cada nível ou fator na barra, temos de alterar o banco de dados para que ele coincida com o que queremos mostrar.&lt;/p&gt;
&lt;p&gt;Para a Figura &lt;a href=&#34;#fig:5-bar-basico-annot&#34;&gt;5&lt;/a&gt;, modificamos apenas o código do gráfico.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggplot(total_trat, aes(Tratamento, Galhas)) +
  geom_col(alpha = 0.8) +
  geom_text(aes(label = Galhas), size = 6, vjust = -0.2) +
  theme_bw(16)&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;figure&#34;&gt;&lt;span id=&#34;fig:5-bar-basico-annot&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;https://italocegatta.github.io/post/2016-05-14-os-graficos-que-explicam-nossos-dados-barras_files/figure-html/5-bar-basico-annot-1.svg&#34; alt=&#34;Número total de galhas de cada tratamento com o valor na respectiva barra.&#34; width=&#34;960&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figura  5: Número total de galhas de cada tratamento com o valor na respectiva barra.
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Também é fácil indicar o número de galhas por local nas barras. A função &lt;code&gt;position_stack()&lt;/code&gt; é responsável por colocar o texto no topo de cada compartimento colorido. Para ficar mais atraente, podemos adicionar um parâmetro para que o texto fique 20% a baixo do topo do compartimento. Como resultado temos a Figura &lt;a href=&#34;#fig:5-bar-local-annot&#34;&gt;6&lt;/a&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# Cria uma nova coluna que contem a posição no eixo y que corresponde ao centro
# da barra. Esta posição correnponde ao local onde o label de cada barra
# será mostrado

ggplot(total_trat_local, aes(Tratamento, Galhas, fill = Local)) +
    geom_col(alpha = 0.8) +
    geom_text(
      aes(label = Galhas),
      position =  position_stack(vjust = 0.8), vjust = 1
    ) +
    scale_fill_brewer(palette = &amp;quot;Dark2&amp;quot;) +
    theme_bw(16) &lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;figure&#34;&gt;&lt;span id=&#34;fig:5-bar-local-annot&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;https://italocegatta.github.io/post/2016-05-14-os-graficos-que-explicam-nossos-dados-barras_files/figure-html/5-bar-local-annot-1.svg&#34; alt=&#34;Número total de galhas de cada tratamento em diferentes locais com o valor da respectiva barra - níveis agrupados.&#34; width=&#34;960&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figura  6: Número total de galhas de cada tratamento em diferentes locais com o valor da respectiva barra - níveis agrupados.
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;As Figuras &lt;a href=&#34;#fig:5-bar-local-dodge-annot&#34;&gt;7&lt;/a&gt; e &lt;a href=&#34;#fig:5-bar-local-facet-annot&#34;&gt;8&lt;/a&gt; foram criadas apenas alterando o código do gráfico.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggplot(total_trat_local, aes(Tratamento, Galhas, fill = Local)) +
    geom_col(alpha = 0.8, position = &amp;quot;dodge&amp;quot;) +
    geom_text(
      aes(label = Galhas),
      position = position_dodge(width=0.9), vjust = -0.2
    ) +
    scale_fill_brewer(palette = &amp;quot;Dark2&amp;quot;) +
    theme_bw(16) &lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;figure&#34;&gt;&lt;span id=&#34;fig:5-bar-local-dodge-annot&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;https://italocegatta.github.io/post/2016-05-14-os-graficos-que-explicam-nossos-dados-barras_files/figure-html/5-bar-local-dodge-annot-1.svg&#34; alt=&#34;Número total de galhas de cada tratamento em diferentes locais com o valor da respectiva barra - níveis lado a lados.&#34; width=&#34;960&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figura  7: Número total de galhas de cada tratamento em diferentes locais com o valor da respectiva barra - níveis lado a lados.
&lt;/p&gt;
&lt;/div&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggplot(total_trat_local, aes(Tratamento, Galhas )) +
  geom_col(alpha = 0.8) +
  geom_text(aes(label = Galhas), vjust = -0.2) +
  facet_wrap(~Local) +
  theme_bw(16) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1))&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;figure&#34;&gt;&lt;span id=&#34;fig:5-bar-local-facet-annot&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;https://italocegatta.github.io/post/2016-05-14-os-graficos-que-explicam-nossos-dados-barras_files/figure-html/5-bar-local-facet-annot-1.svg&#34; alt=&#34;Número total de galhas de cada tratamento em diferentes locais com o valor da respectiva barra - níveis em painel.&#34; width=&#34;960&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figura  8: Número total de galhas de cada tratamento em diferentes locais com o valor da respectiva barra - níveis em painel.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;barra-de-desvio&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Barra de desvio&lt;/h2&gt;
&lt;p&gt;Uma outra informação interessante para o gráfico de barras é a barra de erro ou desvio. Com ela, além de informarmos o valor que queremos, também informamos uma medida de dispersão associada a esse valor. Nos gráficos anteriores apresentei o total de galhas por tratamento e local. Não faz sentido, nesse caso, colocar uma barra de desvio, pois a soma não é uma medida de posição. Portanto, vamos resumir novamente os dados em função da média e acrescentar o erro padrão da média.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# Seleciona apenas as Coletas de numero 5, em seguida calcula a média e o
# desvio padrão de cada Tratamento.

media_trat_desv &amp;lt;- dados %&amp;gt;%
  filter(Coleta == 5) %&amp;gt;%
  group_by(Tratamento) %&amp;gt;%
  summarise(desv = sd(Galhas, na.rm=T)/sqrt(n()),
    Galhas = mean(Galhas, na.rm=T))

media_trat_desv&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 7 x 3
##   Tratamento   desv Galhas
##   &amp;lt;chr&amp;gt;       &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt;
## 1 Actara d1   0.480   4.06
## 2 Actara d2   0.489   3.35
## 3 Actara d3   0.133   2.31
## 4 Evidence d1 0.589   3.86
## 5 Evidence d2 0.267   2.62
## 6 Evidence d3 0.163   2   
## 7 Testemunha  0.360   3.35&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Após criar o &lt;em&gt;data frame&lt;/em&gt; com o desvio, a Figura &lt;a href=&#34;#fig:5-bar-basico-desv&#34;&gt;9&lt;/a&gt; é facilmente criada com o código abaixo.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggplot(media_trat_desv, aes(Tratamento, Galhas)) +
  geom_col(alpha = 0.8) +
  geom_errorbar(
    aes(ymin = Galhas - desv, ymax = Galhas + desv), 
    width = 0.4, alpha = 0.8
  ) +
  theme_bw(16)&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;figure&#34;&gt;&lt;span id=&#34;fig:5-bar-basico-desv&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;https://italocegatta.github.io/post/2016-05-14-os-graficos-que-explicam-nossos-dados-barras_files/figure-html/5-bar-basico-desv-1.svg&#34; alt=&#34;Número total de galhas de cada tratamento com barra de desvio.&#34; width=&#34;960&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figura  9: Número total de galhas de cada tratamento com barra de desvio.
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;No caso das Figuras &lt;a href=&#34;#fig:5-bar-local-dodge-desv&#34;&gt;10&lt;/a&gt; e &lt;a href=&#34;#fig:5-bar-local-facet-desv&#34;&gt;11&lt;/a&gt;, precisamos dos dados agrupados por &lt;code&gt;Tratamento&lt;/code&gt; e &lt;code&gt;Local&lt;/code&gt;. O código para o gráfico é muito semelhante aos anteriores. Em alguns tratamentos há somente um indivíduo com contagem de galhas, portanto, nesta situação não há barra de desvio.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# Seleciona apenas as Coletas de numero 5, em seguida calcula a mediana e o
# desvio padrão em função de cada Trtatamento e Local.

mediana_trat_local_desv &amp;lt;- dados %&amp;gt;%
  filter(Coleta == 5) %&amp;gt;%
  group_by(Tratamento, Local) %&amp;gt;%
  summarise(desv = sd(Galhas, na.rm=T)/sqrt(n()),
    Galhas = median(Galhas, na.rm=T))

mediana_trat_local_desv&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 21 x 4
## # Groups:   Tratamento [7]
##    Tratamento  Local    desv Galhas
##    &amp;lt;chr&amp;gt;       &amp;lt;chr&amp;gt;   &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt;
##  1 Actara d1   Caule   0.329      2
##  2 Actara d1   Nervura 0.828      3
##  3 Actara d1   Peciolo 1.02       4
##  4 Actara d2   Caule   0.271      1
##  5 Actara d2   Nervura 0.281      2
##  6 Actara d2   Peciolo 1.18       4
##  7 Actara d3   Caule   0.112      2
##  8 Actara d3   Nervura 0          2
##  9 Actara d3   Peciolo 0.297      3
## 10 Evidence d1 Caule   0.224      2
## # ... with 11 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggplot(mediana_trat_local_desv, aes(Tratamento, Galhas, fill = Local)) +
  geom_col(alpha = 0.5, position = &amp;quot;dodge&amp;quot;) +
  geom_errorbar(
    aes(ymin = Galhas - desv, ymax = Galhas + desv),
    position = position_dodge(width=0.9), 
    width = 0.4, alpha = 0.8
  ) +
  scale_fill_brewer(palette = &amp;quot;Dark2&amp;quot;) +
  theme_bw(16)&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;figure&#34;&gt;&lt;span id=&#34;fig:5-bar-local-dodge-desv&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;https://italocegatta.github.io/post/2016-05-14-os-graficos-que-explicam-nossos-dados-barras_files/figure-html/5-bar-local-dodge-desv-1.svg&#34; alt=&#34;Número total de galhas de cada tratamento em diferentes locais com barra de desvio - níveis lado a lado.&#34; width=&#34;960&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figura  10: Número total de galhas de cada tratamento em diferentes locais com barra de desvio - níveis lado a lado.
&lt;/p&gt;
&lt;/div&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggplot(mediana_trat_local_desv, aes(Tratamento, Galhas )) +
  geom_col(alpha = 0.8, position = &amp;quot;dodge&amp;quot;) +
  geom_errorbar(
    aes(ymin = Galhas - desv, ymax = Galhas + desv),
    width = 0.4, alpha = 0.8
  ) +
  facet_wrap(~Local) +
  theme_bw(16) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1))&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;figure&#34;&gt;&lt;span id=&#34;fig:5-bar-local-facet-desv&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;https://italocegatta.github.io/post/2016-05-14-os-graficos-que-explicam-nossos-dados-barras_files/figure-html/5-bar-local-facet-desv-1.svg&#34; alt=&#34;Número total de galhas de cada tratamento em diferentes locais com barra de desvio - níveis em painel.&#34; width=&#34;960&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figura  11: Número total de galhas de cada tratamento em diferentes locais com barra de desvio - níveis em painel.
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Caso tenha alguma dúvida ou sugestão sobre o post, fique à vontade para fazer um comentário ou me contatar por E-mail.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;sessioninfo::session_info(c(&amp;quot;readr&amp;quot;, &amp;quot;dplyr&amp;quot;, &amp;quot;ggplot2&amp;quot;))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## - Session info ----------------------------------------------------------
##  setting  value                       
##  version  R version 3.5.3 (2019-03-11)
##  os       Windows 10 x64              
##  system   x86_64, mingw32             
##  ui       RTerm                       
##  language (EN)                        
##  collate  Portuguese_Brazil.1252      
##  ctype    Portuguese_Brazil.1252      
##  tz       America/Sao_Paulo           
##  date     2019-08-25                  
## 
## - Packages --------------------------------------------------------------
##  package      * version  date       lib source        
##  assertthat     0.2.1    2019-03-21 [1] CRAN (R 3.5.3)
##  backports      1.1.4    2019-04-10 [1] CRAN (R 3.5.3)
##  BH             1.69.0-1 2019-01-07 [1] CRAN (R 3.5.2)
##  cli            1.1.0    2019-03-19 [1] CRAN (R 3.5.3)
##  clipr          0.7.0    2019-07-23 [1] CRAN (R 3.5.3)
##  colorspace     1.4-1    2019-03-18 [1] CRAN (R 3.5.3)
##  crayon         1.3.4    2017-09-16 [1] CRAN (R 3.5.1)
##  digest         0.6.20   2019-07-04 [1] CRAN (R 3.5.3)
##  dplyr        * 0.8.3    2019-07-04 [1] CRAN (R 3.5.3)
##  ellipsis       0.2.0.1  2019-07-02 [1] CRAN (R 3.5.3)
##  fansi          0.4.0    2018-10-05 [1] CRAN (R 3.5.1)
##  ggplot2      * 3.2.1    2019-08-10 [1] CRAN (R 3.5.3)
##  glue           1.3.1    2019-03-12 [1] CRAN (R 3.5.3)
##  gtable         0.3.0    2019-03-25 [1] CRAN (R 3.5.3)
##  hms            0.5.0    2019-07-09 [1] CRAN (R 3.5.3)
##  labeling       0.3      2014-08-23 [1] CRAN (R 3.5.0)
##  lattice        0.20-38  2018-11-04 [2] CRAN (R 3.5.3)
##  lazyeval       0.2.2    2019-03-15 [1] CRAN (R 3.5.3)
##  magrittr       1.5      2014-11-22 [1] CRAN (R 3.5.1)
##  MASS           7.3-51.1 2018-11-01 [2] CRAN (R 3.5.3)
##  Matrix         1.2-17   2019-03-22 [1] CRAN (R 3.5.3)
##  mgcv           1.8-28   2019-03-21 [1] CRAN (R 3.5.3)
##  munsell        0.5.0    2018-06-12 [1] CRAN (R 3.5.1)
##  nlme           3.1-137  2018-04-07 [2] CRAN (R 3.5.3)
##  pillar         1.4.2    2019-06-29 [1] CRAN (R 3.5.3)
##  pkgconfig      2.0.2    2018-08-16 [1] CRAN (R 3.5.1)
##  plogr          0.2.0    2018-03-25 [1] CRAN (R 3.5.1)
##  plyr           1.8.4    2016-06-08 [1] CRAN (R 3.5.1)
##  purrr          0.3.2    2019-03-15 [1] CRAN (R 3.5.3)
##  R6             2.4.0    2019-02-14 [1] CRAN (R 3.5.2)
##  RColorBrewer   1.1-2    2014-12-07 [1] CRAN (R 3.5.0)
##  Rcpp           1.0.2    2019-07-25 [1] CRAN (R 3.5.3)
##  readr        * 1.3.1    2018-12-21 [1] CRAN (R 3.5.2)
##  reshape2       1.4.3    2017-12-11 [1] CRAN (R 3.5.1)
##  rlang          0.4.0    2019-06-25 [1] CRAN (R 3.5.3)
##  scales         1.0.0    2018-08-09 [1] CRAN (R 3.5.1)
##  stringi        1.4.3    2019-03-12 [1] CRAN (R 3.5.3)
##  stringr        1.4.0    2019-02-10 [1] CRAN (R 3.5.2)
##  tibble         2.1.3    2019-06-06 [1] CRAN (R 3.5.3)
##  tidyselect     0.2.5    2018-10-11 [1] CRAN (R 3.5.1)
##  utf8           1.1.4    2018-05-24 [1] CRAN (R 3.5.1)
##  vctrs          0.2.0    2019-07-05 [1] CRAN (R 3.5.3)
##  viridisLite    0.3.0    2018-02-01 [1] CRAN (R 3.5.1)
##  withr          2.1.2    2018-03-15 [1] CRAN (R 3.5.1)
##  zeallot        0.1.0    2018-01-28 [1] CRAN (R 3.5.2)
## 
## [1] C:/Users/Italo/Documents/R/win-library/3.5
## [2] C:/Program Files/R/R-3.5.3/library&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

      </content:encoded>
    </item>
    
    <item>
      <title>Os gráficos que explicam nossos dados (boxplot)</title>
      <link>https://italocegatta.github.io/os-graficos-que-explicam-nossos-dados-boxplot/</link>
      <pubDate>Fri, 06 May 2016 00:00:00 +0000</pubDate>
      
      <guid>https://italocegatta.github.io/os-graficos-que-explicam-nossos-dados-boxplot/</guid>
      <description>Nossos dados merecem ser apresentados de forma clara, atraente e inspiradora. Não há nada mais frustrante que dar duro no campo para coletar os dados e depois apresentá-los numa simples tabela de resumos. Podemos e devemos fazer mais, certo?
Vou começar agora uma série de posts sobre tipos de gráficos. Como disse no primeiro post desse blog, minha intenção é documentar os scripts que escrevi durante a graduação, portanto os gráficos que vou apresentar se resumem aos que tive de fazer por conta de alguma demanda específica.</description>
      <content:encoded>
        


&lt;p&gt;Nossos dados merecem ser apresentados de forma clara, atraente e inspiradora. Não há nada mais frustrante que dar duro no campo para coletar os dados e depois apresentá-los numa simples tabela de resumos. Podemos e devemos fazer mais, certo?&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;Vou começar agora uma série de posts sobre tipos de gráficos. Como disse no primeiro post desse &lt;a href=&#34;https://italocegatta.github.io/sobre-esse-blog.html&#34;&gt;blog&lt;/a&gt;, minha intenção é documentar os scripts que escrevi durante a graduação, portanto os gráficos que vou apresentar se resumem aos que tive de fazer por conta de alguma demanda específica.&lt;/p&gt;
&lt;p&gt;Para iniciar, escolhi o gráfico boxplot. É um gráfico muito útil para entender a variabilidade das nossas observações. No boxplot temos 5 informações básicas: valor mínimo, primeiro quartil, mediana, terceiro quartil e valor máximo. Há ainda a notificação de &lt;em&gt;outliers&lt;/em&gt;, quando a observação é maior ou menor que 1,5 vezes a distância interquartílica.&lt;/p&gt;
&lt;p&gt;Vamos trabalhar com os dados que apresentei no post anterior sobre &lt;a href=&#34;https://italocegatta.github.io/o-conceito-tidy-data.html&#34;&gt;tidy data&lt;/a&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(pacman)
p_load(readr, dplyr, tidyr, ggplot2, ggthemes)&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;dados &amp;lt;- read_csv2(
  &amp;quot;https://raw.githubusercontent.com/italocegatta/italocegatta.github.io_source/master/content/dados/base_vespa.csv&amp;quot;
)

dados&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 2,100 x 5
##    Tratamento Individuo Coleta Local   Galhas
##    &amp;lt;chr&amp;gt;          &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt; &amp;lt;chr&amp;gt;    &amp;lt;dbl&amp;gt;
##  1 Actara d1          1      1 Peciolo      1
##  2 Actara d1          2      1 Peciolo     NA
##  3 Actara d1          3      1 Peciolo     NA
##  4 Actara d1          4      1 Peciolo     NA
##  5 Actara d1          5      1 Peciolo     NA
##  6 Actara d1          6      1 Peciolo     NA
##  7 Actara d1          7      1 Peciolo     NA
##  8 Actara d1          8      1 Peciolo     NA
##  9 Actara d1          9      1 Peciolo     NA
## 10 Actara d1         10      1 Peciolo     NA
## # ... with 2,090 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Primeiro vamos processar os dados da última medição (Coleta 5) para verificar o nº total de galhas de cada tratamento, desconsiderando o local da galha. Nesse caso estou considerando apenas as mudas que foram atacadas e tiveram o desenvolvimento de galhas.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# seleciona apenas as Coletas de numero 5, em seguida monta um fator de 
# agrupamento em função de Tratamento e Individuo. Aplica a soma de todas as
# observações (Galhas) de acordo com o fator de agrupamento. Troca os valores
# 0 (quando não há galhas) por NA.

total &amp;lt;- dados %&amp;gt;%
  filter(Coleta == 5) %&amp;gt;%
  group_by(Tratamento, Individuo) %&amp;gt;%
  summarise(Galhas = sum(Galhas, na.rm=T)) %&amp;gt;%
  mutate(Galhas = replace(Galhas, Galhas == 0, NA))

total&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 140 x 3
## # Groups:   Tratamento [7]
##    Tratamento Individuo Galhas
##    &amp;lt;chr&amp;gt;          &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt;
##  1 Actara d1          1     11
##  2 Actara d1          2     NA
##  3 Actara d1          3      4
##  4 Actara d1          4     NA
##  5 Actara d1          5     NA
##  6 Actara d1          6     NA
##  7 Actara d1          7     30
##  8 Actara d1          8     NA
##  9 Actara d1          9     NA
## 10 Actara d1         10     NA
## # ... with 130 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;O boxplot é um gráfico unidimensional, ou seja, precisamos de apenas uma variável para construí-lo. Entretanto, podemos usar variáveis categóricas para servir de agrupamento e replicar o gráfico para todos os níveis da variável. Por exemplo, no nosso banco de dados temos &lt;code&gt;Galhas&lt;/code&gt; como variável quantitativa e &lt;code&gt;Tratamento&lt;/code&gt;, &lt;code&gt;Coleta&lt;/code&gt; e &lt;code&gt;Local&lt;/code&gt; como variável qualitativa.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggplot(total, aes(&amp;quot;Total&amp;quot;, Galhas)) +
  geom_boxplot(fill = &amp;quot;grey60&amp;quot;, alpha = 0.8) +
  theme_bw()&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;figure&#34;&gt;&lt;span id=&#34;fig:4-boxplot-total&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;https://italocegatta.github.io/post/2016-05-06-os-graficos-que-explicam-nossos-dados-boxplot_files/figure-html/4-boxplot-total-1.svg&#34; alt=&#34;Boxplot que mostra o nº de galhas de todos os tratamentos.&#34; width=&#34;960&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figura  1: Boxplot que mostra o nº de galhas de todos os tratamentos.
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;A Figura &lt;a href=&#34;#fig:4-boxplot-total&#34;&gt;1&lt;/a&gt; dá uma visão geral de todas as observações em um único boxplot, mas não nos explica muita coisa. No caso da Figura &lt;a href=&#34;#fig:4-boxplot-trat&#34;&gt;2&lt;/a&gt;, &lt;code&gt;Tratamento&lt;/code&gt; tratamento é uma variável categórica e nos permite subdividir os boxplots para todos os níveis e assim podemos compará-los.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggplot(total, aes(Tratamento, Galhas)) +
  geom_boxplot(fill = &amp;quot;grey60&amp;quot;, alpha = 0.8) +
  theme_bw(16)&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;figure&#34;&gt;&lt;span id=&#34;fig:4-boxplot-trat&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;https://italocegatta.github.io/post/2016-05-06-os-graficos-que-explicam-nossos-dados-boxplot_files/figure-html/4-boxplot-trat-1.svg&#34; alt=&#34;Boxplot que mostra o nº de galhas em função de cada tratamento.&#34; width=&#34;960&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figura  2: Boxplot que mostra o nº de galhas em função de cada tratamento.
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Note que no tratamento &lt;em&gt;Actara d1&lt;/em&gt;, há um indivíduo discrepante (&lt;em&gt;outlier&lt;/em&gt;) que se destaca com 30 galhas. Note também a grande variabilidade entre os tratamentos, muito comum em experimentos envolvendo insetos. Normalmente o coeficiente de variação é extremamente alto e dificilmente há homogeneidade de variância. Um comentário interessante sobre o boxplot é que a caixa, valores entre o 1º e 3º quartil, corresponde a 50% das observações.&lt;/p&gt;
&lt;p&gt;Podemos também avaliar a variabilidade do nº de galhas por local. Para isso vamos incluir a variável &lt;code&gt;Local&lt;/code&gt; no agrupamento (Figura &lt;a href=&#34;#fig:4-boxplot-local&#34;&gt;3&lt;/a&gt;).&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# Adiciona mais um fator de agrupamento para o resumo. Nesse caso cada
# indivíduo terá o nº de galhas explicito em cada local.

local &amp;lt;- dados %&amp;gt;%
  filter(Coleta == 5) %&amp;gt;%
  group_by(Tratamento, Individuo, Local) %&amp;gt;%
  summarise(Galhas = sum(Galhas, na.rm=T)) %&amp;gt;%
  mutate(Galhas = replace(Galhas, Galhas == 0, NA))

local&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 420 x 4
## # Groups:   Tratamento, Individuo [140]
##    Tratamento Individuo Local   Galhas
##    &amp;lt;chr&amp;gt;          &amp;lt;dbl&amp;gt; &amp;lt;chr&amp;gt;    &amp;lt;dbl&amp;gt;
##  1 Actara d1          1 Caule        2
##  2 Actara d1          1 Nervura      3
##  3 Actara d1          1 Peciolo      6
##  4 Actara d1          2 Caule       NA
##  5 Actara d1          2 Nervura     NA
##  6 Actara d1          2 Peciolo     NA
##  7 Actara d1          3 Caule        1
##  8 Actara d1          3 Nervura      1
##  9 Actara d1          3 Peciolo      2
## 10 Actara d1          4 Caule       NA
## # ... with 410 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggplot(local, aes(Tratamento, Galhas, fill = Local)) +
  geom_boxplot(alpha = 0.8) +
  scale_fill_brewer(palette = &amp;quot;Spectral&amp;quot;) +
  theme_bw(16)&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;figure&#34;&gt;&lt;span id=&#34;fig:4-boxplot-local&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;https://italocegatta.github.io/post/2016-05-06-os-graficos-que-explicam-nossos-dados-boxplot_files/figure-html/4-boxplot-local-1.svg&#34; alt=&#34;Boxplot que mostra o nº de galhas por local e tratamento.&#34; width=&#34;960&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figura  3: Boxplot que mostra o nº de galhas por local e tratamento.
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Uma outra perspectiva é avaliar a evolução do total de galhas por coleta. Para isto basta incluir a variável &lt;code&gt;Coleta&lt;/code&gt; no agrupamento (Figura &lt;a href=&#34;#fig:4-boxplot-coleta&#34;&gt;4&lt;/a&gt;). Para facilitar a visualização, vou excluir a primeira coleta. Podemos ainda adicionar os pontos que representam as observações para poder identificar quantas observações tem cada tratamento.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;total_coleta &amp;lt;- dados %&amp;gt;%
  filter(Coleta != 1 ) %&amp;gt;%
  group_by(Tratamento, Coleta, Individuo) %&amp;gt;%
  summarise(Galhas = sum(Galhas, na.rm=T)) %&amp;gt;%
  mutate(Galhas = replace(Galhas, Galhas == 0, NA))

total_coleta&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 560 x 4
## # Groups:   Tratamento, Coleta [28]
##    Tratamento Coleta Individuo Galhas
##    &amp;lt;chr&amp;gt;       &amp;lt;dbl&amp;gt;     &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt;
##  1 Actara d1       2         1      3
##  2 Actara d1       2         2     NA
##  3 Actara d1       2         3     NA
##  4 Actara d1       2         4     NA
##  5 Actara d1       2         5     NA
##  6 Actara d1       2         6     NA
##  7 Actara d1       2         7      2
##  8 Actara d1       2         8     NA
##  9 Actara d1       2         9     NA
## 10 Actara d1       2        10     NA
## # ... with 550 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggplot(total_coleta, aes(Tratamento, Galhas)) +
  geom_boxplot(fill = &amp;quot;grey60&amp;quot;, alpha = 0.8, outlier.color = NA) +
  geom_jitter(alpha = 0.4) +
  facet_wrap(~Coleta) +
  theme_bw(16) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1))&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;figure&#34;&gt;&lt;span id=&#34;fig:4-boxplot-coleta&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;https://italocegatta.github.io/post/2016-05-06-os-graficos-que-explicam-nossos-dados-boxplot_files/figure-html/4-boxplot-coleta-1.svg&#34; alt=&#34;Boxplot que mostra a dispersão do total de galhas por tratamento e coletas.&#34; width=&#34;960&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figura  4: Boxplot que mostra a dispersão do total de galhas por tratamento e coletas.
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;É importante destacar que o gráfico da Figura &lt;a href=&#34;#fig:4-boxplot-coleta&#34;&gt;4&lt;/a&gt; não é adequado para esse tipo de informação. Nesse caso seria mais interessante um gráfico de linhas em que cada linha representa um tratamento (veremos esse gráfico em um futuro post).&lt;/p&gt;
&lt;p&gt;Caso tenha alguma dúvida ou sugestão sobre o post, fique à vontade para fazer um comentário ou me contatar por E-mail.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;devtools::session_info()&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## - Session info ----------------------------------------------------------
##  setting  value                       
##  version  R version 3.5.3 (2019-03-11)
##  os       Windows 10 x64              
##  system   x86_64, mingw32             
##  ui       RTerm                       
##  language (EN)                        
##  collate  Portuguese_Brazil.1252      
##  ctype    Portuguese_Brazil.1252      
##  tz       America/Sao_Paulo           
##  date     2019-08-25                  
## 
## - Packages --------------------------------------------------------------
##  package      * version date       lib source        
##  assertthat     0.2.1   2019-03-21 [1] CRAN (R 3.5.3)
##  backports      1.1.4   2019-04-10 [1] CRAN (R 3.5.3)
##  blogdown       0.14    2019-07-13 [1] CRAN (R 3.5.3)
##  bookdown       0.12    2019-07-11 [1] CRAN (R 3.5.3)
##  callr          3.3.1   2019-07-18 [1] CRAN (R 3.5.3)
##  cli            1.1.0   2019-03-19 [1] CRAN (R 3.5.3)
##  colorspace     1.4-1   2019-03-18 [1] CRAN (R 3.5.3)
##  crayon         1.3.4   2017-09-16 [1] CRAN (R 3.5.1)
##  curl           4.0     2019-07-22 [1] CRAN (R 3.5.3)
##  desc           1.2.0   2018-05-01 [1] CRAN (R 3.5.1)
##  devtools       2.1.0   2019-07-06 [1] CRAN (R 3.5.3)
##  digest         0.6.20  2019-07-04 [1] CRAN (R 3.5.3)
##  dplyr        * 0.8.3   2019-07-04 [1] CRAN (R 3.5.3)
##  evaluate       0.14    2019-05-28 [1] CRAN (R 3.5.3)
##  fansi          0.4.0   2018-10-05 [1] CRAN (R 3.5.1)
##  fs             1.3.1   2019-05-06 [1] CRAN (R 3.5.3)
##  ggplot2      * 3.2.1   2019-08-10 [1] CRAN (R 3.5.3)
##  ggthemes     * 4.2.0   2019-05-13 [1] CRAN (R 3.5.3)
##  glue           1.3.1   2019-03-12 [1] CRAN (R 3.5.3)
##  gtable         0.3.0   2019-03-25 [1] CRAN (R 3.5.3)
##  highr          0.8     2019-03-20 [1] CRAN (R 3.5.3)
##  hms            0.5.0   2019-07-09 [1] CRAN (R 3.5.3)
##  htmltools      0.3.6   2017-04-28 [1] CRAN (R 3.5.1)
##  knitr          1.24    2019-08-08 [1] CRAN (R 3.5.3)
##  labeling       0.3     2014-08-23 [1] CRAN (R 3.5.0)
##  lazyeval       0.2.2   2019-03-15 [1] CRAN (R 3.5.3)
##  magrittr       1.5     2014-11-22 [1] CRAN (R 3.5.1)
##  memoise        1.1.0   2017-04-21 [1] CRAN (R 3.5.1)
##  munsell        0.5.0   2018-06-12 [1] CRAN (R 3.5.1)
##  pacman       * 0.5.1   2019-03-11 [1] CRAN (R 3.5.3)
##  pillar         1.4.2   2019-06-29 [1] CRAN (R 3.5.3)
##  pkgbuild       1.0.4   2019-08-05 [1] CRAN (R 3.5.3)
##  pkgconfig      2.0.2   2018-08-16 [1] CRAN (R 3.5.1)
##  pkgload        1.0.2   2018-10-29 [1] CRAN (R 3.5.1)
##  prettyunits    1.0.2   2015-07-13 [1] CRAN (R 3.5.1)
##  processx       3.4.1   2019-07-18 [1] CRAN (R 3.5.3)
##  ps             1.3.0   2018-12-21 [1] CRAN (R 3.5.2)
##  purrr          0.3.2   2019-03-15 [1] CRAN (R 3.5.3)
##  R6             2.4.0   2019-02-14 [1] CRAN (R 3.5.2)
##  RColorBrewer   1.1-2   2014-12-07 [1] CRAN (R 3.5.0)
##  Rcpp           1.0.2   2019-07-25 [1] CRAN (R 3.5.3)
##  readr        * 1.3.1   2018-12-21 [1] CRAN (R 3.5.2)
##  remotes        2.1.0   2019-06-24 [1] CRAN (R 3.5.3)
##  rlang          0.4.0   2019-06-25 [1] CRAN (R 3.5.3)
##  rmarkdown      1.14    2019-07-12 [1] CRAN (R 3.5.3)
##  rprojroot      1.3-2   2018-01-03 [1] CRAN (R 3.5.1)
##  scales         1.0.0   2018-08-09 [1] CRAN (R 3.5.1)
##  sessioninfo    1.1.1   2018-11-05 [1] CRAN (R 3.5.2)
##  stringi        1.4.3   2019-03-12 [1] CRAN (R 3.5.3)
##  stringr        1.4.0   2019-02-10 [1] CRAN (R 3.5.2)
##  testthat       2.2.1   2019-07-25 [1] CRAN (R 3.5.3)
##  tibble         2.1.3   2019-06-06 [1] CRAN (R 3.5.3)
##  tidyr        * 0.8.3   2019-03-01 [1] CRAN (R 3.5.3)
##  tidyselect     0.2.5   2018-10-11 [1] CRAN (R 3.5.1)
##  usethis        1.5.1   2019-07-04 [1] CRAN (R 3.5.3)
##  utf8           1.1.4   2018-05-24 [1] CRAN (R 3.5.1)
##  vctrs          0.2.0   2019-07-05 [1] CRAN (R 3.5.3)
##  withr          2.1.2   2018-03-15 [1] CRAN (R 3.5.1)
##  xfun           0.8     2019-06-25 [1] CRAN (R 3.5.3)
##  yaml           2.2.0   2018-07-25 [1] CRAN (R 3.5.1)
##  zeallot        0.1.0   2018-01-28 [1] CRAN (R 3.5.2)
## 
## [1] C:/Users/Italo/Documents/R/win-library/3.5
## [2] C:/Program Files/R/R-3.5.3/library&lt;/code&gt;&lt;/pre&gt;

      </content:encoded>
    </item>
    
    <item>
      <title>O conceito tidy data</title>
      <link>https://italocegatta.github.io/o-conceito-tidy-data/</link>
      <pubDate>Sat, 30 Apr 2016 00:00:00 +0000</pubDate>
      
      <guid>https://italocegatta.github.io/o-conceito-tidy-data/</guid>
      <description>A ideia central desse post é bem simples: dados bem organizados valem a pena e economizam seu tempo!
Em minha primeira iniciação científica (quando comecei a trabalhar com o R), propus um experimento para avaliar a eficiência de 2 inseticidas para o controle de uma praga que ataca mudas de eucalipto (Cegatta and Villegas 2013). Eu estava no primeiro ano da faculdade, sabia muito pouco de Excel e nada de R.</description>
      <content:encoded>
        


&lt;p&gt;A ideia central desse post é bem simples: dados bem organizados valem a pena e economizam seu tempo!&lt;/p&gt;
&lt;p&gt;Em minha primeira iniciação científica (quando comecei a trabalhar com o R), propus um experimento para avaliar a eficiência de 2 inseticidas para o controle de uma praga que ataca mudas de eucalipto &lt;span class=&#34;citation&#34;&gt;(Cegatta and Villegas &lt;a href=&#34;#ref-cegatta_eficiencia_2013&#34;&gt;2013&lt;/a&gt;)&lt;/span&gt;. Eu estava no primeiro ano da faculdade, sabia muito pouco de Excel e nada de R.&lt;/p&gt;
&lt;p&gt;Neste post vou retomar os dados brutos desse experimento e organizá-los de uma forma eficiente, pois na época não o fiz.&lt;/p&gt;
&lt;p&gt;No experimento tivemos 5 coletas sucessivas de dados para acompanhar a evolução do número de galhas em mudas de eucalipto com diferentes tratamentos de inseticidas. Galha é uma reação da planta que tem diversas causas, nesse caso específico, é devido à postura de uma vespa em busca de abrigo para seus ovos.&lt;/p&gt;
&lt;br&gt;
&lt;div class=&#34;figure&#34;&gt;&lt;span id=&#34;fig:fig-base&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;http://i.imgur.com/JsYqVH7.png&#34; alt=&#34;Dados brutos. Como não organizar seu banco de dados.&#34;  /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figura  1: Dados brutos. Como não organizar seu banco de dados.
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;A estrutura do banco de dados que obtive no fim do experimento está apresentada na Figura &lt;a href=&#34;#fig:fig-base&#34;&gt;1&lt;/a&gt;. Para a época, foi o melhor que consegui fazer e pela inexperiência cometi os seguintes erros:&lt;/p&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;Uso de caracteres especiais.&lt;/li&gt;
&lt;li&gt;Uso de espaço entre as palavras.&lt;/li&gt;
&lt;li&gt;Células mescladas.&lt;/li&gt;
&lt;li&gt;Observações (Nº de galhas no pecíolo, nervura e caule) organizadas em colunas.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;O uso de caracteres especiais não é recomentado em muitas ocasiões, essa dica vale para quase tudo que envolve computação. O mesmo se aplica para os espaços entre as palavras, mas podemos ser mais flexíveis neste caso. Mesclar uma célula será o seu maior problema em uma planilha eletrônica, cuidado com isso! Recomendo mesclar células em raríssimas exceções, como formatação de tabelas em Word ou PowerPoint. O meu último erro foi o maior deles, confundi observações com variáveis. Em minha defesa, o inexperiente Ítalo tentou organizar os dados em um layout de fácil visualização. Veja que é fácil acompanhar a evolução das galhas ao longo do tempo. Para a percepção humana, organização de dados no formato longitudinal é muito prática e rápida. Mas temos que pensar em como o computador trabalha e como ele faz todos os cálculos que precisamos. No fim, eu consegui fazer tudo que eu queria com os dados nesse formato, mas acredite, foi sofrível e muito ineficiente.&lt;/p&gt;
&lt;p&gt;O conceito tidy data está muito bem descrito por &lt;span class=&#34;citation&#34;&gt;Wickham (&lt;a href=&#34;#ref-wickham_tidy_2014&#34;&gt;2014&lt;/a&gt;)&lt;/span&gt;, onde ele apresenta o pacote &lt;a href=&#34;https://cran.r-project.org/web/packages/tidyr/index.html&#34;&gt;tidyr&lt;/a&gt; que contém uma gama de funções muito úteis para esse fim. Wickham também dedicou um capítulo específico sobre esse conceito em seu &lt;a href=&#34;http://r4ds.had.co.nz/&#34;&gt;livro&lt;/a&gt; &lt;span class=&#34;citation&#34;&gt;(Grolemund and Wickham &lt;a href=&#34;#ref-grolemund_r_2016&#34;&gt;2016&lt;/a&gt;)&lt;/span&gt;. Por tidy data, entendemos que:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Variáveis estão dispostas em colunas.&lt;/li&gt;
&lt;li&gt;Observações estão dispostas em linhas.&lt;/li&gt;
&lt;li&gt;Os valores atribuídos às variáveis em cada observação formam a tabela.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Agora vamos aplicar esse conceito ao meu banco de dados. Podemos fazer isso de várias formas, vai depender de como iremos entrar com os dados no R. Vou mostrar 2 métodos que penso ser os mais práticos e genéricos.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# Pacotes utilizados neste post
if (!require(&amp;quot;pacman&amp;quot;)) install.packages(&amp;quot;pacman&amp;quot;)
pacman::p_load(readxl, dplyr, tidyr, httr)&lt;/code&gt;&lt;/pre&gt;
&lt;div id=&#34;metodo-1&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Método 1&lt;/h1&gt;
&lt;p&gt;Partindo da base de dados original, fiz uma pequena alteração separando em cada aba as coletas que foram realizadas (Figura &lt;a href=&#34;#fig:fig-entrada1&#34;&gt;2&lt;/a&gt;).&lt;/p&gt;
&lt;br&gt;
&lt;div class=&#34;figure&#34;&gt;&lt;span id=&#34;fig:fig-entrada1&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;http://i.imgur.com/3AsFpmQ.png&#34; alt=&#34;Modificação do banco de dados original para ser importado no R. Divisão das coletas em abas.&#34;  /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figura  2: Modificação do banco de dados original para ser importado no R. Divisão das coletas em abas.
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Como são apenas 4 abas, podemos importá-las usando um comando por linha.&lt;/p&gt;
&lt;p&gt;Mas e se tivéssemos 50 coletas? Deu preguiça. Vamos melhorar a importação e deixar o computador trabalhar por nós.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# Faz o mesmo que os comandos anteriores, mas utiliza um ´for´ para repetir 
# o precesso em todas as abas. 
dados1 &amp;lt;- list()

for(i in 1:5) {
 dados1[[paste0(&amp;quot;c&amp;quot;,i)]] &amp;lt;- read_excel(base_vespa1, paste0(&amp;quot;Coleta&amp;quot;, i))
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Agora precisamos de um fator (nº da coleta) para diferenciarmos cada medição e colocar tudo em um único data frame.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# Cria um fator para diferenciar as medições
for(i in names(dados1)) {
  dados1[[i]][ , &amp;quot;Coleta&amp;quot;] = i  
}

dados1 &amp;lt;- bind_rows(dados1)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Como minhas análises vão considerar o local da galha como variável, devo organizar &lt;em&gt;Peciolo&lt;/em&gt;, &lt;em&gt;Nervura&lt;/em&gt; e &lt;em&gt;Caule&lt;/em&gt; em uma só coluna denominada &lt;em&gt;Local&lt;/em&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# Transforma as columas ´Peciolo´, ´Nervura´ e ´Caule´ em uma só coluna
# denominada ´Local´.
dados1 &amp;lt;- gather(dados1, &amp;quot;Local&amp;quot;, &amp;quot;Galhas&amp;quot;, c(Peciolo, Nervura, Caule))

dados1&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 2,100 x 5
##    Tratamento Individuo Coleta Local   Galhas
##    &amp;lt;chr&amp;gt;          &amp;lt;dbl&amp;gt; &amp;lt;chr&amp;gt;  &amp;lt;chr&amp;gt;    &amp;lt;dbl&amp;gt;
##  1 Actara d1          1 c1     Peciolo      1
##  2 Actara d1          2 c1     Peciolo     NA
##  3 Actara d1          3 c1     Peciolo     NA
##  4 Actara d1          4 c1     Peciolo     NA
##  5 Actara d1          5 c1     Peciolo     NA
##  6 Actara d1          6 c1     Peciolo     NA
##  7 Actara d1          7 c1     Peciolo     NA
##  8 Actara d1          8 c1     Peciolo     NA
##  9 Actara d1          9 c1     Peciolo     NA
## 10 Actara d1         10 c1     Peciolo     NA
## # ... with 2,090 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;metodo-2&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Método 2&lt;/h1&gt;
&lt;p&gt;Nesse método, não fiz nenhuma grande alteração na base de dados. Apenas corrigi o nome das colunas com um fator que indica o número da coleta e em seguida o local (Figura &lt;a href=&#34;#fig:fig-entrada2&#34;&gt;3&lt;/a&gt;).&lt;/p&gt;
&lt;br&gt;
&lt;div class=&#34;figure&#34;&gt;&lt;span id=&#34;fig:fig-entrada2&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;http://i.imgur.com/YGY8pvV.png&#34; alt=&#34;Modificação do banco de dados original para ser importado no R. Alteração dos nomes das colunas.&#34;  /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figura  3: Modificação do banco de dados original para ser importado no R. Alteração dos nomes das colunas.
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Vamos agora importar e organizar os dados no mesmo formato que no método 1, mas com um código bem mais simples.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# Lê os dados, transforma as variáveis que estão em várias colunas em uma só e
# Separa as informações que estão na coluna ´Local´ em duas colunas (variáveis)
# ´Coleta´ e ´Local´.
dados2 &amp;lt;- read_excel(base_vespa2) %&amp;gt;%
  gather(&amp;quot;Local&amp;quot;, &amp;quot;Galhas&amp;quot;, 3:dim(.)[2]) %&amp;gt;%
  separate(Local, c(&amp;quot;Coleta&amp;quot;, &amp;quot;Local&amp;quot;))

dados2&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 2,100 x 5
##    Tratamento Individuo Coleta Local   Galhas
##    &amp;lt;chr&amp;gt;          &amp;lt;dbl&amp;gt; &amp;lt;chr&amp;gt;  &amp;lt;chr&amp;gt;    &amp;lt;dbl&amp;gt;
##  1 Actara d1          1 1      Peciolo      1
##  2 Actara d1          2 1      Peciolo     NA
##  3 Actara d1          3 1      Peciolo     NA
##  4 Actara d1          4 1      Peciolo     NA
##  5 Actara d1          5 1      Peciolo     NA
##  6 Actara d1          6 1      Peciolo     NA
##  7 Actara d1          7 1      Peciolo     NA
##  8 Actara d1          8 1      Peciolo     NA
##  9 Actara d1          9 1      Peciolo     NA
## 10 Actara d1         10 1      Peciolo     NA
## # ... with 2,090 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Com os dados nesse formato fica incrivelmente fácil fazer gráficos, resumos e testes. Vou abordar esses pontos no futuro em outros posts.&lt;/p&gt;
&lt;p&gt;Caso tenha alguma dúvida ou sugestão sobre o post, fique à vontade para fazer um comentário ou me contatar por E-mail.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;devtools::session_info()&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## - Session info ----------------------------------------------------------
##  setting  value                       
##  version  R version 3.5.3 (2019-03-11)
##  os       Windows 10 x64              
##  system   x86_64, mingw32             
##  ui       RTerm                       
##  language (EN)                        
##  collate  Portuguese_Brazil.1252      
##  ctype    Portuguese_Brazil.1252      
##  tz       America/Sao_Paulo           
##  date     2019-08-25                  
## 
## - Packages --------------------------------------------------------------
##  package     * version date       lib source        
##  assertthat    0.2.1   2019-03-21 [1] CRAN (R 3.5.3)
##  backports     1.1.4   2019-04-10 [1] CRAN (R 3.5.3)
##  blogdown      0.14    2019-07-13 [1] CRAN (R 3.5.3)
##  bookdown      0.12    2019-07-11 [1] CRAN (R 3.5.3)
##  callr         3.3.1   2019-07-18 [1] CRAN (R 3.5.3)
##  cellranger    1.1.0   2016-07-27 [1] CRAN (R 3.5.1)
##  cli           1.1.0   2019-03-19 [1] CRAN (R 3.5.3)
##  crayon        1.3.4   2017-09-16 [1] CRAN (R 3.5.1)
##  curl          4.0     2019-07-22 [1] CRAN (R 3.5.3)
##  desc          1.2.0   2018-05-01 [1] CRAN (R 3.5.1)
##  devtools      2.1.0   2019-07-06 [1] CRAN (R 3.5.3)
##  digest        0.6.20  2019-07-04 [1] CRAN (R 3.5.3)
##  dplyr       * 0.8.3   2019-07-04 [1] CRAN (R 3.5.3)
##  evaluate      0.14    2019-05-28 [1] CRAN (R 3.5.3)
##  fansi         0.4.0   2018-10-05 [1] CRAN (R 3.5.1)
##  fs            1.3.1   2019-05-06 [1] CRAN (R 3.5.3)
##  glue          1.3.1   2019-03-12 [1] CRAN (R 3.5.3)
##  highr         0.8     2019-03-20 [1] CRAN (R 3.5.3)
##  htmltools     0.3.6   2017-04-28 [1] CRAN (R 3.5.1)
##  httr        * 1.4.1   2019-08-05 [1] CRAN (R 3.5.3)
##  knitr         1.24    2019-08-08 [1] CRAN (R 3.5.3)
##  magrittr      1.5     2014-11-22 [1] CRAN (R 3.5.1)
##  memoise       1.1.0   2017-04-21 [1] CRAN (R 3.5.1)
##  pacman      * 0.5.1   2019-03-11 [1] CRAN (R 3.5.3)
##  pillar        1.4.2   2019-06-29 [1] CRAN (R 3.5.3)
##  pkgbuild      1.0.4   2019-08-05 [1] CRAN (R 3.5.3)
##  pkgconfig     2.0.2   2018-08-16 [1] CRAN (R 3.5.1)
##  pkgload       1.0.2   2018-10-29 [1] CRAN (R 3.5.1)
##  prettyunits   1.0.2   2015-07-13 [1] CRAN (R 3.5.1)
##  processx      3.4.1   2019-07-18 [1] CRAN (R 3.5.3)
##  ps            1.3.0   2018-12-21 [1] CRAN (R 3.5.2)
##  purrr         0.3.2   2019-03-15 [1] CRAN (R 3.5.3)
##  R6            2.4.0   2019-02-14 [1] CRAN (R 3.5.2)
##  Rcpp          1.0.2   2019-07-25 [1] CRAN (R 3.5.3)
##  readxl      * 1.3.1   2019-03-13 [1] CRAN (R 3.5.3)
##  remotes       2.1.0   2019-06-24 [1] CRAN (R 3.5.3)
##  rlang         0.4.0   2019-06-25 [1] CRAN (R 3.5.3)
##  rmarkdown     1.14    2019-07-12 [1] CRAN (R 3.5.3)
##  rprojroot     1.3-2   2018-01-03 [1] CRAN (R 3.5.1)
##  sessioninfo   1.1.1   2018-11-05 [1] CRAN (R 3.5.2)
##  stringi       1.4.3   2019-03-12 [1] CRAN (R 3.5.3)
##  stringr       1.4.0   2019-02-10 [1] CRAN (R 3.5.2)
##  testthat      2.2.1   2019-07-25 [1] CRAN (R 3.5.3)
##  tibble        2.1.3   2019-06-06 [1] CRAN (R 3.5.3)
##  tidyr       * 0.8.3   2019-03-01 [1] CRAN (R 3.5.3)
##  tidyselect    0.2.5   2018-10-11 [1] CRAN (R 3.5.1)
##  usethis       1.5.1   2019-07-04 [1] CRAN (R 3.5.3)
##  utf8          1.1.4   2018-05-24 [1] CRAN (R 3.5.1)
##  vctrs         0.2.0   2019-07-05 [1] CRAN (R 3.5.3)
##  withr         2.1.2   2018-03-15 [1] CRAN (R 3.5.1)
##  xfun          0.8     2019-06-25 [1] CRAN (R 3.5.3)
##  yaml          2.2.0   2018-07-25 [1] CRAN (R 3.5.1)
##  zeallot       0.1.0   2018-01-28 [1] CRAN (R 3.5.2)
## 
## [1] C:/Users/Italo/Documents/R/win-library/3.5
## [2] C:/Program Files/R/R-3.5.3/library&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;referencias&#34; class=&#34;section level1 unnumbered&#34;&gt;
&lt;h1&gt;Referências&lt;/h1&gt;
&lt;div id=&#34;refs&#34; class=&#34;references&#34;&gt;
&lt;div id=&#34;ref-cegatta_eficiencia_2013&#34;&gt;
&lt;p&gt;Cegatta, Italo Ramos, and Cristian Villegas. 2013. “Eficiência de dois inseticidas sistêmicos no controle de Leptocybe invasa em mudas de Eucalyptus camaldulensis.” &lt;em&gt;Revista Instituto Florestal&lt;/em&gt; 25 (2). &lt;a href=&#34;iflorestal.sp.gov.br/files/2014/05/RIF25-2{\_}215-221.pdf&#34;&gt;iflorestal.sp.gov.br/files/2014/05/RIF25-2{\_}215-221.pdf&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;ref-grolemund_r_2016&#34;&gt;
&lt;p&gt;Grolemund, Garrett, and Hadley Wickham. 2016. &lt;em&gt;R for Data Science&lt;/em&gt;. O’Reilly Media. &lt;a href=&#34;http://r4ds.had.co.nz/&#34;&gt;http://r4ds.had.co.nz/&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;ref-wickham_tidy_2014&#34;&gt;
&lt;p&gt;Wickham, Hadley. 2014. “Tidy data.” &lt;em&gt;The Journal of Statistical Software&lt;/em&gt; 59 (10). &lt;a href=&#34;http://www.jstatsoft.org/v59/i10/&#34;&gt;http://www.jstatsoft.org/v59/i10/&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

      </content:encoded>
    </item>
    
    <item>
      <title>O R é para você</title>
      <link>https://italocegatta.github.io/o-r-e-para-voce/</link>
      <pubDate>Tue, 26 Apr 2016 00:00:00 +0000</pubDate>
      
      <guid>https://italocegatta.github.io/o-r-e-para-voce/</guid>
      <description>Se dedicar para aprender uma nova linguagem de programação não é uma tarefa fácil. Principalmente para quem não tem um background de lógica de programação. Não me lembro de me perguntar se valeria a pena ou não estudar o R. Eu estava tão entusiasmado com toda aquela situação de gráficos, tabelas e estatísticas que, quando vi, já tinha passado algumas madrugadas programando.
Vou tentar focar esse texto em duas perguntas muito importantes para quem está chegando agora na comunidade R: será que vale a pena aprender a programar em R?</description>
      <content:encoded>
        


&lt;p&gt;Se dedicar para aprender uma nova linguagem de programação não é uma tarefa fácil. Principalmente para quem não tem um background de lógica de programação. Não me lembro de me perguntar se valeria a pena ou não estudar o R. Eu estava tão entusiasmado com toda aquela situação de gráficos, tabelas e estatísticas que, quando vi, já tinha passado algumas madrugadas programando.&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;Vou tentar focar esse texto em duas perguntas muito importantes para quem está chegando agora na comunidade R: será que vale a pena aprender a programar em R? Se sim, por
onde posso começar?&lt;/p&gt;
&lt;div id=&#34;sobre-o-r&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Sobre o R&lt;/h2&gt;
&lt;p&gt;O R é um software open-source mantido por um grupo de voluntários de vários países, o R-core team. No site oficial do &lt;a href=&#34;https://www.r-project.org/&#34;&gt;projeto&lt;/a&gt; &lt;span class=&#34;citation&#34;&gt;(R Core Team &lt;a href=&#34;#ref-r_development_core_team_r:_2016&#34;&gt;2016&lt;/a&gt;)&lt;/span&gt; a primeira descrição sobre ele é a seguinte:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;O R é uma linguagem e ambiente para computação estatística e gráficos.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Esse grupo mantem o sistema base que possibilita a interação com a linguagem R para computação numérica, manipulação de dados, gráficos e uma variedade de outras tarefas. No R, tudo o que acontece é o resultado de uma função. Eu, você e tantos outros usuários podemos desenvolver funções para facilitar a nossa vida, posteriormente organizá-las em pacotes (ou &lt;em&gt;packages&lt;/em&gt;) e depois disponibilizar para todo o mundo &lt;span class=&#34;citation&#34;&gt;(Chambers &lt;a href=&#34;#ref-chambers_software_2008&#34;&gt;2008&lt;/a&gt;)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;O projeto do R teve início com Ross Ihaka e Robert Gentleman nos anos 90 a partir de uma implementação da linguagem S, que foi desenvolvida anos antes por um grupo de pesquisadores liderados por John Chambers no Bell Laboratories &lt;span class=&#34;citation&#34;&gt;(Chambers &lt;a href=&#34;#ref-chambers_software_2008&#34;&gt;2008&lt;/a&gt;)&lt;/span&gt;. Desde então, o R tem crescido em um ritmo absurdo e pode ser considerado o principal software livre para programação estatística e um dos mais usados no mundo &lt;span class=&#34;citation&#34;&gt;(Revolution Analitics &lt;a href=&#34;#ref-revolution_analitics_rs_2016&#34;&gt;2016&lt;/a&gt;; Docsity &lt;a href=&#34;#ref-docsity_statistical_2014&#34;&gt;2014&lt;/a&gt;)&lt;/span&gt;. Não vou listar todas potencialidades do R aqui neste post, em primeiro lugar por que eu não domino todas elas e segundo por que com certeza o post ficaria muito grande. Com o tempo vou apresentar nos posts algumas aplicações pontuais do R com relação aos problemas que precisei resolver. Mas já adianto, é comum dizermos que a pergunta certa sobre uma tarefa no R não é &lt;em&gt;se podemos fazer&lt;/em&gt;, mas sim &lt;em&gt;como&lt;/em&gt; podemos fazer.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;o-r-e-para-mim&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;O R é para mim?&lt;/h2&gt;
&lt;p&gt;O R tem uma curva de aprendizado um tanto íngreme, no começo é realmente muito frustrante. Uma vez, me lembro de passar horas para conseguir deixar a legenda com as cores que eu queria. Dá vontade de largar tudo e fazer o gráfico no Excel. Mas se você é um pouco persistente no começo e encara como um desafio, as coisas melhoram e essa etapa logo passa.&lt;/p&gt;
&lt;p&gt;Minha formação é em Eng. Florestal, na grade curricular do meu curso não há nada relacionado à lógica e conceitos de programação, ou seja, tive que me motivar muito para aprender a programar. Para mim, abstrair a lógica de um código ou rotina em R não foi (e nem é) fácil. De fato, não é todo mundo que sabe programar e nem por isso se torna um mal profissional, pois há vários softwares que possuem uma interface gráfica totalmente adaptada para o usuário em forma de botões e cliques. Mas com muita certeza, os profissionais que podem programar têm um horizonte de possibilidades muito maior devido a flexibilidade de poder escrever seu próprio programa de processamento.&lt;/p&gt;
&lt;p&gt;Costumo dizer para os meus amigos que o grande trunfo de um programador é a preguiça. Eu particularmente sou bem preguiçoso quando tenho de fazer atividades repetitivas. A Figura &lt;a href=&#34;#fig:geek-task&#34;&gt;1&lt;/a&gt; ilustra bem uma situação que já ocorreu comigo muitas vezes, onde meus amigos faziam processos repetitivos usando o Excel, enquanto eu só conseguia pensar em como fazer aquilo de uma forma rápida e eficiente no R.&lt;/p&gt;
&lt;div class=&#34;figure&#34;&gt;&lt;span id=&#34;fig:geek-task&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;http://i.imgur.com/e8otnTl.png&#34; alt=&#34;Programadores versus não-programadores quando fazem tarefas repetitivas [@iwaya_geeks_2012].&#34;  /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figura  1: Programadores versus não-programadores quando fazem tarefas repetitivas &lt;span class=&#34;citation&#34;&gt;(Iwaya &lt;a href=&#34;#ref-iwaya_geeks_2012&#34;&gt;2012&lt;/a&gt;)&lt;/span&gt;.
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Se você está na dúvida e é daqueles que preferem respostas rápidas, meu professor de biometria pode te ajudar nesse sentido &lt;span class=&#34;citation&#34;&gt;(Batista &lt;a href=&#34;#ref-batista_curso_2015&#34;&gt;2015&lt;/a&gt;)&lt;/span&gt;, com estas afirmações:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Você não quer aprender uma linguagem e realizar análises utilizando comandos.&lt;/li&gt;
&lt;li&gt;Você acredita que análise estatística é um simples protocolo para obter alguns resultados numéricos.&lt;/li&gt;
&lt;li&gt;Você acredita que para cada situação ou conjunto de dados existe &lt;em&gt;a análise&lt;/em&gt; estatística correta.&lt;/li&gt;
&lt;li&gt;Você não sabe o que é análise estatística baseada em modelos e não está nenhum pouco interessado em saber.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Se você concorda com essas afirmações, pense bem antes de dedicar seu tempo nesse caminho. Continue no Excel eu em outro programa amigável e seja feliz. Mas se você já programa em alguma linguagem, ou tem uma certa facilidade para isso, a situação é outra. Veja quais benefícios o R tem em relação ao seu atual software e avalie se essa empreitada vale a pena.&lt;/p&gt;
&lt;p&gt;No meu caso, o SAS resolve a maioria dos problemas relacionados ao processamento de dados e análise estatística de um florestal. Então, a decisão nesse sentido tem que ser bem pontual e depende essencialmente das tarefas que você realiza. Para mim, o R sai na frente por ser uma linguagem livre e com um grupo de desenvolvedores muito grande, o que possibilita a criação de diversas funcionalidades de vanguarda. Outro trunfo do R é a integração com outros softwares e linguagens, que nos possibilita criar aplicações web e em servidores.&lt;/p&gt;
&lt;p&gt;Para fechar o tópico, se as suas tarefas estão relacionadas à análise e processamento de dados e você sente que perde um tempo em atividades repetitivas, talvez seja preciso rever o método. Programando você fará as coisas de forma rápida, considere isso como um investimento a longo prazo.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;por-onde-eu-comeco&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Por onde eu começo?&lt;/h2&gt;
&lt;p&gt;A parte boa de um software livre é que a comunidade que trabalha com ele normalmente disponibiliza seus produtos e projetos gratuitamente. Se você chegou nesse post por que está interessado no R mas não sabe nada ou muito pouco, vou listar algumas dicas que me ajudaram e ainda me ajudam quando preciso fazer algo no R.&lt;/p&gt;
&lt;div id=&#34;comece-vendo-e-ouvindo&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;1. Comece vendo e ouvindo&lt;/h3&gt;
&lt;p&gt;Para quem está começando, é melhor ver e ouvir como as coisas funcionam. Eu particularmente só entendi o jeitão do R quando meu orientador de iniciação científica me explicou. Então segue algumas dicas:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.udemy.com/computacao_r/&#34;&gt;Computação em R - Udemy.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.datacamp.com/courses/free-introduction-to-r&#34;&gt;Introduction to R - DataCamp.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://pt.coursera.org/learn/r-programming/&#34;&gt;R Programming - Coursera.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=cX532N_XLIs&amp;amp;list=PLqzoL9-eJTNBDdKgJgJzaQcY6OXmsXAHU&#34;&gt;Vídeo aulas no Youtube.&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div id=&#34;sites-interessantes&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;2. Sites interessantes&lt;/h3&gt;
&lt;p&gt;Existe uma infinidade de sites e blogs dedicados a te ensinar a programar em R. Mas a maioria espera que você já tenha uma mínima noção de como a linguagem funciona. Com certeza você vai precisar acessar um desses links para resolver algo com o R. Esses são alguns dos links que eu tenho salvo na minha pasta de favoritos no navegador.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.rstudio.com/online-learning/&#34;&gt;RStudio.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.r-tutor.com/%22%20target=%22_blank&#34;&gt;R tutor.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.statmethods.net/&#34;&gt;Quick R.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://rstatistics.net/&#34;&gt;R Statistics.net.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.r-bloggers.com/&#34;&gt;R-bloggers.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://stackoverflow.com/tags/r&#34;&gt;Stackoverflow.&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div id=&#34;livros-e-apostilas&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;3. Livros e apostilas&lt;/h3&gt;
&lt;p&gt;No começo, eu acabei juntando uma pasta com muitos livros e apostilas do R. Uns foram úteis outros não. Meu conselho é que você escolha 3 livros para estudar de verdade. Depois disso os livros vão servir apenas para consultas de questões muito específicas. Segue algumas sugestões de livros e apostilas disponíveis gratuitamente na web.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.cookbook-r.com/&#34;&gt;Cookbook for R.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://r4ds.had.co.nz/&#34;&gt;R for Data Science.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.leg.ufpr.br/~paulojus/&#34;&gt;Apostilas do Prof. Paulo Justiniano, foco em estatística.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://cmq.esalq.usp.br/wiki/doku.php?id=publico:tutoriais:start&#34;&gt;Apostila do Prof. João Batista, foco em inventário florestal.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://cran.r-project.org/doc/contrib/Beasley-BioestatisticaUsandoR.pd&#34;&gt;Apostila do Prof. Colin Beasley, foco em biologia.&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div id=&#34;ambiente-de-desenvolvimento&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;4. Ambiente de desenvolvimento&lt;/h3&gt;
&lt;p&gt;A interface gráfica do R é bem simples. Acostume-se, isso não mudar. Mas felizmente muitas empresas desenvolveram ambientes de desenvolvimento integrado para facilitar a vida do usuário. Nesse sentido, eu recomendo fortemente utilizar o &lt;a href=&#34;https://www.rstudio.com/&#34;&gt;RStudio&lt;/a&gt; como ambiente de programação. O RStudio tem uma das equipes mais atuantes da comunidade R e a cada dia que passa estão tornando a programação mais eficiente e prazerosa.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;referencias&#34; class=&#34;section level2 unnumbered&#34;&gt;
&lt;h2&gt;Referências&lt;/h2&gt;
&lt;div id=&#34;refs&#34; class=&#34;references&#34;&gt;
&lt;div id=&#34;ref-batista_curso_2015&#34;&gt;
&lt;p&gt;Batista, João. 2015. “Curso Relâmpago de R.” &lt;a href=&#34;http://cmq.esalq.usp.br/wiki/doku.php?id=publico:tutoriais:r-relampago:start&#34;&gt;http://cmq.esalq.usp.br/wiki/doku.php?id=publico:tutoriais:r-relampago:start&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;ref-chambers_software_2008&#34;&gt;
&lt;p&gt;Chambers, John. 2008. &lt;em&gt;Software for Data Analysis&lt;/em&gt;. Statistics and Computing. New York, NY: Springer New York. &lt;a href=&#34;http://link.springer.com/10.1007/978-0-387-75936-4&#34;&gt;http://link.springer.com/10.1007/978-0-387-75936-4&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;ref-docsity_statistical_2014&#34;&gt;
&lt;p&gt;Docsity. 2014. “Statistical Language Wars: Comparison among SAS, R and SPSS.” &lt;a href=&#34;http://www.docsity.com/en/news/programming-2/statistical-language-wars-comparison-sas-spss/&#34;&gt;http://www.docsity.com/en/news/programming-2/statistical-language-wars-comparison-sas-spss/&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;ref-iwaya_geeks_2012&#34;&gt;
&lt;p&gt;Iwaya, Akemi. 2012. “Geeks versus Non-Geeks when Doing Repetitive Tasks [Funny Chart].” &lt;a href=&#34;http://www.howtogeek.com/102420/geeks-versus-non-geeks-when-doing-repetitive-tasks-funny-chart/&#34;&gt;http://www.howtogeek.com/102420/geeks-versus-non-geeks-when-doing-repetitive-tasks-funny-chart/&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;ref-r_development_core_team_r:_2016&#34;&gt;
&lt;p&gt;R Core Team. 2016. “R: A Language and Environment for Statistical Computing.” &lt;em&gt;R Foundation for Statistical Computing&lt;/em&gt; 3.3.0. &lt;a href=&#34;http://www.r-project.org&#34;&gt;http://www.r-project.org&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;ref-revolution_analitics_rs_2016&#34;&gt;
&lt;p&gt;Revolution Analitics. 2016. “R’s popularity.” &lt;a href=&#34;http://blog.revolutionanalytics.com/popularity&#34;&gt;http://blog.revolutionanalytics.com/popularity&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

      </content:encoded>
    </item>
    
    <item>
      <title>Sobre esse blog</title>
      <link>https://italocegatta.github.io/sobre-esse-blog/</link>
      <pubDate>Thu, 21 Apr 2016 00:00:00 +0000</pubDate>
      
      <guid>https://italocegatta.github.io/sobre-esse-blog/</guid>
      <description>Algumas situações me motivaram a criar esse site e alimentá-lo como um blog. Provavelmente os motivos para que eu o continue atualizando vão mudar e na medida que isso acontecer, atualizarei esse post.
Quando este blog começou, eu estava em um intercâmbio na Universidade de Lisboa e aproveitando para iniciar o desenvolvimento do meu Trabalho de Conclusão de Curso. A proposta do TCC foi construir um pacote no R para cálculo de índices de competição de árvores individuais.</description>
      <content:encoded>
        


&lt;p&gt;Algumas situações me motivaram a criar esse site e alimentá-lo como um blog. Provavelmente os motivos para que eu o continue atualizando vão mudar e na medida que isso acontecer, atualizarei esse post.&lt;/p&gt;
&lt;p&gt;Quando este blog começou, eu estava em um intercâmbio na Universidade de Lisboa e aproveitando para iniciar o desenvolvimento do meu Trabalho de Conclusão de Curso. A proposta do TCC foi construir um pacote no R para cálculo de índices de competição de árvores individuais. Para um florestal essa não é uma tarefa fácil, pois meu curso não tem relação com tecnologia da informações ou ciência da computação.&lt;/p&gt;
&lt;p&gt;Tive a ideia de criar o blog numa terça-feira, na quarta ele já estava online. As principais motivações foram:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Eu acumulei durante os anos da graduação muitos códigos em R para resolver problemas meus e de amigos, entretanto a maioria desses códigos estavam desorganizados. Sempre que começo um novo projeto no R eu me lembro que já fiz algo parecido anteriormente, mas ou não consigo encontrar o código ou ele está tão bagunçado que não é possível aproveitá-lo. Pretendo organizar todos os meus códigos em forma de posts para facilitar a minha vida no futuro.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Organizar as ideias no papel nunca foi o meu forte. Penso que o hábito de escrever e estruturar um post sobre problemas resolvidos com o R vai ser um exercício e tanto para melhorar esse ponto.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Eu sempre quis programar com o R Markdown. Escrever os posts no R com o RStudio vão me ajudar a adquirir experiencia com essa linguagem.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Eu já havia criado alguns sites no Wix e DokuWiki, mas queira conhecer outras plataformas. Comecei o blog no Wordpress.com, mas a publicação de códigos é muito limitada e não pode ser automatizada. Com Hugo, Blogdown e Github Pages eu consigo editar e publicar os posts diretamente do R, sem muito esforço e com muita flexibilidade.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;E por último, mas não menos importante, espero que os posts possam ajudar as pessoas a resolverem problemas parecidos. Durante todo o tempo em que trabalho com o R (e tantos outros assuntos do dia a dia) preciso recorrer a fóruns e blogs para conseguir avançar. Nesse sentido, tentar ajudar os outros que estão com problemas semelhantes aos que eu tive no passado é o mínimo que posso fazer em respeito à todos aqueles que, anonimamente, me ajudaram.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Um forte abraço a todos e vamos aos posts sobre o R, Floresta e Data Science.&lt;/p&gt;

      </content:encoded>
    </item>
    
  </channel>
</rss>
