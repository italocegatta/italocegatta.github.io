<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Ítalo Cegatta</title>
    <link>/post/index.xml</link>
    <description>Recent content in Posts on Ítalo Cegatta</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>pt-br</language>
    <lastBuildDate>Sat, 29 Jul 2017 00:00:00 +0000</lastBuildDate>
    <atom:link href="/post/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Como um cientista de dados pesquisa o carro que quer comprar?</title>
      <link>/como-um-cientista-de-dados-pesquisa-o-carro-que-quer-comprar/</link>
      <pubDate>Sat, 29 Jul 2017 00:00:00 +0000</pubDate>
      
      <guid>/como-um-cientista-de-dados-pesquisa-o-carro-que-quer-comprar/</guid>
      <description>&lt;p&gt;Estou naquela parte da vida em que se planeja comprar um carro. Como eu sou, acima de todos os sonhos, pão duro, decidir qual marca, modelo, versão e ano do veículo não vai ser fácil. Pensando nisso resolvi escrever um pacote no R para me ajudar a tomar esta decisão. O objetivo deste post é apresentar o pacote e as funções que auxiliam na coleta das informações da tabela &lt;a href=&#34;http://veiculos.fipe.org.br/&#34;&gt;FIPE&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Para aqueles que já passaram pela etapa de compra ou venda de um carro, provavelmente já consultaram a famosa tabela. Nas palavras do próprio site da FIPE:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A Tabela Fipe expressa preços médios de veículos no mercado nacional, servindo apenas como um parâmetro para negociações ou avaliações. Os preços efetivamente praticados variam em função da região, conservação, cor, acessórios ou qualquer outro fator que possa influenciar as condições de oferta e procura por um veículo específico.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;A motivação para este pacote foi exclusivamente pessoal e por isso a utilização das funções está bastante restrita. Por isso, se alguém quiser ajudar no desenvolvimento do pacote é só chegar e mandar um &lt;a href=&#34;https://github.com/italocegatta/fipe&#34;&gt;Pull Request&lt;/a&gt; no Github, contribuições serão muito bem vindas.&lt;/p&gt;
&lt;p&gt;Primeiro vou mostrar as funções e o workflow idealizado para o pacote. Queremos saber, por enquanto, o preço atual de uma BMW X6 M ano 2015. O primeiro passo é definir o mês de referência que se deseja consultar o preço do veículo. A FIPE disponibiliza os valores consolidados desde janeiro de 2001.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;if (!require(&amp;quot;pacman&amp;quot;)) install.packages(&amp;quot;pacman&amp;quot;)
pacman::p_load(dplyr, purrr, stringr, tidyr, forcats, ggplot2)
pacman::p_load_gh(&amp;quot;italocegatta/fipe&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;fipe_referencia()&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 199 x 2
##      data_ref cod_ref
##        &amp;lt;date&amp;gt;   &amp;lt;int&amp;gt;
##  1 2017-07-01     215
##  2 2017-06-01     214
##  3 2017-05-01     212
##  4 2017-04-01     211
##  5 2017-03-01     207
##  6 2017-02-01     205
##  7 2017-01-01     202
##  8 2016-12-01     200
##  9 2016-11-01     198
## 10 2016-10-01     197
## # ... with 189 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Como o objetivo saber o preço atual do veículo, pegaremos o código &lt;code&gt;215&lt;/code&gt; (mês em que escrevo este post). Agora vamos procurar o código da marca BMW. Note que precisamos inserir o código do mês de referência para consultar a marca, essa é uma exigência do site da FIPE. Lembrando que o pacote não possui nenhum banco de dados armazenado, todas as informações são consultadas no site da tabela FIPE no ato da execução da função.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;fipe_marca(cod_ref = 215)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 87 x 2
##           marca cod_marca
##           &amp;lt;chr&amp;gt;     &amp;lt;int&amp;gt;
##  1        Acura         1
##  2       Agrale         2
##  3   Alfa Romeo         3
##  4       AM Gen         4
##  5  Asia Motors         5
##  6 ASTON MARTIN       189
##  7         Audi         6
##  8          BMW         7
##  9          BRM         8
## 10        Buggy         9
## # ... with 77 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Por sorte, o código &lt;code&gt;7&lt;/code&gt; da BMW aparece logo nos primeiros valores por ordem alfabética. Podemos seguir para o próximo passo e pegar o código do modelo que queremos. A consulta a baixo mostras que a BMW tem 221 modelos cadastrados na tabela FIPE. Como já definimos o modelo que queremos, vamos filtrar do dataframe para enxergar o código do modelo.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;(bmw &amp;lt;- fipe_modelo(cod_ref = 215, cod_marca = 7))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 221 x 2
##                                    modelo cod_modelo
##                                     &amp;lt;chr&amp;gt;      &amp;lt;int&amp;gt;
##  1              116iA 1.6 TB 16V 136cv 5p       6146
##  2                 118iA 2.0 16V 136cv 3p       5576
##  3                 118iA 2.0 16V 136cv 5p       4960
##  4         118iA Full 1.6 TB 16V 170cv 5p       6147
##  5 118iA/ Urban/Sport 1.6 TB 16V 170cv 5p       5923
##  6           120i 2.0 16V 150cv/ 156cv 5p        152
##  7          120iA 2.0 16V 150cv/ 156cv 5p        153
##  8                 120iA 2.0 16V 156cv 3p       4700
##  9          120iA Cabrio 2.0 16V 156cv 2p       4683
## 10    120iA Sport 2.0 ActiveFlex 16V Aut.       7178
## # ... with 211 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;filter(bmw, str_detect(modelo, &amp;quot;X6 M&amp;quot;))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 1 x 2
##                              modelo cod_modelo
##                               &amp;lt;chr&amp;gt;      &amp;lt;int&amp;gt;
## 1 X6 M 4.4 4x4 V8 32V Bi-Turbo Aut.       5189&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Pronto, agora já sabemos que o código que a FIPE dá para o modelo X6 M é o &lt;code&gt;5189&lt;/code&gt;. Teríamos tudo pronto, se não fosse o padrão que a FIPE adota no campo&lt;code&gt;ano&lt;/code&gt;, onde o ano do modelo é acrescido de um código de combustível. A diferenciação para os “0 km” é feita na mesma coluna, utilizando a identificação 32000-*. Enfim, contornando as falhas estruturais no banco de dados deles, agora sabemos os códigos que identificam o ano do modelo, bem como o carro 0 km. Como eu optei por procurar o valor do carro 2015, iremos considerar o código &lt;code&gt;2015-1&lt;/code&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;fipe_ano(cod_ref = 215, cod_marca = 7, cod_modelo = 5189)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 9 x 2
##     ano cod_ano
##   &amp;lt;chr&amp;gt;   &amp;lt;chr&amp;gt;
## 1  0 km 32000-1
## 2  2017  2017-1
## 3  2016  2016-1
## 4  2015  2015-1
## 5  2014  2014-1
## 6  2013  2013-1
## 7  2012  2012-1
## 8  2011  2011-1
## 9  2010  2010-1&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Agora sim vamos ao bendito preço da BMW!&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;fipe(cod_ref = 215, cod_marca = 7, cod_modelo = 5189, cod_ano = &amp;quot;2015-1&amp;quot;) %&amp;gt;% 
  glimpse()&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Observations: 1
## Variables: 7
## $ cod_fipe    &amp;lt;chr&amp;gt; &amp;quot;009144-8&amp;quot;
## $ ref         &amp;lt;date&amp;gt; 2017-07-01
## $ marca       &amp;lt;chr&amp;gt; &amp;quot;BMW&amp;quot;
## $ modelo      &amp;lt;chr&amp;gt; &amp;quot;X6 M 4.4 4x4 V8 32V Bi-Turbo Aut.&amp;quot;
## $ ano         &amp;lt;chr&amp;gt; &amp;quot;2015&amp;quot;
## $ combustivel &amp;lt;chr&amp;gt; &amp;quot;Gasolina&amp;quot;
## $ valor       &amp;lt;dbl&amp;gt; 368603&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Achamos o preço do carro que eu queria. Apenas R$ 368 mil. Uma pechincha. Obviamente, saber quanto vale uma BMW X6 não faz diferênça alguma no meu dia. Um abraço pra quem tem condições de comprar um carro desse sem precisar vender um rim.&lt;/p&gt;
&lt;p&gt;Agora que já conhecemos as funções e o fluxo para consultar o valor dos carros, vamos ampliar a consulta e justificar as horas que passamos aprendendo a programar. Já sabemos o preço do X6 M em julho/2017, mas e nos meses anteriores? Como será que foi a depreciação média do carro usado nos últimos meses? E os outros modelos X6, quanto será que estão valendo?&lt;/p&gt;
&lt;p&gt;Digamos que, agora, estas questões podem ser respondidas de forma bem rápida. Eu mostro.&lt;/p&gt;
&lt;p&gt;Vamos retomar os passos, mas agora no nível hard. Vou analisar o comportamento dos preços desde 2009. Para deixar a consulta mais rápida, serão considerados apenas 3 meses de referência por ano.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;(base_marca &amp;lt;- fipe_referencia() %&amp;gt;%
  filter(data_ref %in% seq.Date(as.Date(&amp;quot;2009-01-01&amp;quot;), as.Date(&amp;quot;2017-07-01&amp;quot;), by = &amp;quot;4 months&amp;quot;)) %&amp;gt;%
  mutate(marca = map(cod_ref, fipe_marca)) %&amp;gt;%
  unnest() %&amp;gt;% 
  filter(marca == &amp;quot;BMW&amp;quot;)
)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 26 x 4
##      data_ref cod_ref marca cod_marca
##        &amp;lt;date&amp;gt;   &amp;lt;int&amp;gt; &amp;lt;chr&amp;gt;     &amp;lt;int&amp;gt;
##  1 2017-05-01     212   BMW         7
##  2 2017-01-01     202   BMW         7
##  3 2016-09-01     196   BMW         7
##  4 2016-05-01     191   BMW         7
##  5 2016-01-01     187   BMW         7
##  6 2015-09-01     183   BMW         7
##  7 2015-05-01     179   BMW         7
##  8 2015-01-01     174   BMW         7
##  9 2014-09-01     170   BMW         7
## 10 2014-05-01     166   BMW         7
## # ... with 16 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Notem que agora temos um dataframe com códigos de referência entre janeiro/2008 a maio/2017. Seguindo a análise, precisamos encontrar os códigos dos modelos X6.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;(base_modelo &amp;lt;- mutate(base_marca, modelo = map2(cod_ref, cod_marca, fipe_modelo)) %&amp;gt;%
  unnest() %&amp;gt;% 
  filter(str_detect(modelo, &amp;quot;X6&amp;quot;))
)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 82 x 6
##      data_ref cod_ref marca cod_marca                             modelo
##        &amp;lt;date&amp;gt;   &amp;lt;int&amp;gt; &amp;lt;chr&amp;gt;     &amp;lt;int&amp;gt;                              &amp;lt;chr&amp;gt;
##  1 2017-05-01     212   BMW         7  X6 M 4.4 4x4 V8 32V Bi-Turbo Aut.
##  2 2017-05-01     212   BMW         7   X6 XDRIVE 35i 3.0 306cv Bi-Turbo
##  3 2017-05-01     212   BMW         7   X6 XDRIVE 50i 4.4 407cv Bi-Turbo
##  4 2017-05-01     212   BMW         7 X6 XDRIVE 50i M Sport 4.4 Bi-Turbo
##  5 2017-01-01     202   BMW         7  X6 M 4.4 4x4 V8 32V Bi-Turbo Aut.
##  6 2017-01-01     202   BMW         7   X6 XDRIVE 35i 3.0 306cv Bi-Turbo
##  7 2017-01-01     202   BMW         7   X6 XDRIVE 50i 4.4 407cv Bi-Turbo
##  8 2017-01-01     202   BMW         7 X6 XDRIVE 50i M Sport 4.4 Bi-Turbo
##  9 2016-09-01     196   BMW         7  X6 M 4.4 4x4 V8 32V Bi-Turbo Aut.
## 10 2016-09-01     196   BMW         7   X6 XDRIVE 35i 3.0 306cv Bi-Turbo
## # ... with 72 more rows, and 1 more variables: cod_modelo &amp;lt;int&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;O próximo passo é pegar, para cada versão, os diferentes anos de fabricação do carro. A função vai consultar os anos de fabricação que a FIPE consolidou para cada uma das 82 linhas (combinação entre modelo e mês de referência).&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;(base_consulta &amp;lt;- mutate(base_modelo, ano = pmap(list(cod_ref, cod_marca, cod_modelo), fipe_ano)) %&amp;gt;%
  unnest()
)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 480 x 8
##      data_ref cod_ref marca cod_marca                            modelo
##        &amp;lt;date&amp;gt;   &amp;lt;int&amp;gt; &amp;lt;chr&amp;gt;     &amp;lt;int&amp;gt;                             &amp;lt;chr&amp;gt;
##  1 2017-05-01     212   BMW         7 X6 M 4.4 4x4 V8 32V Bi-Turbo Aut.
##  2 2017-05-01     212   BMW         7 X6 M 4.4 4x4 V8 32V Bi-Turbo Aut.
##  3 2017-05-01     212   BMW         7 X6 M 4.4 4x4 V8 32V Bi-Turbo Aut.
##  4 2017-05-01     212   BMW         7 X6 M 4.4 4x4 V8 32V Bi-Turbo Aut.
##  5 2017-05-01     212   BMW         7 X6 M 4.4 4x4 V8 32V Bi-Turbo Aut.
##  6 2017-05-01     212   BMW         7 X6 M 4.4 4x4 V8 32V Bi-Turbo Aut.
##  7 2017-05-01     212   BMW         7 X6 M 4.4 4x4 V8 32V Bi-Turbo Aut.
##  8 2017-05-01     212   BMW         7 X6 M 4.4 4x4 V8 32V Bi-Turbo Aut.
##  9 2017-05-01     212   BMW         7 X6 M 4.4 4x4 V8 32V Bi-Turbo Aut.
## 10 2017-05-01     212   BMW         7  X6 XDRIVE 35i 3.0 306cv Bi-Turbo
## # ... with 470 more rows, and 3 more variables: cod_modelo &amp;lt;int&amp;gt;,
## #   ano &amp;lt;chr&amp;gt;, cod_ano &amp;lt;chr&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Se na sua internet a função anterior demorou, prepara que a próxima vai demorar um tanto mais. Temos 480 requisições para fazer no site da FIPE em busca dos preços que queremos.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;(consulta &amp;lt;- mutate(
  base_consulta, 
  consulta = pmap(list(cod_ref, cod_marca, cod_modelo, cod_ano), fipe)
  )  %&amp;gt;%
  select(consulta) %&amp;gt;% 
  unnest() %&amp;gt;% 
  select(ref, modelo, ano, valor)
)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 480 x 4
##           ref                            modelo   ano  valor
##        &amp;lt;date&amp;gt;                             &amp;lt;chr&amp;gt; &amp;lt;chr&amp;gt;  &amp;lt;dbl&amp;gt;
##  1 2017-05-01 X6 M 4.4 4x4 V8 32V Bi-Turbo Aut.  0 km 644550
##  2 2017-05-01 X6 M 4.4 4x4 V8 32V Bi-Turbo Aut.  2017 520193
##  3 2017-05-01 X6 M 4.4 4x4 V8 32V Bi-Turbo Aut.  2016 475803
##  4 2017-05-01 X6 M 4.4 4x4 V8 32V Bi-Turbo Aut.  2015 365088
##  5 2017-05-01 X6 M 4.4 4x4 V8 32V Bi-Turbo Aut.  2014 317505
##  6 2017-05-01 X6 M 4.4 4x4 V8 32V Bi-Turbo Aut.  2013 291749
##  7 2017-05-01 X6 M 4.4 4x4 V8 32V Bi-Turbo Aut.  2012 231191
##  8 2017-05-01 X6 M 4.4 4x4 V8 32V Bi-Turbo Aut.  2011 204481
##  9 2017-05-01 X6 M 4.4 4x4 V8 32V Bi-Turbo Aut.  2010 193629
## 10 2017-05-01  X6 XDRIVE 35i 3.0 306cv Bi-Turbo  0 km 415744
## # ... with 470 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Depois de 4 passos, temos o banco de dados desejado. Imagina coletar estes dados, na mão, pelo site oficial!&lt;/p&gt;
&lt;p&gt;Bom agora o pacote está apresentado. Pretendo fazer outros posts com estudos de casos mais específicos, portanto vou deixar apenas um gráfico que resume a consulta que acabamos de fazer.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;consulta %&amp;gt;%
  mutate(ano = fct_relevel(ano, &amp;quot;0 km&amp;quot;, after = Inf)) %&amp;gt;% 
  ggplot(aes(ref, valor, color =  ano, group = ano)) +
    geom_line(color = &amp;quot;grey30&amp;quot;) +
    geom_point(size = 3) +
    facet_wrap(~modelo) +
    labs(
      x = &amp;quot;Mês de refêrencia&amp;quot;,
      y = &amp;quot;Valor (R$)&amp;quot;,
      color = &amp;quot;Ano do \nmodelo&amp;quot;
    ) +
    scale_y_continuous(breaks = seq(0, 700000, 50000), labels = scales::dollar_format(prefix = NULL, big.mark = &amp;quot;.&amp;quot;)) +
    scale_x_date(date_breaks = &amp;quot;1 year&amp;quot;, date_labels = &amp;quot;%b/%y&amp;quot;) +
    scale_color_viridis_d() +
    theme_bw() +
    theme(legend.position = &amp;quot;top&amp;quot;) &lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2017-07-29-como-um-cientista-de-dados-pesquisa-o-carro-que-quer-comprar_files/figure-html/plot_fipe-1.png&#34; width=&#34;4800&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Caso tenha alguma dúvida ou sugestão sobre o post, fique à vontade para fazer um comentário ou me contactar por Email.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;devtools::session_info()&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  setting  value                       
##  version  R version 3.3.3 (2017-03-06)
##  system   x86_64, mingw32             
##  ui       RTerm                       
##  language (EN)                        
##  collate  Portuguese_Brazil.1252      
##  tz       America/Sao_Paulo           
##  date     2017-07-29                  
## 
##  package     * version    date       source                            
##  assertthat    0.2.0      2017-04-11 CRAN (R 3.3.3)                    
##  backports     1.1.0      2017-05-22 CRAN (R 3.3.3)                    
##  base        * 3.3.3      2017-03-06 local                             
##  bindr         0.1        2016-11-13 CRAN (R 3.3.3)                    
##  bindrcpp    * 0.2        2017-06-17 CRAN (R 3.3.3)                    
##  blogdown      0.0.25     2017-03-23 Github (rstudio/blogdown@1c10d16) 
##  bookdown      0.4        2017-05-20 CRAN (R 3.3.3)                    
##  colorspace    1.3-2      2016-12-14 CRAN (R 3.3.2)                    
##  curl          2.8.1      2017-07-21 CRAN (R 3.3.3)                    
##  datasets    * 3.3.3      2017-03-06 local                             
##  devtools      1.13.2     2017-06-02 CRAN (R 3.3.3)                    
##  digest        0.6.12     2017-01-27 CRAN (R 3.3.2)                    
##  dplyr       * 0.7.2      2017-07-20 CRAN (R 3.3.3)                    
##  evaluate      0.10.1     2017-06-24 CRAN (R 3.3.3)                    
##  fipe        * 0.0.0.9000 2017-07-29 local                             
##  forcats     * 0.2.0      2017-01-23 CRAN (R 3.3.2)                    
##  ggplot2     * 2.2.1.9000 2017-07-15 Github (tidyverse/ggplot2@45853c7)
##  glue          1.1.1      2017-06-21 CRAN (R 3.3.3)                    
##  graphics    * 3.3.3      2017-03-06 local                             
##  grDevices   * 3.3.3      2017-03-06 local                             
##  grid          3.3.3      2017-03-06 local                             
##  gtable        0.2.0      2016-02-26 CRAN (R 3.3.2)                    
##  hms           0.3        2016-11-22 CRAN (R 3.3.2)                    
##  htmltools     0.3.6      2017-04-28 CRAN (R 3.3.3)                    
##  httr          1.2.1      2016-07-03 CRAN (R 3.3.2)                    
##  jsonlite      1.5        2017-06-01 CRAN (R 3.3.3)                    
##  knitr         1.16       2017-05-18 CRAN (R 3.3.3)                    
##  lazyeval      0.2.0      2016-06-12 CRAN (R 3.3.2)                    
##  lubridate     1.6.0      2016-09-13 CRAN (R 3.3.2)                    
##  magrittr      1.5        2014-11-22 CRAN (R 3.3.2)                    
##  memoise       1.1.0      2017-04-21 CRAN (R 3.3.3)                    
##  methods       3.3.3      2017-03-06 local                             
##  munsell       0.4.3      2016-02-13 CRAN (R 3.3.2)                    
##  pacman      * 0.4.6      2017-05-14 CRAN (R 3.3.3)                    
##  pkgconfig     2.0.1      2017-03-21 CRAN (R 3.3.3)                    
##  plyr          1.8.4      2016-06-08 CRAN (R 3.3.2)                    
##  purrr       * 0.2.2.2    2017-05-11 CRAN (R 3.3.3)                    
##  R6            2.2.2      2017-06-17 CRAN (R 3.3.3)                    
##  Rcpp          0.12.12    2017-07-15 CRAN (R 3.3.3)                    
##  readr         1.1.1      2017-05-16 CRAN (R 3.3.3)                    
##  rlang         0.1.1      2017-05-18 CRAN (R 3.3.3)                    
##  rmarkdown     1.6        2017-06-15 CRAN (R 3.3.3)                    
##  rprojroot     1.2        2017-01-16 CRAN (R 3.3.3)                    
##  scales        0.4.1.9002 2017-07-15 Github (hadley/scales@6db7b6f)    
##  stats       * 3.3.3      2017-03-06 local                             
##  stringi       1.1.5      2017-04-07 CRAN (R 3.3.3)                    
##  stringr     * 1.2.0      2017-02-18 CRAN (R 3.3.2)                    
##  tibble        1.3.3      2017-05-28 CRAN (R 3.3.3)                    
##  tidyr       * 0.6.3      2017-05-15 CRAN (R 3.3.3)                    
##  tools         3.3.3      2017-03-06 local                             
##  utils       * 3.3.3      2017-03-06 local                             
##  viridisLite   0.2.0      2017-03-24 CRAN (R 3.3.3)                    
##  withr         1.0.2      2016-06-20 CRAN (R 3.3.3)                    
##  yaml          2.1.14     2016-11-12 CRAN (R 3.3.3)&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Gráficos com dimensão espacial e temporal</title>
      <link>/graficos-com-dimensao-espacial-e-temporal/</link>
      <pubDate>Sat, 08 Jul 2017 00:00:00 +0000</pubDate>
      
      <guid>/graficos-com-dimensao-espacial-e-temporal/</guid>
      <description>&lt;p&gt;O post de hoje é sobre visualização de dados com dimensão espacial e temporal. Basicamente são gráficos que têm uma representação geográfica associada a informações que variam no tempo. Este tipo de análise é comum no meu dia a dia e por isso resolvi deixar 3 alternativas resgistradas aqui. O contexto que iremos abordar está relacionado ao banco de dados de focos de incêndios registrados pelo INPE no &lt;a href=&#34;http://www.inpe.br/queimadas/situacao-atual&#34;&gt;Programa Queimadas Monitoramento por Satélites&lt;/a&gt;. O site é bem interessante e apresenta algumas estatísticas úteis sobre as queimadas na América do Sul e Brasil. Iremos trabalhar com a tabela que resume os focos de incêndios por ano e Estado brasileiro.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;if (!require(&amp;quot;pacman&amp;quot;)) install.packages(&amp;quot;pacman&amp;quot;)
pacman::p_load(readr, dplyr, sf, ggplot2, ggthemes, geofacet, gganimate, viridis, scales)
pacman::p_load_gh(&amp;quot;italocegatta/brmap&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;O primeiro passo foi copiar os dados da página e organizá-los no formato &lt;a href=&#34;https://italocegatta.github.io/o-conceito-tidy-data/&#34;&gt;tidy&lt;/a&gt;. Poderíamos fazer uma análise exploratória dos dados, mas quero manter o foco em algo bem pontual: como mostrar os dados brutos de uma só vez? Ou seja, considerando a dimensão de tempo (ano), geografia (localização do estado) e variável resposta (focos) na mesma janela gráfica, de que forma poderíamos apresentar os dados?&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;focos &amp;lt;- read_csv2(&amp;quot;https://raw.githubusercontent.com/italocegatta/italocegatta.github.io_source/master/content/dados/base_incendios.csv&amp;quot;)

focos&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 162 x 3
##    sigla   ano focos
##    &amp;lt;chr&amp;gt; &amp;lt;int&amp;gt; &amp;lt;int&amp;gt;
##  1    AC  2011    13
##  2    AL  2011   127
##  3    AM  2011   159
##  4    AP  2011     5
##  5    BA  2011   883
##  6    CE  2011    44
##  7    DF  2011     8
##  8    ES  2011    55
##  9    GO  2011   492
## 10    MA  2011   656
## # ... with 152 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Vamos agora adicionar a referência espacial aos dados utilizando os polígonos do pacote &lt;a href=&#34;https://github.com/italocegatta/brmap&#34;&gt;brmap&lt;/a&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;estados_focos &amp;lt;-  focos %&amp;gt;% 
  left_join(brmap_estado, by = &amp;quot;sigla&amp;quot;)

estados_focos&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 162 x 6
##    sigla   ano focos cod_estado           estado          geometry
##    &amp;lt;chr&amp;gt; &amp;lt;int&amp;gt; &amp;lt;int&amp;gt;      &amp;lt;dbl&amp;gt;            &amp;lt;chr&amp;gt;  &amp;lt;simple_feature&amp;gt;
##  1    AC  2011    13         12             Acre &amp;lt;MULTIPOLYGON...&amp;gt;
##  2    AL  2011   127         27          Alagoas &amp;lt;MULTIPOLYGON...&amp;gt;
##  3    AM  2011   159         13         Amazonas &amp;lt;MULTIPOLYGON...&amp;gt;
##  4    AP  2011     5         16            Amapá &amp;lt;MULTIPOLYGON...&amp;gt;
##  5    BA  2011   883         29            Bahia &amp;lt;MULTIPOLYGON...&amp;gt;
##  6    CE  2011    44         23            Ceará &amp;lt;MULTIPOLYGON...&amp;gt;
##  7    DF  2011     8         53 Distrito Federal &amp;lt;MULTIPOLYGON...&amp;gt;
##  8    ES  2011    55         32   Espírito Santo &amp;lt;MULTIPOLYGON...&amp;gt;
##  9    GO  2011   492         52            Goiás &amp;lt;MULTIPOLYGON...&amp;gt;
## 10    MA  2011   656         21         Maranhão &amp;lt;MULTIPOLYGON...&amp;gt;
## # ... with 152 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A primeira abordagem vai utilizar o pacote &lt;a href=&#34;https://github.com/hafen/geofacet&#34;&gt;geofacet&lt;/a&gt;. Ele permite criarmos um grid de referência para orientar a função &lt;code&gt;facet_wrap&lt;/code&gt; de &lt;code&gt;ggplot2&lt;/code&gt;. O pacote já vem carregado com um grid do Brasil, o &lt;code&gt;br_grid1&lt;/code&gt;, mas você pode construir e utilizar seu próprio grid. Eu, particularmente, gosto desta representação pois é extramamente flexível e comporta uma infinidade de gráficos (linhas, pontos, barras…) e dimenções (color, shape, size…). O gráfico &lt;a href=&#34;#fig:focos-geofacet&#34;&gt;1&lt;/a&gt; está bem simples mas cumpre seu papel em facilitar a percepção da variação anual e dar uma noção da região espacial do Estado no Brasil.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggplot(estados_focos, aes(ano, focos)) +
  geom_line() +
  facet_geo(~estado, grid = br_grid1) +
  labs(
    x = &amp;quot;Ano&amp;quot;,
    y = &amp;quot;Nº de focos de incêndios&amp;quot;
  ) +
  scale_x_continuous(breaks = 2011:2017, labels = 11:17) +
  scale_y_continuous(label = unit_format(unit = &amp;quot;k&amp;quot;, scale = 1e-3)) +
  theme_few()&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;figure&#34;&gt;&lt;span id=&#34;fig:focos-geofacet&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;/post/2017-07-08-graficos-com-dimensao-espacial-e-temporal_files/figure-html/focos-geofacet-1.png&#34; alt=&#34;Representação em painel orientado utilizando linhas.&#34; width=&#34;4000&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figura  1: Representação em painel orientado utilizando linhas.
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;A segunda abordagem é relativamente simples e intuitiva. Construiremos um mapa temático utilizando o Nº de focos como escala de cor, mas organizado em um painel que tem como base o ano de registro. O gráfico &lt;a href=&#34;#fig:focos-facet&#34;&gt;2&lt;/a&gt; apela para a dimensão de cor e instantaneamente nos informa o estado mais crítico. Especificamente para esta análise ele este tipo de gráfico é muito apropriado.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggplot(estados_focos) +
  geom_sf(aes(fill = focos), color = NA) +
  facet_wrap(~ano) +
  labs(fill = &amp;quot;Nº de focos de incêndios&amp;quot;) +
  scale_fill_viridis(label = unit_format(unit = &amp;quot;k&amp;quot;, scale = 1e-3)) +
  theme_bw() +
  theme(legend.position = &amp;quot;bottom&amp;quot;, legend.justification = &amp;quot;right&amp;quot;) +
  guides(fill = guide_colorbar(barwidth = 15, title.position = &amp;quot;top&amp;quot;))&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;figure&#34;&gt;&lt;span id=&#34;fig:focos-facet&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;/post/2017-07-08-graficos-com-dimensao-espacial-e-temporal_files/figure-html/focos-facet-1.png&#34; alt=&#34;Representação em painel utilizando cores.&#34; width=&#34;4000&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figura  2: Representação em painel utilizando cores.
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;E por fim, nossa terceira tentativa vai unificar os painéis do gráfico &lt;a href=&#34;#fig:focos-facet&#34;&gt;2&lt;/a&gt; em um gif animado. A limitação do gráfico é que muitas vezes nossos gráficos vão para documentos estáticos como PDF e Word, inviabilizando o gif.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;(ggplot(estados_focos) +
  geom_sf(aes(fill = focos, frame = ano), color = NA) +
  ggtitle(&amp;quot;Ano:&amp;quot;) +
  labs(fill = &amp;quot;Nº de focos de incêndios&amp;quot;) +
  scale_fill_viridis(label = unit_format(unit = &amp;quot;k&amp;quot;, scale = 1e-3)) +
  theme_bw() +
  theme(legend.position = &amp;quot;bottom&amp;quot;, legend.justification = &amp;quot;right&amp;quot;) +
  guides(fill = guide_colorbar(barwidth = 15, title.position = &amp;quot;top&amp;quot;))
  ) %&amp;gt;% 
  gganimate()&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;a href=&#34;http://imgur.com/KoLpSsF&#34;&gt;&lt;img src=&#34;http://i.imgur.com/KoLpSsF.gif&#34; style=&#34;width:100%&#34; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Caso tenha alguma dúvida ou sugestão sobre o post, fique à vontade para fazer um comentário ou me contactar por Email.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;devtools::session_info()&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  setting  value                       
##  version  R version 3.3.3 (2017-03-06)
##  system   x86_64, mingw32             
##  ui       RTerm                       
##  language (EN)                        
##  collate  Portuguese_Brazil.1252      
##  tz       America/Sao_Paulo           
##  date     2017-07-09                  
## 
##  package     * version    date       source                            
##  animation     2.5        2017-03-30 CRAN (R 3.3.3)                    
##  assertthat    0.2.0      2017-04-11 CRAN (R 3.3.3)                    
##  backports     1.1.0      2017-05-22 CRAN (R 3.3.3)                    
##  base        * 3.3.3      2017-03-06 local                             
##  base64enc     0.1-3      2015-07-28 CRAN (R 3.3.2)                    
##  bindr         0.1        2016-11-13 CRAN (R 3.3.3)                    
##  bindrcpp      0.2        2017-06-17 CRAN (R 3.3.3)                    
##  blogdown      0.0.25     2017-03-23 Github (rstudio/blogdown@1c10d16) 
##  bookdown      0.4        2017-05-20 CRAN (R 3.3.3)                    
##  brmap       * 0.0.2      2017-07-07 local                             
##  colorspace    1.3-2      2016-12-14 CRAN (R 3.3.2)                    
##  curl          2.7        2017-06-26 CRAN (R 3.3.3)                    
##  datasets    * 3.3.3      2017-03-06 local                             
##  DBI           0.7        2017-06-18 CRAN (R 3.3.3)                    
##  devtools      1.13.2     2017-06-02 CRAN (R 3.3.3)                    
##  digest        0.6.12     2017-01-27 CRAN (R 3.3.2)                    
##  dplyr       * 0.7.1      2017-06-22 CRAN (R 3.3.3)                    
##  evaluate      0.10       2016-10-11 CRAN (R 3.3.3)                    
##  geofacet    * 0.1.4      2017-06-20 CRAN (R 3.3.3)                    
##  gganimate   * 0.1.0.9000 2017-05-24 Github (dgrtwo/gganimate@bf82002) 
##  ggplot2     * 2.2.1.9000 2017-06-16 Github (tidyverse/ggplot2@398fc07)
##  ggthemes    * 3.4.0      2017-02-19 CRAN (R 3.3.3)                    
##  glue          1.1.1      2017-06-21 CRAN (R 3.3.3)                    
##  graphics    * 3.3.3      2017-03-06 local                             
##  grDevices   * 3.3.3      2017-03-06 local                             
##  grid          3.3.3      2017-03-06 local                             
##  gridExtra     2.2.1      2016-02-29 CRAN (R 3.3.3)                    
##  gtable        0.2.0      2016-02-26 CRAN (R 3.3.2)                    
##  highr         0.6        2016-05-09 CRAN (R 3.3.3)                    
##  hms           0.3        2016-11-22 CRAN (R 3.3.2)                    
##  htmltools     0.3.6      2017-04-28 CRAN (R 3.3.3)                    
##  knitr         1.16       2017-05-18 CRAN (R 3.3.3)                    
##  labeling      0.3        2014-08-23 CRAN (R 3.3.2)                    
##  lazyeval      0.2.0      2016-06-12 CRAN (R 3.3.2)                    
##  magrittr      1.5        2014-11-22 CRAN (R 3.3.2)                    
##  memoise       1.1.0      2017-04-21 CRAN (R 3.3.3)                    
##  methods       3.3.3      2017-03-06 local                             
##  munsell       0.4.3      2016-02-13 CRAN (R 3.3.2)                    
##  pacman      * 0.4.6      2017-05-14 CRAN (R 3.3.3)                    
##  pkgconfig     2.0.1      2017-03-21 CRAN (R 3.3.3)                    
##  plyr          1.8.4      2016-06-08 CRAN (R 3.3.2)                    
##  R6            2.2.2      2017-06-17 CRAN (R 3.3.3)                    
##  Rcpp          0.12.11    2017-05-22 CRAN (R 3.3.3)                    
##  readr       * 1.1.1      2017-05-16 CRAN (R 3.3.3)                    
##  rlang         0.1.1      2017-05-18 CRAN (R 3.3.3)                    
##  rmarkdown     1.6        2017-06-15 CRAN (R 3.3.3)                    
##  rprojroot     1.2        2017-01-16 CRAN (R 3.3.3)                    
##  scales      * 0.4.1      2016-11-09 CRAN (R 3.3.2)                    
##  sf          * 0.5-1      2017-06-23 CRAN (R 3.3.3)                    
##  stats       * 3.3.3      2017-03-06 local                             
##  stringi       1.1.5      2017-04-07 CRAN (R 3.3.3)                    
##  stringr       1.2.0      2017-02-18 CRAN (R 3.3.2)                    
##  tibble        1.3.3      2017-05-28 CRAN (R 3.3.3)                    
##  tools         3.3.3      2017-03-06 local                             
##  udunits2      0.13       2016-11-17 CRAN (R 3.3.2)                    
##  units         0.4-5      2017-06-15 CRAN (R 3.3.3)                    
##  utils       * 3.3.3      2017-03-06 local                             
##  viridis     * 0.4.0      2017-03-27 CRAN (R 3.3.3)                    
##  viridisLite * 0.2.0      2017-03-24 CRAN (R 3.3.3)                    
##  withr         1.0.2      2016-06-20 CRAN (R 3.3.3)                    
##  yaml          2.1.14     2016-11-12 CRAN (R 3.3.3)&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Web scraping: dados de páginas da internet na palma da sua mão</title>
      <link>/web-scraping-dados-de-paginas-da-internet-na-palma-da-sua-mao/</link>
      <pubDate>Fri, 16 Jun 2017 00:00:00 +0000</pubDate>
      
      <guid>/web-scraping-dados-de-paginas-da-internet-na-palma-da-sua-mao/</guid>
      <description>&lt;p&gt;Você já precisou copiar na mão uma informação de texto, valor ou tabela de uma pagina web? Pelo menos no meu trabalho isto é muito comum. Por mais que os dados estejam lá site, eles nunca estão disponíveis todos juntos e no formato que queremos, parece que sacanagem. Diante disto, o objetivo deste post é mostrar como podemos utilizar o R para coletar dados de uma página web e esquecer o famooooso &lt;em&gt;ctrl+c/ctrl+v&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Vamos exemplificar o post utilizando o site do IBGE para saber quantos metros cúbicos de lenha de eucalipto foram produzidos em 2015 em cada estado brasileiro. De cara, se os dados não estiverem numa tabela pronta, você já espera ter que entrar em 27 páginas diferentes para pegar esta informação.&lt;/p&gt;
&lt;p&gt;Nosso ponto de partida é a página &lt;a href=&#34;http://www.ibge.gov.br/estadosat/&#34;&gt;States@&lt;/a&gt; do IBGE, que reúne diversas informações na escala estadual. Acessando a página podemos ver o código html por trás (utilize a tecla F12) e assim entender como a página está estruturada. Como queremos entrar nos Estados, podemos ver na Figura &lt;a href=&#34;#fig:pg1&#34;&gt;1&lt;/a&gt; que essa informação está abaixo do &lt;code&gt;id=&amp;quot;menu&amp;quot;&lt;/code&gt;. Note que ao passarmos o mouse sobre a linha &lt;code&gt;&amp;lt;div id=&amp;quot;menu&amp;quot;&amp;gt;&lt;/code&gt; o navegador identifica na página a localização do elemento e ainda nos informa o id CSS de rastreio, no caso &lt;code&gt;div#menu&lt;/code&gt;.&lt;/p&gt;
&lt;div class=&#34;figure&#34;&gt;&lt;span id=&#34;fig:pg1&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;http://i.imgur.com/VjiEvCM.png&#34; alt=&#34;Página inicial do site.&#34;  /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figura  1: Página inicial do site.
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Então já podemos começar a programar e desenhar o acesso aos dados. No R, cada página web é um objeto que precisa ser salvo na memória. Então, cada página é importante para ter os dados ou por ser uma etapa para conseguir os dados. A página inicial (&lt;code&gt;pg_raiz&lt;/code&gt;) contém os links para as páginas dos Estados, por isso precisamos acessá-la.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;if (!require(&amp;quot;pacman&amp;quot;)) install.packages(&amp;quot;pacman&amp;quot;)
pacman::p_load(purrr, dplyr, tidyr, stringr, rvest, ggplot2, viridis, scales, sf)
pacman::p_load_gh(&amp;quot;italocegatta/brmap&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;url_raiz &amp;lt;- &amp;quot;http://www.ibge.gov.br/estadosat/&amp;quot;

pg_raiz &amp;lt;- read_html(url_raiz)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;No objeto &lt;code&gt;posfixo_estados&lt;/code&gt; temos a parte do link que leva até a página de cada estado. Para ter o link completo, é só juntar com o link da página raiz.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;posfixo_estados &amp;lt;- html_node(pg_raiz, &amp;quot;div#menu&amp;quot;) %&amp;gt;% 
  html_children() %&amp;gt;%
  html_node(&amp;quot;a&amp;quot;) %&amp;gt;% 
  html_attr(&amp;quot;href&amp;quot;)

posfixo_estados&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  [1] &amp;quot;perfil.php?sigla=ro&amp;quot; &amp;quot;perfil.php?sigla=ac&amp;quot; &amp;quot;perfil.php?sigla=am&amp;quot;
##  [4] &amp;quot;perfil.php?sigla=rr&amp;quot; &amp;quot;perfil.php?sigla=pa&amp;quot; &amp;quot;perfil.php?sigla=ap&amp;quot;
##  [7] &amp;quot;perfil.php?sigla=to&amp;quot; &amp;quot;perfil.php?sigla=ma&amp;quot; &amp;quot;perfil.php?sigla=pi&amp;quot;
## [10] &amp;quot;perfil.php?sigla=ce&amp;quot; &amp;quot;perfil.php?sigla=rn&amp;quot; &amp;quot;perfil.php?sigla=pb&amp;quot;
## [13] &amp;quot;perfil.php?sigla=pe&amp;quot; &amp;quot;perfil.php?sigla=al&amp;quot; &amp;quot;perfil.php?sigla=se&amp;quot;
## [16] &amp;quot;perfil.php?sigla=ba&amp;quot; &amp;quot;perfil.php?sigla=mg&amp;quot; &amp;quot;perfil.php?sigla=es&amp;quot;
## [19] &amp;quot;perfil.php?sigla=rj&amp;quot; &amp;quot;perfil.php?sigla=sp&amp;quot; &amp;quot;perfil.php?sigla=pr&amp;quot;
## [22] &amp;quot;perfil.php?sigla=sc&amp;quot; &amp;quot;perfil.php?sigla=rs&amp;quot; &amp;quot;perfil.php?sigla=ms&amp;quot;
## [25] &amp;quot;perfil.php?sigla=mt&amp;quot; &amp;quot;perfil.php?sigla=go&amp;quot; &amp;quot;perfil.php?sigla=df&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;url_estados &amp;lt;- paste0(url_raiz, posfixo_estados)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Vamos agora acessar às páginas de todos os Estados e armazenar no objeto &lt;code&gt;pg_estados&lt;/code&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;pg_estados &amp;lt;- map(url_estados, read_html)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Navegando pela página de um estado qualquer, identificamos que queremos a informação contida no link &lt;em&gt;Extração Vegetal e Silvicultura 2015&lt;/em&gt;. Nesse caso, precisamos mais uma vez dos links que leva a esta página (para cada estado). Também é possível, tanto pelo R quanto pelo navegador, ver que esse link está na posição 68 da lista/tablela nomeada como &lt;code&gt;table.temas&lt;/code&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;posfixo_lenha &amp;lt;- map(
  pg_estados,
  ~html_node(.x, &amp;quot;table.temas&amp;quot;) %&amp;gt;% 
    html_children() %&amp;gt;%
    &amp;#39;[&amp;#39;(68) %&amp;gt;%
    html_node(&amp;quot;a&amp;quot;) %&amp;gt;% 
    html_attr(&amp;quot;href&amp;quot;)
  ) %&amp;gt;% 
  flatten_chr()

posfixo_lenha&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  [1] &amp;quot;temas.php?sigla=ro&amp;amp;tema=extracaovegetal2015&amp;quot;
##  [2] &amp;quot;temas.php?sigla=ac&amp;amp;tema=extracaovegetal2015&amp;quot;
##  [3] &amp;quot;temas.php?sigla=am&amp;amp;tema=extracaovegetal2015&amp;quot;
##  [4] &amp;quot;temas.php?sigla=rr&amp;amp;tema=extracaovegetal2015&amp;quot;
##  [5] &amp;quot;temas.php?sigla=pa&amp;amp;tema=extracaovegetal2015&amp;quot;
##  [6] &amp;quot;temas.php?sigla=ap&amp;amp;tema=extracaovegetal2015&amp;quot;
##  [7] &amp;quot;temas.php?sigla=to&amp;amp;tema=extracaovegetal2015&amp;quot;
##  [8] &amp;quot;temas.php?sigla=ma&amp;amp;tema=extracaovegetal2015&amp;quot;
##  [9] &amp;quot;temas.php?sigla=pi&amp;amp;tema=extracaovegetal2015&amp;quot;
## [10] &amp;quot;temas.php?sigla=ce&amp;amp;tema=extracaovegetal2015&amp;quot;
## [11] &amp;quot;temas.php?sigla=rn&amp;amp;tema=extracaovegetal2015&amp;quot;
## [12] &amp;quot;temas.php?sigla=pb&amp;amp;tema=extracaovegetal2015&amp;quot;
## [13] &amp;quot;temas.php?sigla=pe&amp;amp;tema=extracaovegetal2015&amp;quot;
## [14] &amp;quot;temas.php?sigla=al&amp;amp;tema=extracaovegetal2015&amp;quot;
## [15] &amp;quot;temas.php?sigla=se&amp;amp;tema=extracaovegetal2015&amp;quot;
## [16] &amp;quot;temas.php?sigla=ba&amp;amp;tema=extracaovegetal2015&amp;quot;
## [17] &amp;quot;temas.php?sigla=mg&amp;amp;tema=extracaovegetal2015&amp;quot;
## [18] &amp;quot;temas.php?sigla=es&amp;amp;tema=extracaovegetal2015&amp;quot;
## [19] &amp;quot;temas.php?sigla=rj&amp;amp;tema=extracaovegetal2015&amp;quot;
## [20] &amp;quot;temas.php?sigla=sp&amp;amp;tema=extracaovegetal2015&amp;quot;
## [21] &amp;quot;temas.php?sigla=pr&amp;amp;tema=extracaovegetal2015&amp;quot;
## [22] &amp;quot;temas.php?sigla=sc&amp;amp;tema=extracaovegetal2015&amp;quot;
## [23] &amp;quot;temas.php?sigla=rs&amp;amp;tema=extracaovegetal2015&amp;quot;
## [24] &amp;quot;temas.php?sigla=ms&amp;amp;tema=extracaovegetal2015&amp;quot;
## [25] &amp;quot;temas.php?sigla=mt&amp;amp;tema=extracaovegetal2015&amp;quot;
## [26] &amp;quot;temas.php?sigla=go&amp;amp;tema=extracaovegetal2015&amp;quot;
## [27] &amp;quot;temas.php?sigla=df&amp;amp;tema=extracaovegetal2015&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Aqui, mais uma vez, será preciso juntar o &lt;em&gt;link&lt;/em&gt; específico de cada estado com a url da página raiz.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;url_lenha &amp;lt;- paste0(url_raiz, posfixo_lenha)

pg_lenha &amp;lt;- map(url_lenha, read_html)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Agora, vamos dar um passo para trás e listar o nome dos Estados na ordem que as páginas são acessadas para podemos utilizar mais à frente.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;lista_estados &amp;lt;- html_node(pg_raiz, &amp;quot;div#menu&amp;quot;) %&amp;gt;% 
  html_children() %&amp;gt;%
  html_node(&amp;quot;img&amp;quot;) %&amp;gt;%
  html_attr(&amp;quot;alt&amp;quot;)

lista_estados&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  [1] &amp;quot;Rondônia&amp;quot;            &amp;quot;Acre&amp;quot;                &amp;quot;Amazonas&amp;quot;           
##  [4] &amp;quot;Roraima&amp;quot;             &amp;quot;Pará&amp;quot;                &amp;quot;Amapá&amp;quot;              
##  [7] &amp;quot;Tocantins&amp;quot;           &amp;quot;Maranhão&amp;quot;            &amp;quot;Piauí&amp;quot;              
## [10] &amp;quot;Ceará&amp;quot;               &amp;quot;Rio Grande do Norte&amp;quot; &amp;quot;Paraíba&amp;quot;            
## [13] &amp;quot;Pernambuco&amp;quot;          &amp;quot;Alagoas&amp;quot;             &amp;quot;Sergipe&amp;quot;            
## [16] &amp;quot;Bahia&amp;quot;               &amp;quot;Minas Gerais&amp;quot;        &amp;quot;Espírito Santo&amp;quot;     
## [19] &amp;quot;Rio de Janeiro&amp;quot;      &amp;quot;São Paulo&amp;quot;           &amp;quot;Paraná&amp;quot;             
## [22] &amp;quot;Santa Catarina&amp;quot;      &amp;quot;Rio Grande do Sul&amp;quot;   &amp;quot;Mato Grosso do Sul&amp;quot; 
## [25] &amp;quot;Mato Grosso&amp;quot;         &amp;quot;Goiás&amp;quot;               &amp;quot;Distrito federal&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;O próximo passo é extrair a tabela de informação de cada estado e posteriormente filtrar a informação que é de nosso interesse. Note que é neste momento que a programação se diferencia das atividades manuais: caso seu interesse seja por lenha de pinus, por exemplo, basta alterar uma palavra no código abaixo e ser feliz com o resultado em poucos segundos. Claro que é um exemplo hipotético, dificilmente alguém vai precisar desse código específico, mas o ponto está na capacidade de escrever seu próprio código e não precisar fazer o trabalho manual.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;tabelas &amp;lt;- map(
  set_names(pg_lenha, lista_estados), 
  ~html_node(.x, &amp;quot;table#tabela_temas&amp;quot;) %&amp;gt;% 
  html_table() %&amp;gt;% 
  as_tibble() %&amp;gt;% 
  rename(produto = X1, valor = X2, unidade = X3)
  )

qnt &amp;lt;- map_df(
  tabelas, 
  ~filter(.x, str_detect(produto, c(&amp;quot;Lenha de eucalipto&amp;quot;, &amp;quot;quantidade&amp;quot;))) %&amp;gt;% 
  &amp;#39;[[&amp;#39;(&amp;quot;valor&amp;quot;) 
  ) %&amp;gt;%
  gather(estado, volume) %&amp;gt;% 
  mutate(volume = as.numeric(str_replace_all(volume, &amp;quot;\\.&amp;quot;, &amp;quot;&amp;quot;)))

qnt &lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 27 x 2
##       estado volume
##        &amp;lt;chr&amp;gt;  &amp;lt;dbl&amp;gt;
##  1  Rondônia    690
##  2      Acre     NA
##  3  Amazonas     NA
##  4   Roraima     NA
##  5      Pará     NA
##  6     Amapá     NA
##  7 Tocantins   2300
##  8  Maranhão 195428
##  9     Piauí 188724
## 10     Ceará     NA
## # ... with 17 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;De certa forma já resolvemos o problema, a quantidade de lenha de eucalipto produzida em cada estado no ano de 2015 já está em nossas mãos. Mas vamos dar um passo além e visualizar isso num mapa. O pacote &lt;a href=&#34;https://github.com/italocegatta/brmap&#34;&gt;brmap&lt;/a&gt; possui os polígonos dos Estados brasileiros no formato &lt;code&gt;sf&lt;/code&gt;, o novo pacote para manupulação de objetos espaciais no R.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;qnt_mapa &amp;lt;- left_join(brmap_estado, qnt)

ggplot(qnt_mapa) +
  geom_sf(aes(fill = volume)) +
  labs(
    title = &amp;quot;Lenha de eucalipto - quantidade produzida em 2015&amp;quot;,
    subtitle = &amp;quot;IBGE Estados - Extração Vegetal e Silvicultura 2015&amp;quot;
  ) +
  scale_fill_viridis(
    Lenha~de~eucalipto~(m^3), 
    na.value = &amp;quot;grey90&amp;quot;,
    labels = function(x) format(x, big.mark = &amp;quot;.&amp;quot;, decimal.mark = &amp;quot;,&amp;quot;, scientific = FALSE)
  ) +
  theme_bw() +
  theme(legend.position = &amp;quot;bottom&amp;quot;) +
  guides(fill = guide_colorbar(barwidth = 30, title.position = &amp;quot;top&amp;quot;))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2017-06-16-web-scraping-dados-de-paginas-da-internet-na-palma-da-sua-mao_files/figure-html/unnamed-chunk-9-1.png&#34; width=&#34;4000&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Caso tenha alguma dúvida ou sugestão sobre o post, fique à vontade para fazer um comentário ou me contactar por Email.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;devtools::session_info()&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  setting  value                       
##  version  R version 3.3.3 (2017-03-06)
##  system   x86_64, mingw32             
##  ui       RTerm                       
##  language (EN)                        
##  collate  Portuguese_Brazil.1252      
##  tz       America/Sao_Paulo           
##  date     2017-07-08                  
## 
##  package     * version    date       source                            
##  assertthat    0.2.0      2017-04-11 CRAN (R 3.3.3)                    
##  backports     1.1.0      2017-05-22 CRAN (R 3.3.3)                    
##  base        * 3.3.3      2017-03-06 local                             
##  bindr         0.1        2016-11-13 CRAN (R 3.3.3)                    
##  bindrcpp    * 0.2        2017-06-17 CRAN (R 3.3.3)                    
##  blogdown      0.0.25     2017-03-23 Github (rstudio/blogdown@1c10d16) 
##  bookdown      0.4        2017-05-20 CRAN (R 3.3.3)                    
##  brmap       * 0.0.2      2017-07-07 local                             
##  colorspace    1.3-2      2016-12-14 CRAN (R 3.3.2)                    
##  curl          2.7        2017-06-26 CRAN (R 3.3.3)                    
##  datasets    * 3.3.3      2017-03-06 local                             
##  DBI           0.7        2017-06-18 CRAN (R 3.3.3)                    
##  devtools      1.13.2     2017-06-02 CRAN (R 3.3.3)                    
##  digest        0.6.12     2017-01-27 CRAN (R 3.3.2)                    
##  dplyr       * 0.7.1      2017-06-22 CRAN (R 3.3.3)                    
##  evaluate      0.10       2016-10-11 CRAN (R 3.3.3)                    
##  ggplot2     * 2.2.1.9000 2017-06-16 Github (tidyverse/ggplot2@398fc07)
##  glue          1.1.1      2017-06-21 CRAN (R 3.3.3)                    
##  graphics    * 3.3.3      2017-03-06 local                             
##  grDevices   * 3.3.3      2017-03-06 local                             
##  grid          3.3.3      2017-03-06 local                             
##  gridExtra     2.2.1      2016-02-29 CRAN (R 3.3.3)                    
##  gtable        0.2.0      2016-02-26 CRAN (R 3.3.2)                    
##  highr         0.6        2016-05-09 CRAN (R 3.3.3)                    
##  htmltools     0.3.6      2017-04-28 CRAN (R 3.3.3)                    
##  httr          1.2.1      2016-07-03 CRAN (R 3.3.2)                    
##  knitr         1.16       2017-05-18 CRAN (R 3.3.3)                    
##  labeling      0.3        2014-08-23 CRAN (R 3.3.2)                    
##  lazyeval      0.2.0      2016-06-12 CRAN (R 3.3.2)                    
##  magrittr      1.5        2014-11-22 CRAN (R 3.3.2)                    
##  memoise       1.1.0      2017-04-21 CRAN (R 3.3.3)                    
##  methods       3.3.3      2017-03-06 local                             
##  munsell       0.4.3      2016-02-13 CRAN (R 3.3.2)                    
##  pacman      * 0.4.6      2017-05-14 CRAN (R 3.3.3)                    
##  pkgconfig     2.0.1      2017-03-21 CRAN (R 3.3.3)                    
##  plyr          1.8.4      2016-06-08 CRAN (R 3.3.2)                    
##  purrr       * 0.2.2.2    2017-05-11 CRAN (R 3.3.3)                    
##  R6            2.2.2      2017-06-17 CRAN (R 3.3.3)                    
##  Rcpp          0.12.11    2017-05-22 CRAN (R 3.3.3)                    
##  rlang         0.1.1      2017-05-18 CRAN (R 3.3.3)                    
##  rmarkdown     1.6        2017-06-15 CRAN (R 3.3.3)                    
##  rprojroot     1.2        2017-01-16 CRAN (R 3.3.3)                    
##  rvest       * 0.3.2      2016-06-17 CRAN (R 3.3.2)                    
##  scales      * 0.4.1      2016-11-09 CRAN (R 3.3.2)                    
##  selectr       0.3-1      2016-12-19 CRAN (R 3.3.2)                    
##  sf          * 0.5-1      2017-06-23 CRAN (R 3.3.3)                    
##  stats       * 3.3.3      2017-03-06 local                             
##  stringi       1.1.5      2017-04-07 CRAN (R 3.3.3)                    
##  stringr     * 1.2.0      2017-02-18 CRAN (R 3.3.2)                    
##  tibble        1.3.3      2017-05-28 CRAN (R 3.3.3)                    
##  tidyr       * 0.6.3      2017-05-15 CRAN (R 3.3.3)                    
##  tools         3.3.3      2017-03-06 local                             
##  udunits2      0.13       2016-11-17 CRAN (R 3.3.2)                    
##  units         0.4-5      2017-06-15 CRAN (R 3.3.3)                    
##  utils       * 3.3.3      2017-03-06 local                             
##  viridis     * 0.4.0      2017-03-27 CRAN (R 3.3.3)                    
##  viridisLite * 0.2.0      2017-03-24 CRAN (R 3.3.3)                    
##  withr         1.0.2      2016-06-20 CRAN (R 3.3.3)                    
##  XML           3.98-1.9   2017-06-19 CRAN (R 3.3.3)                    
##  xml2        * 1.1.1      2017-01-24 CRAN (R 3.3.2)                    
##  yaml          2.1.14     2016-11-12 CRAN (R 3.3.3)&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Interpolação pelo inverso do quadrado da distância</title>
      <link>/interpolacao-pelo-inverso-do-quadrado-da-distancia/</link>
      <pubDate>Sun, 30 Apr 2017 00:00:00 +0000</pubDate>
      
      <guid>/interpolacao-pelo-inverso-do-quadrado-da-distancia/</guid>
      <description>&lt;script src=&#34;/rmarkdown-libs/htmlwidgets/htmlwidgets.js&#34;&gt;&lt;/script&gt;
&lt;script src=&#34;/rmarkdown-libs/jquery/jquery.min.js&#34;&gt;&lt;/script&gt;
&lt;link href=&#34;/rmarkdown-libs/leaflet/leaflet.css&#34; rel=&#34;stylesheet&#34; /&gt;
&lt;script src=&#34;/rmarkdown-libs/leaflet/leaflet.js&#34;&gt;&lt;/script&gt;
&lt;link href=&#34;/rmarkdown-libs/leafletfix/leafletfix.css&#34; rel=&#34;stylesheet&#34; /&gt;
&lt;link href=&#34;/rmarkdown-libs/leaflet-label/leaflet.label.css&#34; rel=&#34;stylesheet&#34; /&gt;
&lt;script src=&#34;/rmarkdown-libs/leaflet-label/leaflet.label.js&#34;&gt;&lt;/script&gt;
&lt;script src=&#34;/rmarkdown-libs/Proj4Leaflet/proj4-compressed.js&#34;&gt;&lt;/script&gt;
&lt;script src=&#34;/rmarkdown-libs/Proj4Leaflet/proj4leaflet.js&#34;&gt;&lt;/script&gt;
&lt;script src=&#34;/rmarkdown-libs/leaflet-binding/leaflet.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;É comum quando temos um determinado valor distribuído espacialmente e queremos estimá-lo para um ponto específico. Existem inúmeras formas de se chegar nesta estimativa, mas quero mostrar apenas uma neste post. O objetivo é estimar o quanto choveu em Itapetininga-SP, a partir de dados de chuva de outras 6 cidades próximas. Utilizaremos para isso os dados das estações automáticas do &lt;a href=&#34;http://www.inmet.gov.br/portal/index.php?r=estacoes/estacoesAutomaticas&#34;&gt;INMET&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Primeiro, vamos importar e visualizar os dados que temos disponível.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;if (!require(&amp;quot;pacman&amp;quot;)) install.packages(&amp;quot;pacman&amp;quot;)
pacman::p_load(readr, dplyr, leaflet)&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# importa o arquivo os dados de chuva
dados &amp;lt;- read_csv2(
  &amp;quot;https://raw.githubusercontent.com/italocegatta/italocegatta.github.io_source/master/content/dados/chuva_inmet.csv&amp;quot;
)

dados&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 6 x 4
##               cidade       lon       lat     p
##                &amp;lt;chr&amp;gt;     &amp;lt;dbl&amp;gt;     &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt;
## 1           Sorocaba -47.58555 -23.42603  27.0
## 2            Itapeva -48.88582 -23.98192  33.4
## 3 Sao Miguel Arcanjo -48.16482 -23.85202  34.6
## 4              Avare -48.94100 -23.10175  18.2
## 5         Piracicaba -47.62332 -22.70313  30.8
## 6       Barra Bonita -48.55757 -22.47121  42.8&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;O mapa a seguir mostra o total de chuva resgistrado pela estação meteorológica de cada cidade no dia 26/04/2017. Nosso objetivo é estimar o quanto choveu em Itapetininga utilizando a interpolação pelo inverso do quadrado da distância ou IDW (Inverse Distance Weighting).&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;leaflet(dados) %&amp;gt;% 
  addTiles() %&amp;gt;% 
  addMarkers(-48.0530600, -23.5916700) %&amp;gt;% 
  addCircleMarkers(
    ~lon, ~lat, 
    radius = ~p * 0.8, 
    label = ~as.character(p),
    popup = ~cidade,
    fillOpacity = 0.6,
    labelOptions = labelOptions(
      style = list(&amp;quot;color&amp;quot; = &amp;quot;white&amp;quot;),
      offset = c(5, -10),
      noHide = TRUE,
      textOnly = TRUE,
      direction = &amp;quot;bottom&amp;quot;
    )
  )&lt;/code&gt;&lt;/pre&gt;
&lt;div id=&#34;htmlwidget-dcaba7a7a938ce23b79b&#34; style=&#34;width:100%;height:500px;&#34; class=&#34;leaflet html-widget&#34;&gt;&lt;/div&gt;
&lt;script type=&#34;application/json&#34; data-for=&#34;htmlwidget-dcaba7a7a938ce23b79b&#34;&gt;{&#34;x&#34;:{&#34;options&#34;:{&#34;crs&#34;:{&#34;crsClass&#34;:&#34;L.CRS.EPSG3857&#34;,&#34;code&#34;:null,&#34;proj4def&#34;:null,&#34;projectedBounds&#34;:null,&#34;options&#34;:{}}},&#34;calls&#34;:[{&#34;method&#34;:&#34;addTiles&#34;,&#34;args&#34;:[&#34;//{s}.tile.openstreetmap.org/{z}/{x}/{y}.png&#34;,null,null,{&#34;minZoom&#34;:0,&#34;maxZoom&#34;:18,&#34;maxNativeZoom&#34;:null,&#34;tileSize&#34;:256,&#34;subdomains&#34;:&#34;abc&#34;,&#34;errorTileUrl&#34;:&#34;&#34;,&#34;tms&#34;:false,&#34;continuousWorld&#34;:false,&#34;noWrap&#34;:false,&#34;zoomOffset&#34;:0,&#34;zoomReverse&#34;:false,&#34;opacity&#34;:1,&#34;zIndex&#34;:null,&#34;unloadInvisibleTiles&#34;:null,&#34;updateWhenIdle&#34;:null,&#34;detectRetina&#34;:false,&#34;reuseTiles&#34;:false,&#34;attribution&#34;:&#34;&amp;copy; &lt;a href=\&#34;http://openstreetmap.org\&#34;&gt;OpenStreetMap&lt;\/a&gt; contributors, &lt;a href=\&#34;http://creativecommons.org/licenses/by-sa/2.0/\&#34;&gt;CC-BY-SA&lt;\/a&gt;&#34;}]},{&#34;method&#34;:&#34;addMarkers&#34;,&#34;args&#34;:[-23.59167,-48.05306,null,null,null,{&#34;clickable&#34;:true,&#34;draggable&#34;:false,&#34;keyboard&#34;:true,&#34;title&#34;:&#34;&#34;,&#34;alt&#34;:&#34;&#34;,&#34;zIndexOffset&#34;:0,&#34;opacity&#34;:1,&#34;riseOnHover&#34;:false,&#34;riseOffset&#34;:250},null,null,null,null,null,null,null]},{&#34;method&#34;:&#34;addCircleMarkers&#34;,&#34;args&#34;:[[-23.426035,-23.981918,-23.852022,-23.101749,-22.703132,-22.471205],[-47.585552,-48.885818,-48.164817,-48.940997,-47.623317,-48.557573],[21.6,26.72,27.68,14.56,24.64,34.24],null,null,{&#34;lineCap&#34;:null,&#34;lineJoin&#34;:null,&#34;clickable&#34;:true,&#34;pointerEvents&#34;:null,&#34;className&#34;:&#34;&#34;,&#34;stroke&#34;:true,&#34;color&#34;:&#34;#03F&#34;,&#34;weight&#34;:5,&#34;opacity&#34;:0.5,&#34;fill&#34;:true,&#34;fillColor&#34;:&#34;#03F&#34;,&#34;fillOpacity&#34;:0.6,&#34;dashArray&#34;:null},null,null,[&#34;Sorocaba&#34;,&#34;Itapeva&#34;,&#34;Sao Miguel Arcanjo&#34;,&#34;Avare&#34;,&#34;Piracicaba&#34;,&#34;Barra Bonita&#34;],null,[&#34;27&#34;,&#34;33.4&#34;,&#34;34.6&#34;,&#34;18.2&#34;,&#34;30.8&#34;,&#34;42.8&#34;],{&#34;clickable&#34;:false,&#34;noHide&#34;:true,&#34;direction&#34;:&#34;bottom&#34;,&#34;opacity&#34;:1,&#34;offset&#34;:[5,-10],&#34;textsize&#34;:&#34;10px&#34;,&#34;textOnly&#34;:true,&#34;style&#34;:{&#34;color&#34;:&#34;white&#34;},&#34;zoomAnimation&#34;:true,&#34;className&#34;:&#34;&#34;},null]}],&#34;limits&#34;:{&#34;lat&#34;:[-23.981918,-22.471205],&#34;lng&#34;:[-48.940997,-47.585552]}},&#34;evals&#34;:[],&#34;jsHooks&#34;:[]}&lt;/script&gt;
&lt;p&gt;A expressão que define o método é dada abaixo. Basicamente considera-se o valor de cada vizinho ponderado pelo inverso da distância entre ele e o ponto de interesse. Assim, vizinhos distantes contribuem com menos peso para o valor final que vizinhos mais próximos.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://bit.ly/2oN3IlI&#34; align=&#34;center&#34; border=&#34;0&#34; alt=&#34;x_{p} =\frac{\sum_{i=1}^n(\frac{1}{d_{i}^{2}}\times x_{i})}{\sum_{i=1}^n(\frac{1}{d_{i}^{2}})}&#34; width=&#34;153&#34; height=&#34;71&#34; /&gt;&lt;/p&gt;
&lt;p&gt;onde: xp = valor interpolado; xi = valor da i-ésimo ponto vizinho; di = distância entre o i-ésimo ponto de vizinho e o ponto de interesse.&lt;/p&gt;
&lt;p&gt;Agora que já definimos o método, vamos começar os cálculos. O primeiro valor calculado será a distância entre os pontos. Utilizaremos a formula de Haversine que retorna a distâncias entre dois pontos de uma esfera a partir de suas latitudes e longitudes.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;haversine &amp;lt;- function(lon1, lat1, lon2, lat2) {
  # converte graus pra radiano
  rad &amp;lt;- pi/180
  # raio medio da terra no equador em km
  R &amp;lt;- 6378.1

  dlon &amp;lt;- (lon2 - lon1) * rad
  dlat &amp;lt;- (lat2 - lat1) * rad

  a &amp;lt;- (sin(dlat/2))^2 +
       cos(lat1 * rad) *
       cos(lat2 * rad) *
       (sin(dlon/2))^2

  c &amp;lt;- 2 * atan2(sqrt(a), sqrt(1 - a))

  d &amp;lt;- R * c 

  # distancia em km
  return(d)
}&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;dist &amp;lt;- dados %&amp;gt;%
  mutate(d_itape = haversine(lon, lat, -48.0530600, -23.5916700))

dist&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 6 x 5
##               cidade       lon       lat     p   d_itape
##                &amp;lt;chr&amp;gt;     &amp;lt;dbl&amp;gt;     &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt;     &amp;lt;dbl&amp;gt;
## 1           Sorocaba -47.58555 -23.42603  27.0  51.16089
## 2            Itapeva -48.88582 -23.98192  33.4  95.30342
## 3 Sao Miguel Arcanjo -48.16482 -23.85202  34.6  31.13972
## 4              Avare -48.94100 -23.10175  18.2 105.87726
## 5         Piracicaba -47.62332 -22.70313  30.8 108.25070
## 6       Barra Bonita -48.55757 -22.47121  42.8 135.01301&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;O cálculo do IDW é relativamente simples, basta reproduzir a expressão do método.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;idw &amp;lt;- function(x, dist, na.rm = TRUE) {
  s1 &amp;lt;-  sum(x / dist^2, na.rm = na.rm)
  s2 &amp;lt;-  sum(1 / dist^2, na.rm = na.rm)

  return(s1 / s2)
}&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;dados_itape &amp;lt;- dist %&amp;gt;% 
  add_row(
    .,
    cidade = &amp;quot;Itapetininga&amp;quot;,
    lon = -48.0530600,
    lat = -23.5916700,
    p = round(idw(.$p, .$d_itape), 1)
  )

dados_itape&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 7 x 5
##               cidade       lon       lat     p   d_itape
##                &amp;lt;chr&amp;gt;     &amp;lt;dbl&amp;gt;     &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt;     &amp;lt;dbl&amp;gt;
## 1           Sorocaba -47.58555 -23.42603  27.0  51.16089
## 2            Itapeva -48.88582 -23.98192  33.4  95.30342
## 3 Sao Miguel Arcanjo -48.16482 -23.85202  34.6  31.13972
## 4              Avare -48.94100 -23.10175  18.2 105.87726
## 5         Piracicaba -47.62332 -22.70313  30.8 108.25070
## 6       Barra Bonita -48.55757 -22.47121  42.8 135.01301
## 7       Itapetininga -48.05306 -23.59167  32.1        NA&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Muito bom, agora vamos retornar ao mapa e adicionar o quanto choveu em Itapetiniga, de acordo com a interpolação por IDW. &lt;br&gt; &lt;br&gt; &lt;div id=&#34;htmlwidget-ac4090246ac7828fbbca&#34; style=&#34;width:100%;height:500px;&#34; class=&#34;leaflet html-widget&#34;&gt;&lt;/div&gt;
&lt;script type=&#34;application/json&#34; data-for=&#34;htmlwidget-ac4090246ac7828fbbca&#34;&gt;{&#34;x&#34;:{&#34;options&#34;:{&#34;crs&#34;:{&#34;crsClass&#34;:&#34;L.CRS.EPSG3857&#34;,&#34;code&#34;:null,&#34;proj4def&#34;:null,&#34;projectedBounds&#34;:null,&#34;options&#34;:{}}},&#34;calls&#34;:[{&#34;method&#34;:&#34;addTiles&#34;,&#34;args&#34;:[&#34;//{s}.tile.openstreetmap.org/{z}/{x}/{y}.png&#34;,null,null,{&#34;minZoom&#34;:0,&#34;maxZoom&#34;:18,&#34;maxNativeZoom&#34;:null,&#34;tileSize&#34;:256,&#34;subdomains&#34;:&#34;abc&#34;,&#34;errorTileUrl&#34;:&#34;&#34;,&#34;tms&#34;:false,&#34;continuousWorld&#34;:false,&#34;noWrap&#34;:false,&#34;zoomOffset&#34;:0,&#34;zoomReverse&#34;:false,&#34;opacity&#34;:1,&#34;zIndex&#34;:null,&#34;unloadInvisibleTiles&#34;:null,&#34;updateWhenIdle&#34;:null,&#34;detectRetina&#34;:false,&#34;reuseTiles&#34;:false,&#34;attribution&#34;:&#34;&amp;copy; &lt;a href=\&#34;http://openstreetmap.org\&#34;&gt;OpenStreetMap&lt;\/a&gt; contributors, &lt;a href=\&#34;http://creativecommons.org/licenses/by-sa/2.0/\&#34;&gt;CC-BY-SA&lt;\/a&gt;&#34;}]},{&#34;method&#34;:&#34;addCircleMarkers&#34;,&#34;args&#34;:[[-23.426035,-23.981918,-23.852022,-23.101749,-22.703132,-22.471205,-23.59167],[-47.585552,-48.885818,-48.164817,-48.940997,-47.623317,-48.557573,-48.05306],[27,33.4,34.6,18.2,30.8,42.8,32.1],null,null,{&#34;lineCap&#34;:null,&#34;lineJoin&#34;:null,&#34;clickable&#34;:true,&#34;pointerEvents&#34;:null,&#34;className&#34;:&#34;&#34;,&#34;stroke&#34;:true,&#34;color&#34;:&#34;#03F&#34;,&#34;weight&#34;:5,&#34;opacity&#34;:0.5,&#34;fill&#34;:true,&#34;fillColor&#34;:&#34;#03F&#34;,&#34;fillOpacity&#34;:0.6,&#34;dashArray&#34;:null},null,null,[&#34;Sorocaba&#34;,&#34;Itapeva&#34;,&#34;Sao Miguel Arcanjo&#34;,&#34;Avare&#34;,&#34;Piracicaba&#34;,&#34;Barra Bonita&#34;,&#34;Itapetininga&#34;],null,[&#34;27&#34;,&#34;33.4&#34;,&#34;34.6&#34;,&#34;18.2&#34;,&#34;30.8&#34;,&#34;42.8&#34;,&#34;32.1&#34;],{&#34;clickable&#34;:false,&#34;noHide&#34;:true,&#34;direction&#34;:&#34;bottom&#34;,&#34;opacity&#34;:1,&#34;offset&#34;:[5,-10],&#34;textsize&#34;:&#34;10px&#34;,&#34;textOnly&#34;:true,&#34;style&#34;:{&#34;color&#34;:&#34;white&#34;},&#34;zoomAnimation&#34;:true,&#34;className&#34;:&#34;&#34;},null]}],&#34;limits&#34;:{&#34;lat&#34;:[-23.981918,-22.471205],&#34;lng&#34;:[-48.940997,-47.585552]}},&#34;evals&#34;:[],&#34;jsHooks&#34;:[]}&lt;/script&gt;&lt;/p&gt;
&lt;p&gt;Caso tenha alguma dúvida ou sugestão sobre o post, fique à vontade para fazer um comentário ou me contactar por Email.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;devtools::session_info()&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  setting  value                       
##  version  R version 3.3.3 (2017-03-06)
##  system   x86_64, mingw32             
##  ui       RTerm                       
##  language (EN)                        
##  collate  Portuguese_Brazil.1252      
##  tz       America/Sao_Paulo           
##  date     2017-06-16                  
## 
##  package     * version date       source                           
##  assertthat    0.2.0   2017-04-11 CRAN (R 3.3.3)                   
##  backports     1.1.0   2017-05-22 CRAN (R 3.3.3)                   
##  base        * 3.3.3   2017-03-06 local                            
##  bindr         0.1     2016-11-13 CRAN (R 3.3.3)                   
##  bindrcpp    * 0.1     2016-12-11 CRAN (R 3.3.3)                   
##  blogdown      0.0.25  2017-03-23 Github (rstudio/blogdown@1c10d16)
##  bookdown      0.4     2017-05-20 CRAN (R 3.3.3)                   
##  crosstalk     1.0.0   2016-12-21 CRAN (R 3.3.3)                   
##  curl          2.6     2017-04-27 CRAN (R 3.3.3)                   
##  datasets    * 3.3.3   2017-03-06 local                            
##  devtools      1.13.2  2017-06-02 CRAN (R 3.3.3)                   
##  digest        0.6.12  2017-01-27 CRAN (R 3.3.2)                   
##  dplyr       * 0.7.0   2017-06-09 CRAN (R 3.3.3)                   
##  evaluate      0.10    2016-10-11 CRAN (R 3.3.3)                   
##  glue          1.0.0   2017-04-17 CRAN (R 3.3.3)                   
##  graphics    * 3.3.3   2017-03-06 local                            
##  grDevices   * 3.3.3   2017-03-06 local                            
##  hms           0.3     2016-11-22 CRAN (R 3.3.2)                   
##  htmltools     0.3.6   2017-04-28 CRAN (R 3.3.3)                   
##  htmlwidgets   0.8     2016-11-09 CRAN (R 3.3.3)                   
##  httpuv        1.3.3   2015-08-04 CRAN (R 3.3.3)                   
##  jsonlite      1.5     2017-06-01 CRAN (R 3.3.3)                   
##  knitr         1.16    2017-05-18 CRAN (R 3.3.3)                   
##  leaflet     * 1.1.0   2017-02-21 CRAN (R 3.3.3)                   
##  magrittr      1.5     2014-11-22 CRAN (R 3.3.2)                   
##  memoise       1.1.0   2017-04-21 CRAN (R 3.3.3)                   
##  methods       3.3.3   2017-03-06 local                            
##  mime          0.5     2016-07-07 CRAN (R 3.3.2)                   
##  pacman      * 0.4.6   2017-05-14 CRAN (R 3.3.3)                   
##  R6            2.2.1   2017-05-10 CRAN (R 3.3.3)                   
##  Rcpp          0.12.11 2017-05-22 CRAN (R 3.3.3)                   
##  readr       * 1.1.1   2017-05-16 CRAN (R 3.3.3)                   
##  rlang         0.1.1   2017-05-18 CRAN (R 3.3.3)                   
##  rmarkdown     1.5     2017-04-26 CRAN (R 3.3.3)                   
##  rprojroot     1.2     2017-01-16 CRAN (R 3.3.3)                   
##  shiny         1.0.3   2017-04-26 CRAN (R 3.3.3)                   
##  stats       * 3.3.3   2017-03-06 local                            
##  stringi       1.1.5   2017-04-07 CRAN (R 3.3.3)                   
##  stringr       1.2.0   2017-02-18 CRAN (R 3.3.2)                   
##  tibble        1.3.3   2017-05-28 CRAN (R 3.3.3)                   
##  tools         3.3.3   2017-03-06 local                            
##  utils       * 3.3.3   2017-03-06 local                            
##  withr         1.0.2   2016-06-20 CRAN (R 3.3.3)                   
##  xtable        1.8-2   2016-02-05 CRAN (R 3.3.3)                   
##  yaml          2.1.14  2016-11-12 CRAN (R 3.3.3)&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Download automático de imagens MODIS</title>
      <link>/download-automatico-de-imagens-modis/</link>
      <pubDate>Sun, 15 Jan 2017 00:00:00 +0000</pubDate>
      
      <guid>/download-automatico-de-imagens-modis/</guid>
      <description>&lt;!-- BLOGDOWN-HEAD --&gt;
&lt;!-- /BLOGDOWN-HEAD --&gt;

&lt;!-- BLOGDOWN-BODY-BEFORE --&gt;
&lt;!-- /BLOGDOWN-BODY-BEFORE --&gt;
&lt;p&gt;O MODIS (MODerate resolution Imaging Spectroradiometer) faz parte de um programa da NASA para monitoramento da superfície terrestre. Os satélites Terra e Aqua fornecem informações muito interessantes para o setor agroflorestal e nos permite entender de maneira bastante eficaz a dinâmica do uso do solo e de crescimento das nossas culturas.&lt;/p&gt;
&lt;p&gt;O MODOIS tem diversos &lt;a href=&#34;https://modis.gsfc.nasa.gov/data/&#34;&gt;produtos&lt;/a&gt;, mas neste post vamos tratar especificamente do produto &lt;a href=&#34;https://lpdaac.usgs.gov/dataset_discovery/modis/modis_products_table/mod13q1_v006&#34;&gt;MOD13Q1&lt;/a&gt;, que disponibiliza a cada 16 dias um raster de EVI e NDVI com resolução de 250 m. Bom, se você está acostumado com imagens de satélite/drone/vant com resolução submétrica, pode ser que no primeiro momento esta escala te assuste. Mas vale lembrar que é um serviço gratuito e e de ótima qualidade.&lt;/p&gt;
&lt;p&gt;As cenas do MODIS ficam disponíveis em um &lt;a href=&#34;https://e4ftl01.cr.usgs.gov/&#34;&gt;ftp&lt;/a&gt; e navegando por lá podemos chegar na pasta do produto que nos &lt;a href=&#34;http://e4ftl01.cr.usgs.gov/MOLT/MOD13Q1.006&#34;&gt;interessa&lt;/a&gt;. Temos então imagens de satélite processadas, com correção atmosférica, sem deslocamento espacial e com regularidade. O satélite varre a terra a cada dois dias e as melhores visadas são utilizadas para compor o produto que é disponibilizado a cada 16 dias. Há casos (de baixa frequência) em que a nebulosidade é tanta que não é possível compor a informação do pixel dentro desta janela&lt;/p&gt;
&lt;p&gt;Nosso objetivo para este poste é fazer o download das cenas de forma automática, um web scraping. No R há diversos pacotes que nos auxiliam neste processo. A primeira etapa é acessar o ftp que contém as cenas e extrair as datas das cenas disponíveis.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;if (!require(&amp;quot;pacman&amp;quot;)) install.packages(&amp;quot;pacman&amp;quot;)
pacman::p_load(dplyr, xml2, rvest, httr, stringr, methods)&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# url do ftp que contém as cenas
path_root &amp;lt;- &amp;quot;http://e4ftl01.cr.usgs.gov/MOLT/MOD13Q1.006&amp;quot;

# carrega a raiz do ftp
page_root &amp;lt;- read_html(path_root)

# extrai os dias das cenas
scene_days &amp;lt;- page_root %&amp;gt;% 
 html_nodes(&amp;quot;a&amp;quot;) %&amp;gt;% 
  html_text(trim = T) %&amp;gt;%
  &amp;#39;[&amp;#39;(-c(1:7)) %&amp;gt;%
  str_replace_all(&amp;quot;\\/&amp;quot;, &amp;quot;&amp;quot;)

glimpse(scene_days)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  chr [1:395] &amp;quot;2000.02.18&amp;quot; &amp;quot;2000.03.05&amp;quot; &amp;quot;2000.03.21&amp;quot; ...&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Muito bem, temos até a data da ultima atualização deste post 395 cenas disponíveis. O script abaixo cria a pasta com a data da cena e coloca lá os &lt;a href=&#34;https://modis-land.gsfc.nasa.gov/MODLAND_grid.html&#34;&gt;tiles&lt;/a&gt; de seu interesse. Como exemplo vamos pegar os tiles que cobrem os estados de São Paulo e Bahia. Note que é preciso ter um cadastro para autorizar o download dos arquivos. É simples e rápido de fazer acessando este &lt;a href=&#34;https://urs.earthdata.nasa.gov/users/new/&#34;&gt;link&lt;/a&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# inicio do 1º loop - dias
for (i in seq_along(scene_days)) {
  # cria a pasta para receber os tiles
  if(!dir.exists(scene_days[i])) dir.create(scene_days[i])

  # ideintificador de iteração
  day &amp;lt;- scene_days[i]
  
  # carrega a pagina do dia da cena
  page_tiles &amp;lt;- read_html(paste(path_root, day, sep = &amp;quot;/&amp;quot;))
  
  # extrai os tiles de interesse
  path_tiles &amp;lt;- page_tiles %&amp;gt;% 
    html_nodes(&amp;quot;a&amp;quot;) %&amp;gt;% 
    html_text(trim = T) %&amp;gt;%
    &amp;#39;[&amp;#39;(str_detect(., &amp;quot;[hdf]$&amp;quot;)) %&amp;gt;% 
    &amp;#39;[&amp;#39;(str_detect(., &amp;quot;h13v11|h14v10&amp;quot;))
  
  # inicio do 2º loop - tiles
  for (j in seq_along(path_tiles)) {
    # url do tile
    path_tile &amp;lt;- paste(path_root, day, path_tiles[j], sep = &amp;quot;/&amp;quot;)

    # id do tile
    tile &amp;lt;- paste(day, path_tiles[j], sep = &amp;quot;/&amp;quot;)
    
    # download do arquivo
    if (!file.exists(tile)) {
      temp &amp;lt;- GET(path_tile, authenticate(&amp;quot;LOGIN&amp;quot;, &amp;quot;SENHA&amp;quot;))
      writeBin(content(temp, &amp;quot;raw&amp;quot;), tile)
      rm(temp)
    }
  }
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Como tudo que está neste blog, este script foi escrito para resolver um problema específico e com certeza tem muito espaço para melhoria. Os próximos passos da análise, extração dos rasters e processamento da imagem serão abordados em posts separados. No futuro, caso exista uma demanda, pode ser que as funções sejam reunidas em um pacote específico sobre isso.&lt;/p&gt;
&lt;p&gt;Caso tenha alguma dúvida ou sugestão sobre o post, fique à vontade para fazer um comentário ou me contactar por Email.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;devtools::session_info()&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  setting  value                       
##  version  R version 3.3.3 (2017-03-06)
##  system   x86_64, mingw32             
##  ui       RTerm                       
##  language (EN)                        
##  collate  Portuguese_Brazil.1252      
##  tz       America/Sao_Paulo           
##  date     2017-04-30                  
## 
##  package    * version  date       source                           
##  assertthat   0.2.0    2017-04-11 CRAN (R 3.3.3)                   
##  backports    1.0.5    2017-01-18 CRAN (R 3.3.2)                   
##  blogdown     0.0.25   2017-03-23 Github (rstudio/blogdown@1c10d16)
##  bookdown     0.3.14   2017-03-23 Github (rstudio/bookdown@f427fdf)
##  curl         2.6      2017-04-27 CRAN (R 3.3.3)                   
##  DBI          0.6-1    2017-04-01 CRAN (R 3.3.3)                   
##  devtools     1.12.0   2016-06-24 CRAN (R 3.3.3)                   
##  digest       0.6.12   2017-01-27 CRAN (R 3.3.2)                   
##  dplyr      * 0.5.0    2016-06-24 CRAN (R 3.3.2)                   
##  evaluate     0.10     2016-10-11 CRAN (R 3.3.3)                   
##  htmltools    0.3.6    2017-04-28 CRAN (R 3.3.3)                   
##  httr       * 1.2.1    2016-07-03 CRAN (R 3.3.2)                   
##  knitr        1.15.1   2016-11-22 CRAN (R 3.3.3)                   
##  magrittr     1.5      2014-11-22 CRAN (R 3.3.2)                   
##  memoise      1.1.0    2017-04-21 CRAN (R 3.3.3)                   
##  pacman     * 0.4.1    2016-03-30 CRAN (R 3.3.3)                   
##  R6           2.2.0    2016-10-05 CRAN (R 3.3.2)                   
##  Rcpp         0.12.10  2017-03-19 CRAN (R 3.3.3)                   
##  rmarkdown    1.5      2017-04-26 CRAN (R 3.3.3)                   
##  rprojroot    1.2      2017-01-16 CRAN (R 3.3.3)                   
##  rvest      * 0.3.2    2016-06-17 CRAN (R 3.3.2)                   
##  selectr      0.3-1    2016-12-19 CRAN (R 3.3.2)                   
##  stringi      1.1.5    2017-04-07 CRAN (R 3.3.3)                   
##  stringr    * 1.2.0    2017-02-18 CRAN (R 3.3.2)                   
##  tibble       1.3.0    2017-04-01 CRAN (R 3.3.3)                   
##  withr        1.0.2    2016-06-20 CRAN (R 3.3.3)                   
##  XML          3.98-1.6 2017-03-30 CRAN (R 3.3.3)                   
##  xml2       * 1.1.1    2017-01-24 CRAN (R 3.3.2)                   
##  yaml         2.1.14   2016-11-12 CRAN (R 3.3.3)&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Índice de uniformidade (PV50)</title>
      <link>/indice-de-uniformidade-pv50/</link>
      <pubDate>Sun, 09 Oct 2016 00:00:00 +0000</pubDate>
      
      <guid>/indice-de-uniformidade-pv50/</guid>
      <description>&lt;p&gt;O PV50 é hoje o índice mais utilizado quando queremos expressar a uniformidade de um plantio florestal. &lt;span class=&#34;citation&#34;&gt;Hakamada (&lt;a href=&#34;#ref-Hakamada2012&#34;&gt;2012&lt;/a&gt;)&lt;/span&gt; apresentou um estudo detalhado sobre diversos índices e concluiu que o PV50 é o índice mais indicado para explicar a relação entre uniformidade, qualidade silvicultural e produtividade em plantios homogêneos de &lt;em&gt;Eucalyptus&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;O objetivo deste post é mostrar, passo a passo, como calcular este índice no R e fazer uma breve análise de seus resultados.&lt;/p&gt;
&lt;p&gt;O PV50 é a porcentagem de volume acumulado das 50% menores árvores do seu conjunto de dados, considerando as falhas de plantio e árvores mortas &lt;span class=&#34;citation&#34;&gt;(Hakamada et al. &lt;a href=&#34;#ref-Hakamada2015&#34;&gt;2015&lt;/a&gt;)&lt;/span&gt;. A expressão do índice é dada da seguinte forma:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://www.sciweavers.org/tex2img.php?eq=PV50%20%3D%20%5Cfrac%7B%5Csum_%7Bk%3D1%7D%5E%7B%5Cfrac%7Bn%7D%7B2%7D%7DV_%7Bij%7D%7D%7B%5Csum_%7Bk%3D1%7D%5E%7Bn%7DV_%7Bij%7D%7D&amp;bc=White&amp;fc=Black&amp;im=jpg&amp;fs=12&amp;ff=arev&amp;edit=0&#34; align=&#34;center&#34; border=&#34;0&#34; alt=&#34;PV50 = \frac{\sum_{k=1}^{\frac{n}{2}}V_{ij}}{\sum_{k=1}^{n}V_{ij}}&#34; width=&#34;139&#34; height=&#34;62&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Onde: PV50 = porcentagem acumulada do volume das 50% menores árvores plantadas; V = volume da árvore i; n = número de árvores plantadas ordenadas (da menor para a maior).&lt;/p&gt;
&lt;p&gt;Primeiro vamos entender os cálculos do índice, considerando apenas 10 árvores hipotéticas com 0,1 metros cúbicos de volume.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# carrega os pacotes necessários
if (!require(&amp;quot;pacman&amp;quot;)) install.packages(&amp;quot;pacman&amp;quot;)
pacman::p_load(readr, dplyr, ggplot2, forcats)&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# exemplo com número par
arv10 &amp;lt;- rep(0.1, 10)
str(arv10)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  num [1:10] 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Este é o referencial teórico de uniformidade, todas as árvores do mesmo tamanho. Sem precisar fazer conta, sabemos que o volume das 50% menores árvores é igual a 50% do volume total, o que equivale a um PV50 = 50.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# identifica a metade do numero de árvores
metade &amp;lt;- length(arv10)/2
metade&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 5&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# soma todas as árvores
soma_todas &amp;lt;- sum(arv10, na.rm = TRUE)
soma_todas&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 1&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# soma o valor de metade das árvores em ordem crescente
soma_metade &amp;lt;- sum(sort(arv10)[1:metade], na.rm = TRUE)
soma_metade&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 0.5&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# calcula o PV50
PV50 &amp;lt;- soma_metade / soma_todas * 100
PV50&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 50&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Agora vamos simular 11 árvores com o mesmo volume, veja o que acontece.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# exemplo com número impar
arv11 &amp;lt;- rep(0.1, 11)
str(arv11)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  num [1:11] 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 ...&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# metade do numero de árvores
metade &amp;lt;- length(arv11)/2
metade&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 5.5&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# soma todas as árvores
soma_todas &amp;lt;- sum(arv11, na.rm = TRUE)
soma_todas&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 1.1&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# soma o valor de metade das árvores em ordem crescente
soma_metade &amp;lt;- sum(sort(arv11)[1:metade], na.rm = TRUE)
soma_metade&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 0.5&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# calcula o PV50
PV50 &amp;lt;- soma_metade / soma_todas * 100
PV50&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 45.45455&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;O resultado deveria ser 50, mas como o número de árvores é impar, o R arredonda a posição 5,5 para 5 e pega até a quinta árvore no momento em que queremos somar as 50% menores. Para contornar isso, vamos calcular a soma das 50% menores árvores de uma forma diferente. Primeiro calculamos a soma acumulada e depois extraímos a média (semelhante ao modo de se calcular uma mediana).&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# vetor de soma acumulada
soma_acumulada &amp;lt;- cumsum(sort(arv11))
soma_acumulada&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  [1] 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0 1.1&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# soma a metade do vetor de soma acumulada
soma_metade &amp;lt;- mean(soma_acumulada[metade + 0L:1L], na.rm = TRUE)
soma_metade&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 0.55&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# calcula o PV50
PV50 &amp;lt;- soma_metade / soma_todas * 100
PV50&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 50&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Agora que a questão do número de árvores foi superada, podemos incluir árvores mortas, o que equivale a elementos do tipo &lt;code&gt;NA&lt;/code&gt; no R. Veja que o resultado não está consistente pois a &lt;code&gt;soma_acumulada&lt;/code&gt; ignorou as árvores mortas.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# exemplo com valores perdidos
arv11_na &amp;lt;- rep(0.1, 11)
arv11_na[c(3,4)] &amp;lt;- NA
str(arv11_na)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  num [1:11] 0.1 0.1 NA NA 0.1 0.1 0.1 0.1 0.1 0.1 ...&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# metade do numero de árvores
metade &amp;lt;- length(arv11_na)/2
metade&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 5.5&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# soma todas as árvores
soma_todas &amp;lt;- sum(arv11_na, na.rm = TRUE)
soma_todas&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 0.9&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# vetor de soma acumulada
soma_acumulada &amp;lt;- cumsum(sort(arv11_na))
soma_acumulada&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# soma a metade do vetor de soma acumulada
soma_metade &amp;lt;- mean(soma_acumulada[metade + 0L:1L], na.rm = TRUE)
soma_metade&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 0.55&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# calcula o PV50
PV50 &amp;lt;- soma_metade / soma_todas * 100
PV50&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 61.11111&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Para corrigir este o erro, temos de incluir manualmente as árvores mortas na sequência. Veja que agora o resultado está de acordo com o esperado.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# vetor de valores perdidos
mortas &amp;lt;- arv11_na[is.na(arv11_na)]
mortas&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] NA NA&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# metade do numero de árvores
metade &amp;lt;- length(arv11_na)/2
metade&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 5.5&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# soma todas as árvores
soma_todas &amp;lt;- sum(arv11_na, na.rm = TRUE)
soma_todas&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 0.9&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# vetor de soma acumulada com valores perdidos
soma_acumulada &amp;lt;- c(mortas, cumsum(sort(arv11_na)))
soma_acumulada&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  [1]  NA  NA 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# soma a metade do vetor de soma acumulada
soma_metade &amp;lt;- mean(soma_acumulada[metade + 0L:1L], na.rm = TRUE)
soma_metade&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 0.35&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# calcula o PV50
PV50 &amp;lt;- soma_metade / soma_todas * 100
PV50&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 38.88889&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Agora eu vou dar aquele passo mágico dos livros de matemática e física, em que o autor diz “é fácil notar que o resultado leva a …” e apresentar uma função que lida com as questões que mostramos acima e retorna o PV50 do nosso conjunto de dados de forma correta.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;pv50 &amp;lt;- function(x) {
  
  mortas &amp;lt;- x[is.na(x)]
  
  metade &amp;lt;- length(x)/2
  
  soma_todas &amp;lt;- sum(x, na.rm = TRUE)
  
  soma_acumulada &amp;lt;- c(mortas, cumsum(sort(x)))
  
  if (metade%%2L == 1L)
    soma_metade &amp;lt;- mean(soma_acumulada[metade], na.rm = TRUE)
  else
    soma_metade &amp;lt;- mean(soma_acumulada[metade + 0L:1L], na.rm = TRUE)
  
  z &amp;lt;- soma_metade / soma_todas * 100
  
  return(z)
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Podemos rapidamente verificar se os resultados estão consistentes fazendo alguns testes.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;a &amp;lt;- rep(10, 10)
str(a)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  num [1:10] 10 10 10 10 10 10 10 10 10 10&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;pv50(a) # Ok!&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 50&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;a1 &amp;lt;- rep(10 ,11)
str(a1)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  num [1:11] 10 10 10 10 10 10 10 10 10 10 ...&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;pv50(a1) # Ok!&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 50&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;b &amp;lt;- a
b[c(3, 7)] &amp;lt;- NA
str(b)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  num [1:10] 10 10 NA 10 10 10 NA 10 10 10&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;pv50(b) # Ok!&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 37.5&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;b1 &amp;lt;- a1
b1[c(3, 7)] &amp;lt;- NA
str(b1)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  num [1:11] 10 10 NA 10 10 10 NA 10 10 10 ...&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;pv50(b1) # Ok!&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 38.88889&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Boa, já temos uma função para calcular o PV50 e podemos aplicá-la em um conjunto de dados para podermos interpretar. Utilizaremos mais uma vez os dados do &lt;a href=&#34;www.projetotume.com&#34;&gt;Projeto TUME&lt;/a&gt;, referente ao &lt;a href=&#34;http://www.projetotume.com/tume134&#34;&gt;TUME 134&lt;/a&gt; plantado em Piracicaba-SP. O volume individual foi calculado arbitrariamente utilizando o fator de forma 0,5.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# importa o arquivo tume_55.csv
dados &amp;lt;- read_csv2(
  &amp;quot;https://github.com/italocegatta/italocegatta.github.io_source/raw/master/content/dados/tume_55.csv&amp;quot;
)

glimpse(dados)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Observations: 1,222
## Variables: 7
## $ Esp     &amp;lt;chr&amp;gt; &amp;quot;E_camaldulensis&amp;quot;, &amp;quot;E_camaldulensis&amp;quot;, &amp;quot;E_camaldulensis...
## $ I_meses &amp;lt;int&amp;gt; 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34...
## $ Parc_m2 &amp;lt;int&amp;gt; 288, 288, 288, 288, 288, 288, 288, 288, 288, 288, 288,...
## $ N_arv   &amp;lt;int&amp;gt; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16,...
## $ DAP_cm  &amp;lt;dbl&amp;gt; 5.411268, 12.254931, 3.978874, 6.429860, 9.676621, 5.6...
## $ H_m     &amp;lt;dbl&amp;gt; 7.651490, 11.424046, 5.909205, 8.572873, 10.498957, 7....
## $ Vol     &amp;lt;dbl&amp;gt; 0.008798406, 0.067375427, 0.003673747, 0.013918399, 0....&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Iremos calcular o PV50 e o volume por hectare para cada fator &lt;code&gt;Esp&lt;/code&gt; e &lt;code&gt;I_meses&lt;/code&gt; e em seguida ordenar as espécies pelo PV50.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# agrupa os dados em função de espécie e idade para 
# calcular o pv50 e o volume
dados_pv50 &amp;lt;- dados %&amp;gt;% 
  group_by(Esp, I_meses) %&amp;gt;% 
  summarise(
    Parc_m2 = mean( Parc_m2),
    PV50 = pv50(Vol),
    Vol_ha = sum(Vol, na.rm = TRUE) * (10000/Parc_m2)
  ) %&amp;gt;%
  ungroup() %&amp;gt;% 
  # ordena o fator de espécies de forma decrescente em função do pv50
  mutate(Esp = fct_reorder(Esp, -PV50))

dados_pv50&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 20 × 5
##                    Esp I_meses Parc_m2     PV50    Vol_ha
##                 &amp;lt;fctr&amp;gt;   &amp;lt;int&amp;gt;   &amp;lt;dbl&amp;gt;    &amp;lt;dbl&amp;gt;     &amp;lt;dbl&amp;gt;
## 1      E_camaldulensis      34     288 21.36325  47.50044
## 2      E_camaldulensis      46     288 14.26669  79.09417
## 3      E_camaldulensis      60     600 13.18344 110.06612
## 4      E_camaldulensis      85     288 12.70684 203.98374
## 5         E_citriodora      34     288 17.84086  46.56646
## 6         E_citriodora      46     288 16.43760  84.96252
## 7         E_citriodora      60     600 12.53474  97.00958
## 8         E_citriodora      85     288 12.73166 205.04360
## 9             E_dunnii      34     288 28.58694 103.36725
## 10            E_dunnii      46     288 29.21288 160.54057
## 11            E_dunnii      60     600 27.46026 198.47239
## 12            E_dunnii      85     288 26.39616 349.63571
## 13        E_paniculata      34     288 27.36895  46.43145
## 14        E_paniculata      46     288 24.13274  84.42312
## 15        E_paniculata      60     600 19.63065 114.81369
## 16        E_paniculata      85     288 18.21965 194.87958
## 17 E_urophylla_grandis      34     288 26.25100  85.67855
## 18 E_urophylla_grandis      46     288 24.20636 157.30295
## 19 E_urophylla_grandis      60     600 20.33734 217.30209
## 20 E_urophylla_grandis      85     288 17.89856 277.37748&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Para entendermos os dados, vamos primeiro ver o crescimento em volume de cada espécies em função do tempo (Figura &lt;a href=&#34;#fig:12-vol-idade&#34;&gt;1&lt;/a&gt;). Note que &lt;em&gt;E. dunnii&lt;/em&gt; e &lt;em&gt;E. urophylla&lt;/em&gt; x &lt;em&gt;E. grandis&lt;/em&gt; tinham crescimento muito parecido até os 60 meses de idade.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggplot(dados_pv50, aes(I_meses, Vol_ha, color = Esp)) +
  geom_point() +
  geom_line() +
  labs(
    color = &amp;quot;Espécies&amp;quot;,
    x = &amp;quot;Idade (meses)&amp;quot;,
    y = Volume~m^3~ha^-1
  ) +
  scale_color_brewer(palette = &amp;quot;Set1&amp;quot;) +
  theme_bw(base_size = 16) +
  theme(legend.justification = &amp;quot;top&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;figure&#34;&gt;&lt;span id=&#34;fig:12-vol-idade&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;/post/2016-10-09-indice-de-uniformidade-pv50_files/figure-html/12-vol-idade-1.png&#34; alt=&#34;Crescimento em volume por hectare em função da idade.&#34; width=&#34;4000&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figura  1: Crescimento em volume por hectare em função da idade.
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Agora podemos construir um gráfico que relaciona o PV50 e a idade (Figura &lt;a href=&#34;#fig:12-pv50-idade&#34;&gt;2&lt;/a&gt;). A interpretação do índice é simples, o PV50 representa a porcentagem em volume que as 50% menores árvores contribuem para o volume total. Em nossos dados, &lt;em&gt;E. dunnii&lt;/em&gt;, ao 85 meses de idade, tem um PV50 de aproximadamente 26. Isso quer dizer que aos 7 anos, as 50% menores árvores da parcela de &lt;em&gt;E. dunnii&lt;/em&gt; representam apenas 26% do volume total. Ou seja, 50% das árvores contribuem muito pouco para o volume total da parcela e isso tem um impacto direto na produtividade.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggplot(dados_pv50, aes(I_meses, PV50, color = Esp)) +
  geom_point() +
  geom_line() +
  labs(color = &amp;quot;Espécies&amp;quot;, x = &amp;quot;Idade (meses)&amp;quot;, y = &amp;quot;PV50&amp;quot;) +
  scale_color_brewer(palette = &amp;quot;Set1&amp;quot;) +
  scale_y_continuous(breaks = seq(10, 30, 2)) +
  theme_bw(base_size = 16) +
  theme(legend.justification = &amp;quot;top&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;figure&#34;&gt;&lt;span id=&#34;fig:12-pv50-idade&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;/post/2016-10-09-indice-de-uniformidade-pv50_files/figure-html/12-pv50-idade-1.png&#34; alt=&#34;Variação do PV50 por espécies em função da idade.&#34; width=&#34;4000&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figura  2: Variação do PV50 por espécies em função da idade.
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;A Figura &lt;a href=&#34;#fig:12-pv50-vol&#34;&gt;3&lt;/a&gt; mostra claramente a relação direta que há entre produção de madeira e a uniformidade ao longo do crescimento da floresta. Note também que na medida em que a idade avança, a uniformidade diminui, pois a dominância das árvores maiores sobre as menores fica cada vez mais forte.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggplot(dados_pv50, aes(Vol_ha, PV50)) +
  geom_point(aes(color = factor(I_meses))) +
  geom_smooth(method = &amp;quot;lm&amp;quot;, formula = y ~x, se = FALSE) +
  facet_wrap(~Esp, dir = &amp;quot;v&amp;quot;) +
  labs(color = &amp;quot;Idade (meses)&amp;quot;, x = Volume~m^3~ha^-1, y = &amp;quot;PV50&amp;quot;) +
  scale_color_brewer(palette = &amp;quot;Dark2&amp;quot;) +
  theme_bw(base_size = 16) +
  theme(legend.justification = &amp;quot;top&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;figure&#34;&gt;&lt;span id=&#34;fig:12-pv50-vol&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;/post/2016-10-09-indice-de-uniformidade-pv50_files/figure-html/12-pv50-vol-1.png&#34; alt=&#34;Relação entre o PV50 e volume por hectare em função da idade.&#34; width=&#34;4000&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figura  3: Relação entre o PV50 e volume por hectare em função da idade.
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Por fim, para colocar tudo em um só gráfico, podemos adicionar ao gráfico de crescimento em volume a informação do PV50 para evidenciar que as espécies mais produtivas tem PV50 elevado e que este índice consegue explicar muito bem essa relação (Figura &lt;a href=&#34;#fig:12-vol-pv50-idade&#34;&gt;4&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;Um comentário interessante é que dentre as espécies que estamos estudando, todas são de origem seminal, com exceção do &lt;em&gt;E. dunnii&lt;/em&gt;, que é um clone. Este fator explica sua produtividade e alta homogeneidade, principalmente frente ao hibrido de &lt;em&gt;E. urophylla&lt;/em&gt; x &lt;em&gt;E. grandis&lt;/em&gt;, que é seu concorrente direto. Quando estivermos analisando dados de plantios clonais, o PV50 vai expressar a qualidade silvicultural do plantio, uma vez que a base genética é a mesma em todas as plantas.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggplot(dados_pv50, aes(I_meses, Vol_ha, color = Esp)) +
  geom_point(aes(size = PV50), alpha = 0.4) +
  geom_line() +
  labs(
    color = &amp;quot;Espécies&amp;quot;,
    x = &amp;quot;Idade (meses)&amp;quot;,
    y = Volume~m^3~ha^-1
  ) +
  scale_color_brewer(palette = &amp;quot;Set1&amp;quot;) +
  theme_bw(base_size = 16) +
  theme(legend.justification = &amp;quot;top&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;figure&#34;&gt;&lt;span id=&#34;fig:12-vol-pv50-idade&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;/post/2016-10-09-indice-de-uniformidade-pv50_files/figure-html/12-vol-pv50-idade-1.png&#34; alt=&#34;Crescimento do volume em função da idade, com informação do PV50 no tamanho do ponto.&#34; width=&#34;4000&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figura  4: Crescimento do volume em função da idade, com informação do PV50 no tamanho do ponto.
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Caso tenha alguma dúvida ou sugestão sobre o post, fique à vontade para fazer um comentário ou me contactar por Email.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;devtools::session_info()&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  setting  value                       
##  version  R version 3.3.3 (2017-03-06)
##  system   x86_64, mingw32             
##  ui       RTerm                       
##  language (EN)                        
##  collate  Portuguese_Brazil.1252      
##  tz       America/Sao_Paulo           
##  date     2017-04-30                  
## 
##  package      * version date       source                           
##  assertthat     0.2.0   2017-04-11 CRAN (R 3.3.3)                   
##  backports      1.0.5   2017-01-18 CRAN (R 3.3.2)                   
##  blogdown       0.0.25  2017-03-23 Github (rstudio/blogdown@1c10d16)
##  bookdown       0.3.14  2017-03-23 Github (rstudio/bookdown@f427fdf)
##  colorspace     1.3-2   2016-12-14 CRAN (R 3.3.2)                   
##  curl           2.6     2017-04-27 CRAN (R 3.3.3)                   
##  DBI            0.6-1   2017-04-01 CRAN (R 3.3.3)                   
##  devtools       1.12.0  2016-06-24 CRAN (R 3.3.3)                   
##  digest         0.6.12  2017-01-27 CRAN (R 3.3.2)                   
##  dplyr        * 0.5.0   2016-06-24 CRAN (R 3.3.2)                   
##  evaluate       0.10    2016-10-11 CRAN (R 3.3.3)                   
##  forcats      * 0.2.0   2017-01-23 CRAN (R 3.3.2)                   
##  ggplot2      * 2.2.1   2016-12-30 CRAN (R 3.3.2)                   
##  gtable         0.2.0   2016-02-26 CRAN (R 3.3.2)                   
##  highr          0.6     2016-05-09 CRAN (R 3.3.3)                   
##  hms            0.3     2016-11-22 CRAN (R 3.3.2)                   
##  htmltools      0.3.6   2017-04-28 CRAN (R 3.3.3)                   
##  knitr          1.15.1  2016-11-22 CRAN (R 3.3.3)                   
##  labeling       0.3     2014-08-23 CRAN (R 3.3.2)                   
##  lazyeval       0.2.0   2016-06-12 CRAN (R 3.3.2)                   
##  magrittr       1.5     2014-11-22 CRAN (R 3.3.2)                   
##  memoise        1.1.0   2017-04-21 CRAN (R 3.3.3)                   
##  munsell        0.4.3   2016-02-13 CRAN (R 3.3.2)                   
##  pacman       * 0.4.1   2016-03-30 CRAN (R 3.3.3)                   
##  plyr           1.8.4   2016-06-08 CRAN (R 3.3.2)                   
##  R6             2.2.0   2016-10-05 CRAN (R 3.3.2)                   
##  RColorBrewer   1.1-2   2014-12-07 CRAN (R 3.3.2)                   
##  Rcpp           0.12.10 2017-03-19 CRAN (R 3.3.3)                   
##  readr        * 1.1.0   2017-03-22 CRAN (R 3.3.3)                   
##  rmarkdown      1.5     2017-04-26 CRAN (R 3.3.3)                   
##  rprojroot      1.2     2017-01-16 CRAN (R 3.3.3)                   
##  scales         0.4.1   2016-11-09 CRAN (R 3.3.2)                   
##  stringi        1.1.5   2017-04-07 CRAN (R 3.3.3)                   
##  stringr        1.2.0   2017-02-18 CRAN (R 3.3.2)                   
##  tibble         1.3.0   2017-04-01 CRAN (R 3.3.3)                   
##  withr          1.0.2   2016-06-20 CRAN (R 3.3.3)                   
##  yaml           2.1.14  2016-11-12 CRAN (R 3.3.3)&lt;/code&gt;&lt;/pre&gt;
&lt;div id=&#34;referencias&#34; class=&#34;section level1 unnumbered&#34;&gt;
&lt;h1&gt;Referências&lt;/h1&gt;
&lt;div id=&#34;refs&#34; class=&#34;references&#34;&gt;
&lt;div id=&#34;ref-Hakamada2012&#34;&gt;
&lt;p&gt;Hakamada, Rodrigo Eiji. 2012. “Uso do inventário florestal como ferramenta de monitoramento da qualidade silvicultura em povoamentos clonais de Eucalyptus.” PhD thesis, Piracicaba: Universidade de São Paulo; Biblioteca Digital de Teses e Dissertações da Universidade de São Paulo. doi:&lt;a href=&#34;https://doi.org/10.11606/D.11.2012.tde-05072012-100431&#34;&gt;10.11606/D.11.2012.tde-05072012-100431&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;ref-Hakamada2015&#34;&gt;
&lt;p&gt;Hakamada, Rodrigo Eiji, José Luiz Stape, Cristiane Camargo Zani de Lemos, Adriano Emanuel Amaral Almeida, and Luis Fernando Silva. 2015. “Uniformidade entre árvores durante uma rotação e sua relação com a produtividade em Eucalyptus clonais.” &lt;em&gt;CERNE&lt;/em&gt; 21 (3). Universidade Federal de Lavras: 465–72. doi:&lt;a href=&#34;https://doi.org/10.1590/01047760201521031716&#34;&gt;10.1590/01047760201521031716&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>ANOVA e teste de Tukey</title>
      <link>/anova-e-teste-de-tukey/</link>
      <pubDate>Thu, 08 Sep 2016 00:00:00 +0000</pubDate>
      
      <guid>/anova-e-teste-de-tukey/</guid>
      <description>&lt;p&gt;Análise de variância (ANOVA) e testes de médias são métodos comuns em artigos científicos. Você com certeza já viu aquelas letrinhas indicando a diferença entre tratamentos em algum estudo publicado. Por mais que este método esteja entrando em desuso - há uma tendência em abandonar esse tipo de abordagem estatística - penso que ainda o veremos por muitos anos no meio científico.&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;Como contexto, temos um teste de 5 progênies de eucalipto e queremos avaliar se volume por hectare (nossa variável resposta), difere entre os tratamentos.&lt;/p&gt;
&lt;p&gt;Pois bem, para percebermos a dimensão dos dados e qual a variabilidade de cada tratamento, vamos criar um boxplot (Figura &lt;a href=&#34;#fig:10-boxplot&#34;&gt;1&lt;/a&gt;). Caso você queira saber um pouco mais sobre este tipo de gráfico, veja o &lt;a href=&#34;https://italocegatta.github.io/os-graficos-que-explicam-nossos-dados-boxplot&#34;&gt;post sobre ele&lt;/a&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;if (!require(&amp;quot;pacman&amp;quot;)) install.packages(&amp;quot;pacman&amp;quot;)
pacman::p_load(readr, dplyr, tibble, ggplot2, ggthemes, car, agricolae)&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;dados &amp;lt;- read_csv2(
  &amp;quot;https://github.com/italocegatta/italocegatta.github.io_source/raw/master/content/dados/base_progenie.csv&amp;quot;
)

dados&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 30 x 3
##    repeticao progenie volume
##        &amp;lt;int&amp;gt;    &amp;lt;chr&amp;gt;  &amp;lt;int&amp;gt;
##  1         1        A    212
##  2         2        A    206
##  3         3        A    224
##  4         4        A    289
##  5         5        A    324
##  6         6        A    219
##  7         1        B    108
##  8         2        B    194
##  9         3        B    163
## 10         4        B    111
## # ... with 20 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggplot(dados, aes(progenie, volume)) +
  geom_boxplot() +
  theme_bw() +
  theme_few()&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;figure&#34;&gt;&lt;span id=&#34;fig:10-boxplot&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;/post/2016-09-08-anova-e-teste-de-tukey_files/figure-html/10-boxplot-1.png&#34; alt=&#34;Variabilidade do volume por hectare de cada tratamento.&#34; width=&#34;4000&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figura  1: Variabilidade do volume por hectare de cada tratamento.
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;A ANOVA é um método bastante consolidado no meio acadêmico. Basicamente, este método informa se existe um tratamento discrepante dentre os demais. Entretanto, ele exige que algumas premissas sejam atendidas, como: distribuição normal dos resíduos e homogeneidade de variância.&lt;/p&gt;
&lt;p&gt;Primeiro, vamos utilizar o teste de Levene para verificar se há homogeneidade de variância, ou homocedasticidade. Como o p-valor é maior que 5% não temos evidência significativa para rejeitar a hipótese nula de homogeneidade, ou seja, nossos dados tem homogeneidade de variância.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;leveneTest(volume ~ factor(progenie), data=dados)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Levene&amp;#39;s Test for Homogeneity of Variance (center = median)
##       Df F value  Pr(&amp;gt;F)  
## group  4  2.4677 0.07086 .
##       25                  
## ---
## Signif. codes:  0 &amp;#39;***&amp;#39; 0.001 &amp;#39;**&amp;#39; 0.01 &amp;#39;*&amp;#39; 0.05 &amp;#39;.&amp;#39; 0.1 &amp;#39; &amp;#39; 1&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;O segundo pressuposto é a normalidade dos resíduos. Utilizaremos o teste de Shapiro-Wilk cuja hipótese nula é a de que os dados seguem uma distribuição normal. Como o p-valor é superior ao limite de 5%, podemos aceitar a hipótese nula e considerar nossos dados normais.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;anova &amp;lt;-  aov(volume ~ progenie, data=dados)

shapiro.test(resid(anova))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 
##  Shapiro-Wilk normality test
## 
## data:  resid(anova)
## W = 0.96097, p-value = 0.3279&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Uma vez que os pressupostos foram atendidos, seguiremos para a ANOVA. Note que, caso os testes de Levene e Shapiro-Wilk resultassem em um p-valor significante, ou seja, menor que 5%, teríamos que utilizar outro método estatístico para analisar nossos dados. Nesse caso, uma alternativa é utilizar testes não-paramétricos, uma vez que eles não exigem os pressupostos que acabamos de testar.&lt;/p&gt;
&lt;p&gt;Nossa ANOVA resultou em um p-valor menor que 5%, portanto, temos evidências de que ao menos um tratamento se diferencia dos demais. Isso já é uma resposta, mas pouco acrescenta à nossa pesquisa pois queremos saber quem é este tratamento discrepante. Ou melhor, queremos poder comparar os tratamentos entre si e verificar quais são estatisticamente iguais ou diferentes.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;summary(anova)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##             Df Sum Sq Mean Sq F value   Pr(&amp;gt;F)    
## progenie     4  86726   21681    8.89 0.000131 ***
## Residuals   25  60974    2439                     
## ---
## Signif. codes:  0 &amp;#39;***&amp;#39; 0.001 &amp;#39;**&amp;#39; 0.01 &amp;#39;*&amp;#39; 0.05 &amp;#39;.&amp;#39; 0.1 &amp;#39; &amp;#39; 1&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Para esta abordagem existem alguns testes de médias e cada um tem uma particularidade, mas de longe o mais utilizado é o de Tukey.&lt;/p&gt;
&lt;p&gt;A interpretação do teste de Tukey é simples. Após determinarmos a diferença mínima significativa (ou Honest Significant Difference - HSD), podemos julgar se as médias são iguais ou não. Em termos práticos, esse valor nos dá uma margem de igualdade, pois se a diferença entre dois tratamentos for maior do que isso, os médias são diferentes.&lt;/p&gt;
&lt;p&gt;A análise começa sempre pela maior média, no nosso caso a progênie A (245, 66). Com uma continha rápida, a média do tratamento A menos a diferença mínima significativa &lt;code&gt;245,66 - 83,73 = 161,93&lt;/code&gt;, aceitaremos que um tratamento é igual ao A se a média dele for maior que 161,93. O tratamento subsequente (o segundo do ranking) é a progênie D e como sua média é maior que 161,93 podemos dizer que ela é estatisticamente igual a progênie A.&lt;/p&gt;
&lt;p&gt;As próximas comparações seguem a mesma lógica. Quando registramos que duas médias são iguais, nós as rotulamos com a mesma letra para facilitar a identificação. Veja no fim do output as letras evidenciando a igualdade entre os tratamentos.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;tukey &amp;lt;- HSD.test(anova, &amp;quot;progenie&amp;quot;)

tukey&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## $statistics
##    MSerror Df     Mean       CV      MSD
##   2438.953 25 165.7667 29.79233 83.73866
## 
## $parameters
##    test   name.t ntr StudentizedRange alpha
##   Tukey progenie   5         4.153363  0.05
## 
## $means
##     volume      std r Min Max    Q25   Q50    Q75
## A 245.6667 48.78798 6 206 324 213.75 221.5 272.75
## B 159.6667 49.47996 6 108 236 119.75 154.5 186.25
## C  80.5000 15.60449 6  63 100  70.00  76.5  93.50
## D 190.1667 75.37484 6 100 267 121.75 207.0 251.75
## E 152.8333 37.96534 6 106 210 133.75 141.5 175.50
## 
## $comparison
## NULL
## 
## $groups
##     volume groups
## A 245.6667      a
## D 190.1667     ab
## B 159.6667     bc
## E 152.8333     bc
## C  80.5000      c
## 
## attr(,&amp;quot;class&amp;quot;)
## [1] &amp;quot;group&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Para deixar mais visual ainda, podemos construir um gráfico de barras com a média de cada tratamento e adicionar a sua letra correspondente ao teste de Tukey (Figura &lt;a href=&#34;#fig:10-barras-tukey&#34;&gt;2&lt;/a&gt;).&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;tukey$groups %&amp;gt;% 
  rownames_to_column(var = &amp;quot;trt&amp;quot;) %&amp;gt;% 
  ggplot(aes(reorder(trt, volume, function(x) -mean(x)), volume)) +
    geom_bar(stat = &amp;quot;identity&amp;quot;) +
    geom_text(aes(label = groups), vjust = 1.8, size = 9, color = &amp;quot;white&amp;quot;) +
    labs(x = &amp;quot;Progênies&amp;quot;, y = &amp;quot;Médias&amp;quot;) +
    theme_few()&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;figure&#34;&gt;&lt;span id=&#34;fig:10-barras-tukey&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;/post/2016-09-08-anova-e-teste-de-tukey_files/figure-html/10-barras-tukey-1.png&#34; alt=&#34;Médias dos tratamentos. As letras indicam médias estatisticamente iguais pelo teste de Tukey a 5% de significância.&#34; width=&#34;4000&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figura  2: Médias dos tratamentos. As letras indicam médias estatisticamente iguais pelo teste de Tukey a 5% de significância.
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Caso tenha alguma dúvida ou sugestão sobre o post, fique à vontade para fazer um comentário ou me contactar por Email.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;devtools::session_info()&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  setting  value                       
##  version  R version 3.4.0 (2017-04-21)
##  system   x86_64, mingw32             
##  ui       RTerm                       
##  language (EN)                        
##  collate  Portuguese_Brazil.1252      
##  tz       America/Sao_Paulo           
##  date     2017-09-16                  
## 
##  package      * version    date       source                            
##  agricolae    * 1.2-8      2017-09-12 CRAN (R 3.4.1)                    
##  AlgDesign      1.1-7.3    2014-10-15 CRAN (R 3.4.0)                    
##  assertthat     0.2.0      2017-04-11 CRAN (R 3.4.0)                    
##  backports      1.1.0      2017-05-22 CRAN (R 3.4.0)                    
##  base         * 3.4.0      2017-04-21 local                             
##  bindr          0.1        2016-11-13 CRAN (R 3.4.0)                    
##  bindrcpp       0.2        2017-06-17 CRAN (R 3.4.0)                    
##  blogdown       0.1        2017-08-22 CRAN (R 3.4.1)                    
##  bookdown       0.5        2017-08-20 CRAN (R 3.4.1)                    
##  boot           1.3-19     2017-02-11 CRAN (R 3.4.0)                    
##  car          * 2.1-5      2017-07-04 CRAN (R 3.4.1)                    
##  cluster        2.0.6      2017-03-10 CRAN (R 3.4.0)                    
##  coda           0.19-1     2016-12-08 CRAN (R 3.4.0)                    
##  colorspace     1.3-2      2016-12-14 CRAN (R 3.4.0)                    
##  combinat       0.0-8      2012-10-29 CRAN (R 3.4.0)                    
##  compiler       3.4.0      2017-04-21 local                             
##  curl           2.8.1      2017-07-21 CRAN (R 3.4.1)                    
##  datasets     * 3.4.0      2017-04-21 local                             
##  deldir         0.1-14     2017-04-22 CRAN (R 3.4.0)                    
##  devtools       1.13.3     2017-08-02 CRAN (R 3.4.1)                    
##  digest         0.6.12     2017-01-27 CRAN (R 3.4.0)                    
##  dplyr        * 0.7.3      2017-09-09 CRAN (R 3.4.1)                    
##  evaluate       0.10.1     2017-06-24 CRAN (R 3.4.0)                    
##  expm           0.999-2    2017-03-29 CRAN (R 3.4.0)                    
##  gdata          2.18.0     2017-06-06 CRAN (R 3.4.0)                    
##  ggplot2      * 2.2.1.9000 2017-08-08 Github (tidyverse/ggplot2@53a22cd)
##  ggthemes     * 3.4.0      2017-02-19 CRAN (R 3.4.0)                    
##  glue           1.1.1      2017-06-21 CRAN (R 3.4.0)                    
##  gmodels        2.16.2     2015-07-22 CRAN (R 3.4.0)                    
##  graphics     * 3.4.0      2017-04-21 local                             
##  grDevices    * 3.4.0      2017-04-21 local                             
##  grid           3.4.0      2017-04-21 local                             
##  gtable         0.2.0      2016-02-26 CRAN (R 3.4.0)                    
##  gtools         3.5.0      2015-05-29 CRAN (R 3.4.0)                    
##  highr          0.6        2016-05-09 CRAN (R 3.4.0)                    
##  hms            0.3        2016-11-22 CRAN (R 3.4.0)                    
##  htmltools      0.3.6      2017-04-28 CRAN (R 3.4.0)                    
##  klaR           0.6-12     2014-08-06 CRAN (R 3.4.0)                    
##  knitr          1.17       2017-08-10 CRAN (R 3.4.1)                    
##  labeling       0.3        2014-08-23 CRAN (R 3.4.0)                    
##  lattice        0.20-35    2017-03-25 CRAN (R 3.4.0)                    
##  lazyeval       0.2.0      2016-06-12 CRAN (R 3.4.0)                    
##  LearnBayes     2.15       2014-05-29 CRAN (R 3.4.0)                    
##  lme4           1.1-13     2017-04-19 CRAN (R 3.4.0)                    
##  magrittr       1.5        2014-11-22 CRAN (R 3.4.0)                    
##  MASS           7.3-47     2017-02-26 CRAN (R 3.4.0)                    
##  Matrix         1.2-9      2017-03-14 CRAN (R 3.4.0)                    
##  MatrixModels   0.4-1      2015-08-22 CRAN (R 3.4.0)                    
##  memoise        1.1.0      2017-04-21 CRAN (R 3.4.0)                    
##  methods      * 3.4.0      2017-04-21 local                             
##  mgcv           1.8-17     2017-02-08 CRAN (R 3.4.0)                    
##  minqa          1.2.4      2014-10-09 CRAN (R 3.4.0)                    
##  munsell        0.4.3      2016-02-13 CRAN (R 3.4.0)                    
##  nlme           3.1-131    2017-02-06 CRAN (R 3.4.0)                    
##  nloptr         1.0.4      2014-08-04 CRAN (R 3.4.0)                    
##  nnet           7.3-12     2016-02-02 CRAN (R 3.4.0)                    
##  pacman       * 0.4.6      2017-05-14 CRAN (R 3.4.0)                    
##  parallel       3.4.0      2017-04-21 local                             
##  pbkrtest       0.4-7      2017-03-15 CRAN (R 3.4.0)                    
##  pkgconfig      2.0.1      2017-03-21 CRAN (R 3.4.0)                    
##  plyr           1.8.4      2016-06-08 CRAN (R 3.4.0)                    
##  quantreg       5.33       2017-04-18 CRAN (R 3.4.0)                    
##  R6             2.2.2      2017-06-17 CRAN (R 3.4.0)                    
##  Rcpp           0.12.12    2017-07-15 CRAN (R 3.4.1)                    
##  readr        * 1.1.1      2017-05-16 CRAN (R 3.4.0)                    
##  rlang          0.1.2      2017-08-09 CRAN (R 3.4.1)                    
##  rmarkdown      1.6        2017-06-15 CRAN (R 3.4.0)                    
##  rprojroot      1.2        2017-01-16 CRAN (R 3.4.0)                    
##  scales         0.5.0      2017-08-24 CRAN (R 3.4.1)                    
##  sp             1.2-5      2017-06-29 CRAN (R 3.4.1)                    
##  SparseM        1.77       2017-04-23 CRAN (R 3.4.0)                    
##  spdep          0.6-15     2017-09-01 CRAN (R 3.4.1)                    
##  splines        3.4.0      2017-04-21 local                             
##  stats        * 3.4.0      2017-04-21 local                             
##  stringi        1.1.5      2017-04-07 CRAN (R 3.4.0)                    
##  stringr        1.2.0      2017-02-18 CRAN (R 3.4.0)                    
##  tibble       * 1.3.4      2017-08-22 CRAN (R 3.4.1)                    
##  tools          3.4.0      2017-04-21 local                             
##  utils        * 3.4.0      2017-04-21 local                             
##  withr          2.0.0      2017-08-08 Github (jimhester/withr@190d293)  
##  yaml           2.1.14     2016-11-12 CRAN (R 3.4.0)&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Ajuste de um modelo linear para vários fatores</title>
      <link>/ajuste-de-um-modelo-linear-para-varios-fatores/</link>
      <pubDate>Sat, 27 Aug 2016 00:00:00 +0000</pubDate>
      
      <guid>/ajuste-de-um-modelo-linear-para-varios-fatores/</guid>
      <description>&lt;p&gt;Ajustar um modelo linear ou não linear é algo relativamente simples no R. Mas em muitos casos precisamos ajustá-lo para vários fatores e dependendo da quantidade isso se torna uma tarefa chata. Se você, assim como eu, já precisou fazer isso no Excel, sabe o que é perder mais que uma tarde copiando e colando informações entres abas e planilhas.&lt;br /&gt;
&lt;!-- more --&gt;&lt;/p&gt;
&lt;p&gt;Mas felizmente existe uma máxima muito interessante entre programadores que é:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Don’t Repeat Yourself (DRY)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Depois que eu percebi o quanto a repetição humana gera erros, abracei totalmente o conceito DRY. Acreditem, vocês serão muito mais felizes e eficientes deixando o computador fazer as tarefas repetitivas e chatas.&lt;/p&gt;
&lt;p&gt;Para exemplificar, vamos fazer algo muito comum nas ciências florestais, que é predizer as alturas das árvores. Medir a altura da árvore é uma atividade laboriosa, e há muito tempo se sabe que a altura total das árvores possui alta correlação com o seu diâmetro.&lt;/p&gt;
&lt;p&gt;Utilizaremos mais uma vez os dados do &lt;a href=&#34;www.projetotume.com&#34;&gt;Projeto TUME&lt;/a&gt;, referente a medição de 24 meses do TUME 55 plantado no Mato Grosso do Sul.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;if (!require(&amp;quot;pacman&amp;quot;)) install.packages(&amp;quot;pacman&amp;quot;)
pacman::p_load(readr, dplyr, tidyr, broom, purrr, ggplot2)&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;dados &amp;lt;- read_csv2(
  &amp;quot;https://github.com/italocegatta/italocegatta.github.io_source/raw/master/content/dados/tume_55_24.csv&amp;quot;
)

dados&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 1,881 × 9
##    N_tume I_meses          Esp Parc_m2 N_arv DAP_cm   H_m   Cod  Cod2
##     &amp;lt;int&amp;gt;   &amp;lt;int&amp;gt;        &amp;lt;chr&amp;gt;   &amp;lt;dbl&amp;gt; &amp;lt;int&amp;gt;  &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;int&amp;gt; &amp;lt;int&amp;gt;
## 1      55      24 E_botryoides     600     1    4.1   6.5    NA    NA
## 2      55      24 E_botryoides     600     2    9.7   8.0    NA    NA
## 3      55      24 E_botryoides     600     3     NA    NA     5    NA
## 4      55      24 E_botryoides     600     4    7.6   7.5     2    NA
## 5      55      24 E_botryoides     600     5    3.8   5.0    NA    NA
## 6      55      24 E_botryoides     600     6     NA    NA     1    NA
## 7      55      24 E_botryoides     600     7   12.6   9.0     6    NA
## 8      55      24 E_botryoides     600     8     NA    NA     1    NA
## 9      55      24 E_botryoides     600     9    7.0   8.0    NA    NA
## 10     55      24 E_botryoides     600    10    7.5   7.5    NA    NA
## # ... with 1,871 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Nosso objetivo é simples: ajustar um modelo hipsométrico para cada espécie e em seguida predizer as alturas das árvores. A Figura &lt;a href=&#34;#fig:9-dap-h&#34;&gt;1&lt;/a&gt; mostra a relação que teríamos se fosse ajustado apenas um modelo para todas as espécies.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggplot(dados, aes(DAP_cm, H_m)) +
  geom_point(alpha=0.4) +
  geom_smooth(method=&amp;quot;lm&amp;quot;) +
  theme_bw()&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;figure&#34;&gt;&lt;span id=&#34;fig:9-dap-h&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;/post/2016-08-27-ajuste-de-um-modelo-linear-para-varios-fatores_files/figure-html/9-dap-h-1.png&#34; alt=&#34;Relação entre o diâmetro e a altura sem destinção de espécie.&#34; width=&#34;4000&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figura  1: Relação entre o diâmetro e a altura sem destinção de espécie.
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Mas na prática, a relação diâmetro-altura é diferente entre espécie, como pode ser notado na Figura &lt;a href=&#34;#fig:9-dap-h-spp&#34;&gt;2&lt;/a&gt;. Talvez fique mais evidente a diferença observando os coeficientes dos modelos que serão ajustados a seguir.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggplot(dados, aes(DAP_cm, H_m)) +
  geom_point(alpha=0.4) +
  geom_smooth(method=&amp;quot;lm&amp;quot;) +
  facet_wrap(~Esp) +
  theme_bw()&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;figure&#34;&gt;&lt;span id=&#34;fig:9-dap-h-spp&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;/post/2016-08-27-ajuste-de-um-modelo-linear-para-varios-fatores_files/figure-html/9-dap-h-spp-1.png&#34; alt=&#34;Relação entre o diâmetro e a altura por espécie.&#34; width=&#34;4000&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figura  2: Relação entre o diâmetro e a altura por espécie.
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;A primeira etapa é entender que um data.frame pode conter vários tipos de elementos, como números, caracteres, listas e também outros data.frames. Para isso utilizaremos a função &lt;code&gt;nest()&lt;/code&gt; do pacote &lt;code&gt;tidyr&lt;/code&gt; e aninharemos os dados em função das espécies.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;dados %&amp;gt;%
  group_by(Esp) %&amp;gt;% 
  nest()&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 24 × 2
##                        Esp              data
##                      &amp;lt;chr&amp;gt;            &amp;lt;list&amp;gt;
## 1             E_botryoides &amp;lt;tibble [80 × 8]&amp;gt;
## 2              E_brassiana &amp;lt;tibble [80 × 8]&amp;gt;
## 3          E_camaldulensis &amp;lt;tibble [80 × 8]&amp;gt;
## 4             E_citriodora &amp;lt;tibble [80 × 8]&amp;gt;
## 5              E_cloeziana &amp;lt;tibble [51 × 8]&amp;gt;
## 6       E_dunnii_urophylla &amp;lt;tibble [80 × 8]&amp;gt;
## 7                E_exserta &amp;lt;tibble [80 × 8]&amp;gt;
## 8             E_grandis_AT &amp;lt;tibble [80 × 8]&amp;gt;
## 9  E_grandis_camaldulensis &amp;lt;tibble [80 × 8]&amp;gt;
## 10            E_grandis_CH &amp;lt;tibble [80 × 8]&amp;gt;
## # ... with 14 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Agora podemos ajustar um modelo de regressão para cada espécie utilizando a função &lt;code&gt;map&lt;/code&gt;,do pacote &lt;code&gt;purrr&lt;/code&gt;. Podemos ainda extrair as informações desses modelos com as funções &lt;code&gt;glance&lt;/code&gt;, &lt;code&gt;tidy&lt;/code&gt; e &lt;code&gt;augment&lt;/code&gt;, do pacote &lt;code&gt;broom&lt;/code&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;dados_modl &amp;lt;- dados %&amp;gt;%
  group_by(Esp) %&amp;gt;% 
  nest() %&amp;gt;% 
  mutate(
    ajuste = data %&amp;gt;% map(~ lm(log(H_m) ~ I(1/DAP_cm), data = .)),
    resumo = map(ajuste, glance),
    coef = map(ajuste, tidy),
    resid = map(ajuste, augment)
  )

dados_modl&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 24 × 6
##                        Esp              data   ajuste
##                      &amp;lt;chr&amp;gt;            &amp;lt;list&amp;gt;   &amp;lt;list&amp;gt;
## 1             E_botryoides &amp;lt;tibble [80 × 8]&amp;gt; &amp;lt;S3: lm&amp;gt;
## 2              E_brassiana &amp;lt;tibble [80 × 8]&amp;gt; &amp;lt;S3: lm&amp;gt;
## 3          E_camaldulensis &amp;lt;tibble [80 × 8]&amp;gt; &amp;lt;S3: lm&amp;gt;
## 4             E_citriodora &amp;lt;tibble [80 × 8]&amp;gt; &amp;lt;S3: lm&amp;gt;
## 5              E_cloeziana &amp;lt;tibble [51 × 8]&amp;gt; &amp;lt;S3: lm&amp;gt;
## 6       E_dunnii_urophylla &amp;lt;tibble [80 × 8]&amp;gt; &amp;lt;S3: lm&amp;gt;
## 7                E_exserta &amp;lt;tibble [80 × 8]&amp;gt; &amp;lt;S3: lm&amp;gt;
## 8             E_grandis_AT &amp;lt;tibble [80 × 8]&amp;gt; &amp;lt;S3: lm&amp;gt;
## 9  E_grandis_camaldulensis &amp;lt;tibble [80 × 8]&amp;gt; &amp;lt;S3: lm&amp;gt;
## 10            E_grandis_CH &amp;lt;tibble [80 × 8]&amp;gt; &amp;lt;S3: lm&amp;gt;
## # ... with 14 more rows, and 3 more variables: resumo &amp;lt;list&amp;gt;, coef &amp;lt;list&amp;gt;,
## #   resid &amp;lt;list&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Da mesma forma que aninhamos os dados por espécie, podemos retorná-los para o formato original, mas agora mostrando apenas as informações que realmente interessam.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;dados_modl %&amp;gt;%
  select(Esp, resumo) %&amp;gt;% 
  unnest(resumo)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 24 × 12
##                        Esp r.squared adj.r.squared      sigma statistic
##                      &amp;lt;chr&amp;gt;     &amp;lt;dbl&amp;gt;         &amp;lt;dbl&amp;gt;      &amp;lt;dbl&amp;gt;     &amp;lt;dbl&amp;gt;
## 1             E_botryoides 0.7865503     0.7832152 0.13638082 235.83647
## 2              E_brassiana 0.7034805     0.6984547 0.16015749 139.97510
## 3          E_camaldulensis 0.7193692     0.7156767 0.12781229 194.81849
## 4             E_citriodora 0.6017939     0.5958506 0.10226763 101.25459
## 5              E_cloeziana 0.2595328     0.2339995 0.16724765  10.16446
## 6       E_dunnii_urophylla 0.7199293     0.7159283 0.16115569 179.93693
## 7                E_exserta 0.5897407     0.5837949 0.19572456  99.18630
## 8             E_grandis_AT 0.7472094     0.7438832 0.07718312 224.64407
## 9  E_grandis_camaldulensis 0.8290924     0.8265415 0.16085772 325.02460
## 10            E_grandis_CH 0.7764890     0.7731530 0.10465726 232.76148
## # ... with 14 more rows, and 7 more variables: p.value &amp;lt;dbl&amp;gt;, df &amp;lt;int&amp;gt;,
## #   logLik &amp;lt;dbl&amp;gt;, AIC &amp;lt;dbl&amp;gt;, BIC &amp;lt;dbl&amp;gt;, deviance &amp;lt;dbl&amp;gt;, df.residual &amp;lt;int&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;dados_modl %&amp;gt;%
  select(Esp, coef ) %&amp;gt;% 
  unnest(coef)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 48 × 6
##                Esp        term  estimate  std.error  statistic
##              &amp;lt;chr&amp;gt;       &amp;lt;chr&amp;gt;     &amp;lt;dbl&amp;gt;      &amp;lt;dbl&amp;gt;      &amp;lt;dbl&amp;gt;
## 1     E_botryoides (Intercept)  2.633365 0.04223569  62.349272
## 2     E_botryoides I(1/DAP_cm) -4.129688 0.26891300 -15.356968
## 3      E_brassiana (Intercept)  2.014323 0.05110864  39.412563
## 4      E_brassiana I(1/DAP_cm) -2.373711 0.20063302 -11.831107
## 5  E_camaldulensis (Intercept)  2.727702 0.04605191  59.231027
## 6  E_camaldulensis I(1/DAP_cm) -4.792441 0.34335365 -13.957740
## 7     E_citriodora (Intercept)  2.553408 0.05513037  46.315809
## 8     E_citriodora I(1/DAP_cm) -3.802655 0.37790230 -10.062534
## 9      E_cloeziana (Intercept)  2.323552 0.11578912  20.067098
## 10     E_cloeziana I(1/DAP_cm) -2.842311 0.89151651  -3.188176
## # ... with 38 more rows, and 1 more variables: p.value &amp;lt;dbl&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;dados_modl %&amp;gt;%
  select(Esp, resid) %&amp;gt;% 
  unnest(resid)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 1,633 × 11
##             Esp .rownames log.H_m. I.1.DAP_cm.  .fitted    .se.fit
##           &amp;lt;chr&amp;gt;     &amp;lt;chr&amp;gt;    &amp;lt;dbl&amp;gt;       &amp;lt;dbl&amp;gt;    &amp;lt;dbl&amp;gt;      &amp;lt;dbl&amp;gt;
## 1  E_botryoides         1 1.871802  0.24390244 1.626124 0.03165108
## 2  E_botryoides         2 2.079442  0.10309278 2.207624 0.02008843
## 3  E_botryoides         4 2.014903  0.13157895 2.089985 0.01712280
## 4  E_botryoides         5 1.609438  0.26315789 1.546605 0.03614528
## 5  E_botryoides         7 2.197225  0.07936508 2.305612 0.02418794
## 6  E_botryoides         9 2.079442  0.14285714 2.043409 0.01679076
## 7  E_botryoides        10 2.014903  0.13333333 2.082740 0.01703615
## 8  E_botryoides        13 1.609438  0.16666667 1.945083 0.01784853
## 9  E_botryoides        14 2.302585  0.09803922 2.228493 0.02086574
## 10 E_botryoides        15 2.140066  0.12048193 2.135812 0.01795064
## # ... with 1,623 more rows, and 5 more variables: .resid &amp;lt;dbl&amp;gt;,
## #   .hat &amp;lt;dbl&amp;gt;, .sigma &amp;lt;dbl&amp;gt;, .cooksd &amp;lt;dbl&amp;gt;, .std.resid &amp;lt;dbl&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Após o ajuste do modelo, temos de predizer as alturas. O único adendo para esse comando é que precisamos fazer em duas etapas, uma utilizando a função &lt;code&gt;predict&lt;/code&gt; e outra para trazer o valor predito para a escala natural, pois o modelo foi ajustado na escala logarítmica.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;dados_pred &amp;lt;- dados_modl %&amp;gt;% 
  mutate(
    hpred = map2(ajuste, data, predict),
    hpred = map(hpred, exp)
  ) %&amp;gt;%
  select(Esp, data, hpred)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Por fim, temos de volta um data.frame com as alturas preditas. Por mais que o ajuste tenha ficado razoável, na prática a construção de modelos de relação hipsométrica envolvem outras etapas e um maior rigor em termos estatísticos.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;dados_compl &amp;lt;- dados_pred %&amp;gt;%
  unnest(hpred, data)

dados_compl&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 1,881 × 10
##             Esp     hpred N_tume I_meses Parc_m2 N_arv DAP_cm   H_m   Cod
##           &amp;lt;chr&amp;gt;     &amp;lt;dbl&amp;gt;  &amp;lt;int&amp;gt;   &amp;lt;int&amp;gt;   &amp;lt;dbl&amp;gt; &amp;lt;int&amp;gt;  &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;int&amp;gt;
## 1  E_botryoides  5.084129     55      24     600     1    4.1   6.5    NA
## 2  E_botryoides  9.094080     55      24     600     2    9.7   8.0    NA
## 3  E_botryoides        NA     55      24     600     3     NA    NA     5
## 4  E_botryoides  8.084791     55      24     600     4    7.6   7.5     2
## 5  E_botryoides  4.695500     55      24     600     5    3.8   5.0    NA
## 6  E_botryoides        NA     55      24     600     6     NA    NA     1
## 7  E_botryoides 10.030312     55      24     600     7   12.6   9.0     6
## 8  E_botryoides        NA     55      24     600     8     NA    NA     1
## 9  E_botryoides  7.716873     55      24     600     9    7.0   8.0    NA
## 10 E_botryoides  8.026428     55      24     600    10    7.5   7.5    NA
## # ... with 1,871 more rows, and 1 more variables: Cod2 &amp;lt;int&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Caso tenha alguma dúvida ou sugestão sobre o post, fique à vontade para fazer um comentário ou me contactar por Email.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;devtools::session_info()&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  setting  value                       
##  version  R version 3.3.3 (2017-03-06)
##  system   x86_64, mingw32             
##  ui       RTerm                       
##  language (EN)                        
##  collate  Portuguese_Brazil.1252      
##  tz       America/Sao_Paulo           
##  date     2017-04-08                  
## 
##  package    * version date       source                           
##  assertthat   0.1     2013-12-06 CRAN (R 3.3.2)                   
##  backports    1.0.5   2017-01-18 CRAN (R 3.3.2)                   
##  blogdown     0.0.25  2017-03-23 Github (rstudio/blogdown@1c10d16)
##  bookdown     0.3.14  2017-03-23 Github (rstudio/bookdown@f427fdf)
##  broom      * 0.4.2   2017-02-13 CRAN (R 3.3.2)                   
##  colorspace   1.3-2   2016-12-14 CRAN (R 3.3.2)                   
##  curl         2.3     2016-11-24 CRAN (R 3.3.2)                   
##  DBI          0.5-1   2016-09-10 CRAN (R 3.3.2)                   
##  devtools     1.12.0  2016-06-24 CRAN (R 3.3.3)                   
##  digest       0.6.12  2017-01-27 CRAN (R 3.3.2)                   
##  dplyr      * 0.5.0   2016-06-24 CRAN (R 3.3.2)                   
##  evaluate     0.10    2016-10-11 CRAN (R 3.3.3)                   
##  foreign      0.8-67  2016-09-13 CRAN (R 3.3.3)                   
##  ggplot2    * 2.2.1   2016-12-30 CRAN (R 3.3.2)                   
##  gtable       0.2.0   2016-02-26 CRAN (R 3.3.2)                   
##  highr        0.6     2016-05-09 CRAN (R 3.3.3)                   
##  htmltools    0.3.5   2016-03-21 CRAN (R 3.3.3)                   
##  knitr        1.15.1  2016-11-22 CRAN (R 3.3.3)                   
##  labeling     0.3     2014-08-23 CRAN (R 3.3.2)                   
##  lattice      0.20-34 2016-09-06 CRAN (R 3.3.3)                   
##  lazyeval     0.2.0   2016-06-12 CRAN (R 3.3.2)                   
##  magrittr     1.5     2014-11-22 CRAN (R 3.3.2)                   
##  memoise      1.0.0   2016-01-29 CRAN (R 3.3.3)                   
##  mnormt       1.5-5   2016-10-15 CRAN (R 3.3.2)                   
##  munsell      0.4.3   2016-02-13 CRAN (R 3.3.2)                   
##  nlme         3.1-131 2017-02-06 CRAN (R 3.3.3)                   
##  pacman     * 0.4.1   2016-03-30 CRAN (R 3.3.3)                   
##  plyr         1.8.4   2016-06-08 CRAN (R 3.3.2)                   
##  psych        1.6.12  2017-01-08 CRAN (R 3.3.2)                   
##  purrr      * 0.2.2   2016-06-18 CRAN (R 3.3.2)                   
##  R6           2.2.0   2016-10-05 CRAN (R 3.3.2)                   
##  Rcpp         0.12.9  2017-01-14 CRAN (R 3.3.2)                   
##  readr      * 1.0.0   2016-08-03 CRAN (R 3.3.2)                   
##  reshape2     1.4.2   2016-10-22 CRAN (R 3.3.2)                   
##  rmarkdown    1.3     2016-12-21 CRAN (R 3.3.3)                   
##  rprojroot    1.2     2017-01-16 CRAN (R 3.3.3)                   
##  scales       0.4.1   2016-11-09 CRAN (R 3.3.2)                   
##  stringi      1.1.2   2016-10-01 CRAN (R 3.3.2)                   
##  stringr      1.2.0   2017-02-18 CRAN (R 3.3.2)                   
##  tibble       1.2     2016-08-26 CRAN (R 3.3.2)                   
##  tidyr      * 0.6.1   2017-01-10 CRAN (R 3.3.2)                   
##  withr        1.0.2   2016-06-20 CRAN (R 3.3.3)                   
##  yaml         2.1.14  2016-11-12 CRAN (R 3.3.3)&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Análise de componentes principais</title>
      <link>/analise-de-componentes-principais/</link>
      <pubDate>Mon, 01 Aug 2016 00:00:00 +0000</pubDate>
      
      <guid>/analise-de-componentes-principais/</guid>
      <description>&lt;p&gt;Quando temos dados multivariados, a análise de componentes principais (PCA) é um recurso muito interessante e relativamente simples, em termos de conceito teórico e interpretação prática. Para exemplificar, vamos trabalhar com os dados climáticos de algumas cidades brasileiras. Os dados climáticos foram compilados a partir de estações automáticas do &lt;a href=&#34;http://www.inmet.gov.br/portal/index.php?r=estacoes/estacoesautomaticas&#34;&gt;INMET&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;No R, temos a facilidade de poder fazer o cálculo dos componentes principais e logo em seguida poder apresentá-los em gráficos elegantes e de fácil entendimento. O Objetivo deste post é apresentar uma rápida demonstração de como rodar um PCA e gerar os gráficos derivados.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;if (!require(&amp;quot;pacman&amp;quot;)) install.packages(&amp;quot;pacman&amp;quot;)
pacman::p_load(readr, dplyr, ggplot2, ggrepel)
pacman::p_load_gh(&amp;quot;vqv/ggbiplot&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;dados &amp;lt;- read_csv2(
  &amp;quot;https://github.com/italocegatta/italocegatta.github.io_source/raw/master/content/dados/base_clima.csv&amp;quot;
)

print(dados, n=31)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 31 × 6
##                Cidade Koppen  Tmed    PPT    ETP   DEF
##                 &amp;lt;chr&amp;gt;  &amp;lt;chr&amp;gt; &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt;
## 1        Bom Despacho    Cwa 22.64  801.8 1112.1 238.4
## 2         Niquelandia     Aw 24.63  562.2 1372.5 655.7
## 3             Arapoti    Cfb 18.48 1367.0  669.7  25.4
## 4           Rio Verde     Aw 23.34 1244.8 1196.2 425.4
## 5        Belo Oriente     Aw 22.56 1053.5 1104.8 125.4
## 6            Guanhaes    Cwa 20.62  817.6  866.0 187.9
## 7     Eldorado do Sul    Cfa 20.58 1787.4  858.7  10.7
## 8         Sao Gabriel    Cfa 20.23 1782.6  927.4   2.8
## 9           Inhambupe     As 24.23  715.2 1318.4 607.4
## 10           Botucatu    Cfb 21.94 1012.8 1030.0 184.1
## 11     Estrela do Sul    Cwa 23.41 1133.6 1208.4 206.2
## 12               Buri    Cfa 19.98 1404.4  805.0   3.6
## 13          Inocencia     Am 24.48 1019.6 1374.8 389.2
## 14    Chapadao do Sul     Am 22.62 1026.6 1097.7 325.8
## 15            Aracruz     Aw 23.89  849.4 1276.9 335.5
## 16        Tres Lagoas     Aw 25.23  943.8 1501.6 538.4
## 17        Tres Marias     Aw 22.25  811.4 1052.1 404.8
## 18              Peixe     Aw 26.29 1207.6 1630.3 674.5
## 19         Mogi Guacu    Cwa 22.40  923.6 1100.4 209.9
## 20 Brejinho de Nazare     Aw 25.88 1507.2 1563.4 495.7
## 21      Monte Dourado     Am 27.38 2528.7 1820.6 529.7
## 22     Otacilio Costa    Cfb 16.91 2092.2  547.8   0.0
## 23     Telemaco Borba    Cfa 18.48 1367.0  669.7  28.0
## 24             Borebi    Cfa 22.12  947.6 1057.8 200.9
## 25   Coracao de Jesus     As 23.91  413.4 1275.1 743.7
## 26     Antonio Olinto    Cfb 17.67 1740.2  615.8   0.0
## 27        Tres Barras    Cfb 17.30 1122.8  581.0  16.5
## 28      Urbano Santos     Aw 27.05 1437.8 1750.3 935.0
## 29          Eunapolis     Am 22.88 1419.2 1127.6  31.2
## 30         Itagimirim     Aw 25.18  490.6 1460.3 869.5
## 31           Bocaiuva     Aw 23.91  413.4 1275.5 641.8&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A análise de componentes principais nos mostra o quanto cada grupo de variáveis explicam a variabilidade total dados. No nosso caso, o primeiro componente responde por 72% da variabilidade e tem efeito quase que igual da temperatura (Tmed), evapotranspiração (ETP) e déficit hídrico (DEF). O segundo componente é majoritariamente o efeito da chuva (PPT). Juntos, os dois componente explicam 95% dos dados.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;pca &amp;lt;- select(dados, Tmed:DEF) %&amp;gt;%
  princomp(cor = T)

summary(pca); loadings(pca)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Importance of components:
##                           Comp.1    Comp.2     Comp.3       Comp.4
## Standard deviation     1.7007490 0.9709348 0.40137904 0.0602784852
## Proportion of Variance 0.7231368 0.2356786 0.04027628 0.0009083739
## Cumulative Proportion  0.7231368 0.9588153 0.99909163 1.0000000000&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 
## Loadings:
##      Comp.1 Comp.2 Comp.3 Comp.4
## Tmed  0.567 -0.201 -0.437  0.668
## PPT  -0.241 -0.933  0.251       
## ETP   0.561 -0.284 -0.261 -0.732
## DEF   0.553         0.823       
## 
##                Comp.1 Comp.2 Comp.3 Comp.4
## SS loadings      1.00   1.00   1.00   1.00
## Proportion Var   0.25   0.25   0.25   0.25
## Cumulative Var   0.25   0.50   0.75   1.00&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A Figura &lt;a href=&#34;#fig:8-pca&#34;&gt;1&lt;/a&gt; ajuda-nos a visualizar a disposição das cidades em função dos dois principais componentes. Se analisarmos por quadrantes, podemos agrupar as cidades de clima semelhante e ainda verificar a relação com as variáveis de clima. As setas indicam o efeito positivo ou negativo da variável. Por exemplo, o quadrante Q4 é caracterizado por valores altos de chuva e praticamente nenhum deficit hídrico. No oposto, temos o Q2 com baixa precipitação e alto déficit hídrico.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggbiplot(pca) +
  geom_point() +
  geom_vline(xintercept = 0, size = 1.2, linetype = 6) +
  geom_hline(yintercept = 0, size = 1.2, linetype = 6) +
  geom_label_repel(aes(label = dados$Cidade), size = 3, nudge_x = .2) +
  annotate(
    &amp;quot;text&amp;quot;,
    x = c(-2, 2, 2, -2),
    y = c(2, 2, -2, -2), 
    label = paste0(&amp;quot;Q&amp;quot;, 1:4), size = 6
  ) +
  lims(x = c(-2,2), y = c(-2,2)) +
  theme_bw()&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;figure&#34;&gt;&lt;span id=&#34;fig:8-pca&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;/post/2016-08-01-analise-de-componentes-principais_files/figure-html/8-pca-1.png&#34; alt=&#34;Representação gráfica dos componentes principais.&#34; width=&#34;3200&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figura  1: Representação gráfica dos componentes principais.
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Como também temos a informação do clima Koppen, podemos colorir o gráfico em função deste atributo (Figura &lt;a href=&#34;#fig:8-pca-koppen&#34;&gt;2&lt;/a&gt;).&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggbiplot(pca) +
  geom_point(aes(color = dados$Koppen)) +
  geom_vline(xintercept = 0, size = 1.2, linetype = 6) +
  geom_hline(yintercept = 0, size = 1.2, linetype = 6) +
  geom_label_repel(
    aes(color = dados$Koppen, label = dados$Cidade),
    size = 3, nudge_x = .2, show.legend = F
  ) +
  lims(x = c(-2,2), y = c(-2,2)) +
  scale_color_brewer(&amp;quot;Clima Koppen&amp;quot;, palette = &amp;quot;Dark2&amp;quot;) +
  theme_bw()+
  theme(legend.position = &amp;quot;top&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;figure&#34;&gt;&lt;span id=&#34;fig:8-pca-koppen&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;/post/2016-08-01-analise-de-componentes-principais_files/figure-html/8-pca-koppen-1.png&#34; alt=&#34;Representação gráfica dos componentes principais com classificação Koppen.&#34; width=&#34;3200&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figura  2: Representação gráfica dos componentes principais com classificação Koppen.
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Caso tenha alguma dúvida ou sugestão sobre o post, fique à vontade para fazer um comentário ou me contactar por Email.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;devtools::session_info()&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  setting  value                       
##  version  R version 3.3.3 (2017-03-06)
##  system   x86_64, mingw32             
##  ui       RTerm                       
##  language (EN)                        
##  collate  Portuguese_Brazil.1252      
##  tz       America/Sao_Paulo           
##  date     2017-04-08                  
## 
##  package      * version date       source                           
##  assertthat     0.1     2013-12-06 CRAN (R 3.3.2)                   
##  backports      1.0.5   2017-01-18 CRAN (R 3.3.2)                   
##  blogdown       0.0.25  2017-03-23 Github (rstudio/blogdown@1c10d16)
##  bookdown       0.3.14  2017-03-23 Github (rstudio/bookdown@f427fdf)
##  colorspace     1.3-2   2016-12-14 CRAN (R 3.3.2)                   
##  curl           2.3     2016-11-24 CRAN (R 3.3.2)                   
##  DBI            0.5-1   2016-09-10 CRAN (R 3.3.2)                   
##  devtools       1.12.0  2016-06-24 CRAN (R 3.3.3)                   
##  digest         0.6.12  2017-01-27 CRAN (R 3.3.2)                   
##  dplyr        * 0.5.0   2016-06-24 CRAN (R 3.3.2)                   
##  evaluate       0.10    2016-10-11 CRAN (R 3.3.3)                   
##  ggbiplot     * 0.55    2017-03-24 Github (vqv/ggbiplot@7325e88)    
##  ggplot2      * 2.2.1   2016-12-30 CRAN (R 3.3.2)                   
##  ggrepel      * 0.6.5   2016-11-24 CRAN (R 3.3.3)                   
##  gtable         0.2.0   2016-02-26 CRAN (R 3.3.2)                   
##  highr          0.6     2016-05-09 CRAN (R 3.3.3)                   
##  htmltools      0.3.5   2016-03-21 CRAN (R 3.3.3)                   
##  knitr          1.15.1  2016-11-22 CRAN (R 3.3.3)                   
##  labeling       0.3     2014-08-23 CRAN (R 3.3.2)                   
##  lazyeval       0.2.0   2016-06-12 CRAN (R 3.3.2)                   
##  magrittr       1.5     2014-11-22 CRAN (R 3.3.2)                   
##  memoise        1.0.0   2016-01-29 CRAN (R 3.3.3)                   
##  munsell        0.4.3   2016-02-13 CRAN (R 3.3.2)                   
##  pacman       * 0.4.1   2016-03-30 CRAN (R 3.3.3)                   
##  plyr         * 1.8.4   2016-06-08 CRAN (R 3.3.2)                   
##  R6             2.2.0   2016-10-05 CRAN (R 3.3.2)                   
##  RColorBrewer   1.1-2   2014-12-07 CRAN (R 3.3.2)                   
##  Rcpp           0.12.9  2017-01-14 CRAN (R 3.3.2)                   
##  readr        * 1.0.0   2016-08-03 CRAN (R 3.3.2)                   
##  rmarkdown      1.3     2016-12-21 CRAN (R 3.3.3)                   
##  rprojroot      1.2     2017-01-16 CRAN (R 3.3.3)                   
##  scales       * 0.4.1   2016-11-09 CRAN (R 3.3.2)                   
##  stringi        1.1.2   2016-10-01 CRAN (R 3.3.2)                   
##  stringr        1.2.0   2017-02-18 CRAN (R 3.3.2)                   
##  tibble         1.2     2016-08-26 CRAN (R 3.3.2)                   
##  withr          1.0.2   2016-06-20 CRAN (R 3.3.3)                   
##  yaml           2.1.14  2016-11-12 CRAN (R 3.3.3)&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Os gráficos que explicam nossos dados (histograma)</title>
      <link>/os-graficos-que-explicam-nossos-dados-histograma/</link>
      <pubDate>Fri, 15 Jul 2016 00:00:00 +0000</pubDate>
      
      <guid>/os-graficos-que-explicam-nossos-dados-histograma/</guid>
      <description>&lt;p&gt;Histogramas são usados para mostrar a frequência com que uma variável ocorre. Isto é muito interessante para mostrar qual a distribuição dos seus dados e podemos apresentar em forma de frequência absoluta, relativa, percentual e acumulada. Para exemplificar este tipo gráfico, vamos utilizar os dados de inventário de uma propriedade fictícia na Amazônia. Estes dados são meramente ilustrativos e não tem valor real. O objetivo aqui é apresentar algumas particularidades da construção de gráficos de barras no R e facilitar a vida de quem quer abandonar os gráficos do Excel.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;if (!require(&amp;quot;pacman&amp;quot;)) install.packages(&amp;quot;pacman&amp;quot;)
pacman::p_load(readr, dplyr, ggplot2, ggthemes)&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;dados &amp;lt;- read_csv2(
  &amp;quot;https://raw.githubusercontent.com/italocegatta/italocegatta.github.io_source/master/content/dados/base_amazonia.csv&amp;quot;
)

dados&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 276 x 7
##             Especie              Nome_cientifico Comercial   DAP  HCom
##               &amp;lt;chr&amp;gt;                        &amp;lt;chr&amp;gt;     &amp;lt;chr&amp;gt; &amp;lt;int&amp;gt; &amp;lt;int&amp;gt;
##  1 NAO IDENTIFICADA             Nao Identificada       Nao    20    10
##  2           EMBIRA                Lecythidaceae       Nao    34    13
##  3 NAO IDENTIFICADA             Nao Identificada       Nao    18     6
##  4         SUCUPIRA   Leguminosae-Papilionoideae       Nao    18     7
##  5           CANELA                    Lauraceae       Nao    24    10
##  6            TACHI                Lecythidaceae       Sim    21    10
##  7      ENVIRA CAJU                   Annonaceae       Nao    20    11
##  8            JUTAI Leguminosae-Caesalpinioideae       Nao    38    13
##  9          CATUABA                 Vochysiaceae       Sim    57    13
## 10 NAO IDENTIFICADA             Nao Identificada       Nao    22     7
## # ... with 266 more rows, and 2 more variables: Volume &amp;lt;dbl&amp;gt;, QF &amp;lt;int&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Primeiro vamos ver qual a distribuição dos indivíduos em classes de diâmetro. A Figura &lt;a href=&#34;#fig:7-hist-dap&#34;&gt;1&lt;/a&gt; mostra a frequência de indivíduos em classes de diâmetro de 10 cm. Visivelmente, podemos ver que a faixa de diâmetro mais frequente está entre 15 e 35 cm (centro de classe 20 e 30 cm, respectivamente).&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggplot(dados, aes(DAP)) +
  geom_histogram(binwidth = 10, color = &amp;quot;white&amp;quot;) +
  labs(x = &amp;quot;Diâmetro (cm)&amp;quot;, y = &amp;quot;Frequência (arv/ha)&amp;quot;) +
  scale_x_continuous(breaks = seq(0, 100,10)) +
  theme_few()&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;figure&#34;&gt;&lt;span id=&#34;fig:7-hist-dap&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;/post/2016-07-15-os-graficos-que-explicam-nossos-dados-histograma_files/figure-html/7-hist-dap-1.png&#34; alt=&#34;Histograma com a frequência absoluta por classes de diâmetro.&#34; width=&#34;4000&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figura  1: Histograma com a frequência absoluta por classes de diâmetro.
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Mas, e quanto às espécies comerciais? Como elas estão distribuídas? A Figura &lt;a href=&#34;#fig:7-hist-dap-comerc&#34;&gt;2&lt;/a&gt; faz esta diferenciação. E lembre-se, no manejo florestal da Amazônia só é permitido a exploração de árvores com diâmetro maior que 50 cm.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggplot(dados, aes(DAP, fill = Comercial)) +
  geom_histogram(binwidth = 10, color = &amp;quot;white&amp;quot;, alpha = 0.5) +
  labs(x = &amp;quot;Diâmetro (cm)&amp;quot;, y = &amp;quot;Frequência (arv/ha)&amp;quot;) +
  scale_x_continuous(breaks = seq(0, 100,10)) +
  theme_few() +
  theme(legend.position = c(.9, .9)) +
  scale_fill_hue(&amp;quot;Comercial?&amp;quot;, labels = c(&amp;quot;Não&amp;quot;, &amp;quot;Sim&amp;quot;))&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;figure&#34;&gt;&lt;span id=&#34;fig:7-hist-dap-comerc&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;/post/2016-07-15-os-graficos-que-explicam-nossos-dados-histograma_files/figure-html/7-hist-dap-comerc-1.png&#34; alt=&#34;Histograma com a frequência absoluta por classes de diâmetro e separação pelo fator de árvores de interesse comercial.&#34; width=&#34;4000&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figura  2: Histograma com a frequência absoluta por classes de diâmetro e separação pelo fator de árvores de interesse comercial.
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Vamos melhorar um pouco mais a informação sob o ponto de vista da exploração: qual a frequência de indivíduos que são de interesse comercial e tem diâmetro mais que 50 cm? (Figura &lt;a href=&#34;#fig:7-hist-vol-exp&#34;&gt;3&lt;/a&gt;).&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggplot(dados, aes(Volume, fill = DAP &amp;gt; 50 &amp;amp; Comercial == &amp;quot;Sim&amp;quot;)) +
  geom_histogram(binwidth = 0.5, color = &amp;quot;white&amp;quot;, alpha = 0.5) +
  labs(x = Volume~individual ~ (m^3 / arv), y = &amp;quot;Frequência (arv/ha)&amp;quot;) +
  scale_y_continuous(breaks = seq(0, 150, 20)) +
  scale_x_continuous(breaks = seq(0, 10, 0.5)) +
  theme_few()  +
  theme(legend.position = c(.9, .9)) +
  scale_fill_hue(&amp;quot;Pode explorar?&amp;quot;, labels = c(&amp;quot;Não&amp;quot;, &amp;quot;Sim&amp;quot;))&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;figure&#34;&gt;&lt;span id=&#34;fig:7-hist-vol-exp&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;/post/2016-07-15-os-graficos-que-explicam-nossos-dados-histograma_files/figure-html/7-hist-vol-exp-1.png&#34; alt=&#34;Histograma com a frequência absoluta por classes de volume individual e separação pelo fator de árvores de interesse comercial e diâmetro maior que 50 cm.&#34; width=&#34;4000&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figura  3: Histograma com a frequência absoluta por classes de volume individual e separação pelo fator de árvores de interesse comercial e diâmetro maior que 50 cm.
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Se quisermos ainda apresentar o gráfico em termos das frequências relativas, podemos fazer a seguinte modificação, conforme a Figura &lt;a href=&#34;#fig:7-hist-vol-exp-rel&#34;&gt;4&lt;/a&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggplot(dados, aes(Volume, fill = DAP &amp;gt; 50 &amp;amp; Comercial == &amp;quot;Sim&amp;quot;)) +
  geom_histogram(
    aes(y = ..count../sum(..count..)),
    binwidth = 0.5, color = &amp;quot;white&amp;quot;, alpha = 0.5
  ) +
  labs(x =  Volume~individual ~ (m^3 / arv), y = &amp;quot;Frequência (arv/ha)&amp;quot;) +
  scale_y_continuous(breaks = seq(0, .5, 0.05), labels = scales::percent) +
  scale_x_continuous(breaks = seq(0, 10, 0.5)) +
  theme_few()  +
  theme(legend.position = c(.9, .9)) +
  scale_fill_hue(&amp;quot;Pode explorar?&amp;quot;, labels = c(&amp;quot;Não&amp;quot;, &amp;quot;Sim&amp;quot;))&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;figure&#34;&gt;&lt;span id=&#34;fig:7-hist-vol-exp-rel&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;/post/2016-07-15-os-graficos-que-explicam-nossos-dados-histograma_files/figure-html/7-hist-vol-exp-rel-1.png&#34; alt=&#34;Histograma com a frequência relativa por classes de volume individual e separação pelo fator de árvores de interesse comercial e diâmetro maior que 50 cm.&#34; width=&#34;4000&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figura  4: Histograma com a frequência relativa por classes de volume individual e separação pelo fator de árvores de interesse comercial e diâmetro maior que 50 cm.
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Caso tenha alguma dúvida ou sugestão sobre o post, fique à vontade para fazer um comentário ou me contactar por Email.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;devtools::session_info()&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  setting  value                       
##  version  R version 3.4.0 (2017-04-21)
##  system   x86_64, mingw32             
##  ui       RTerm                       
##  language (EN)                        
##  collate  Portuguese_Brazil.1252      
##  tz       America/Sao_Paulo           
##  date     2017-09-16                  
## 
##  package    * version    date       source                            
##  assertthat   0.2.0      2017-04-11 CRAN (R 3.4.0)                    
##  backports    1.1.0      2017-05-22 CRAN (R 3.4.0)                    
##  base       * 3.4.0      2017-04-21 local                             
##  bindr        0.1        2016-11-13 CRAN (R 3.4.0)                    
##  bindrcpp     0.2        2017-06-17 CRAN (R 3.4.0)                    
##  blogdown     0.1        2017-08-22 CRAN (R 3.4.1)                    
##  bookdown     0.5        2017-08-20 CRAN (R 3.4.1)                    
##  colorspace   1.3-2      2016-12-14 CRAN (R 3.4.0)                    
##  compiler     3.4.0      2017-04-21 local                             
##  curl         2.8.1      2017-07-21 CRAN (R 3.4.1)                    
##  datasets   * 3.4.0      2017-04-21 local                             
##  devtools     1.13.3     2017-08-02 CRAN (R 3.4.1)                    
##  digest       0.6.12     2017-01-27 CRAN (R 3.4.0)                    
##  dplyr      * 0.7.3      2017-09-09 CRAN (R 3.4.1)                    
##  evaluate     0.10.1     2017-06-24 CRAN (R 3.4.0)                    
##  ggplot2    * 2.2.1.9000 2017-08-08 Github (tidyverse/ggplot2@53a22cd)
##  ggthemes   * 3.4.0      2017-02-19 CRAN (R 3.4.0)                    
##  glue         1.1.1      2017-06-21 CRAN (R 3.4.0)                    
##  graphics   * 3.4.0      2017-04-21 local                             
##  grDevices  * 3.4.0      2017-04-21 local                             
##  grid         3.4.0      2017-04-21 local                             
##  gtable       0.2.0      2016-02-26 CRAN (R 3.4.0)                    
##  highr        0.6        2016-05-09 CRAN (R 3.4.0)                    
##  hms          0.3        2016-11-22 CRAN (R 3.4.0)                    
##  htmltools    0.3.6      2017-04-28 CRAN (R 3.4.0)                    
##  knitr        1.17       2017-08-10 CRAN (R 3.4.1)                    
##  labeling     0.3        2014-08-23 CRAN (R 3.4.0)                    
##  lazyeval     0.2.0      2016-06-12 CRAN (R 3.4.0)                    
##  magrittr     1.5        2014-11-22 CRAN (R 3.4.0)                    
##  memoise      1.1.0      2017-04-21 CRAN (R 3.4.0)                    
##  methods    * 3.4.0      2017-04-21 local                             
##  munsell      0.4.3      2016-02-13 CRAN (R 3.4.0)                    
##  pacman     * 0.4.6      2017-05-14 CRAN (R 3.4.0)                    
##  pkgconfig    2.0.1      2017-03-21 CRAN (R 3.4.0)                    
##  plyr         1.8.4      2016-06-08 CRAN (R 3.4.0)                    
##  R6           2.2.2      2017-06-17 CRAN (R 3.4.0)                    
##  Rcpp         0.12.12    2017-07-15 CRAN (R 3.4.1)                    
##  readr      * 1.1.1      2017-05-16 CRAN (R 3.4.0)                    
##  rlang        0.1.2      2017-08-09 CRAN (R 3.4.1)                    
##  rmarkdown    1.6        2017-06-15 CRAN (R 3.4.0)                    
##  rprojroot    1.2        2017-01-16 CRAN (R 3.4.0)                    
##  scales       0.5.0      2017-08-24 CRAN (R 3.4.1)                    
##  stats      * 3.4.0      2017-04-21 local                             
##  stringi      1.1.5      2017-04-07 CRAN (R 3.4.0)                    
##  stringr      1.2.0      2017-02-18 CRAN (R 3.4.0)                    
##  tibble       1.3.4      2017-08-22 CRAN (R 3.4.1)                    
##  tools        3.4.0      2017-04-21 local                             
##  utils      * 3.4.0      2017-04-21 local                             
##  withr        2.0.0      2017-08-08 Github (jimhester/withr@190d293)  
##  yaml         2.1.14     2016-11-12 CRAN (R 3.4.0)&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Os gráficos que explicam nossos dados (heatmap)</title>
      <link>/os-graficos-que-explicam-nossos-dados-heatmap/</link>
      <pubDate>Sat, 09 Jul 2016 00:00:00 +0000</pubDate>
      
      <guid>/os-graficos-que-explicam-nossos-dados-heatmap/</guid>
      <description>&lt;p&gt;O heatmap é um gráfico muito útil para identificar padrões, principalmente quando temos muitas variáveis no gráfico. Essencialmente o heatmap necessita de 3 variáveis: uma variável resposta e duas outras variáveis para compor os eixos x e y. Não há restrição quanto ao tipo de variável, qualquer uma delas podem ser quantitativa ou qualitativa. Talvez esse seja o trunfo do heatmap, essa flexbilidade quanto a natureza das variáveis nos permite utilizá-lo em diversos momentos e substituir gráficos mais tradicionais quando eles não dão conta do recado.&lt;/p&gt;
&lt;p&gt;Vamos trabalhar com os dados do &lt;a href=&#34;http://www.projetotume.com/&#34;&gt;Projeto TUME&lt;/a&gt;, especificamente com o TUME 0, plantado na Estação Experimental de Itatinga. O TUME é um projeto muito interessante e possui informações importantes sobre plantios de &lt;em&gt;Eucalyptus&lt;/em&gt; no Brasil, vale a pena visitar o site e aproveitar o conteúdo disponível.&lt;/p&gt;
&lt;p&gt;Vamos primeiro carregar os dados e fazer algumas alterações. Para auxiliar na ordem dos fatores no gráfico vamos adicionar um atributo na coluna &lt;code&gt;Esp&lt;/code&gt; informando a ordem crescente das espécies em função da altura dominante. Em seguida, apenas por conveniência, converti a idade dos inventários de meses para anos.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;if (!require(&amp;quot;pacman&amp;quot;)) install.packages(&amp;quot;pacman&amp;quot;)
pacman::p_load(readr, dplyr, ggplot2, ggthemes, viridis)&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;dados &amp;lt;- read_csv2(
  &amp;quot;https://github.com/italocegatta/italocegatta.github.io_source/raw/master/content/dados/tume0.csv&amp;quot;
)

# Cria um fator com o atributo para a variável Esp que informa a ordem crescente
# das espécies em função da altura dominante.
dados &amp;lt;- dados %&amp;gt;% 
  mutate(
    Esp = reorder(Esp, Hdom, function(x) max(x)),
    Idade = round(I_meses/12,1)
  )
dados&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 138 x 16
##    N_tume             Esp I_meses Parc_m2 DAPmed DAPsd  Hmed   Hsd  Hdom
##     &amp;lt;int&amp;gt;          &amp;lt;fctr&amp;gt;   &amp;lt;int&amp;gt;   &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt;
##  1      0         Clone_1      52  1425.6   11.4   1.4  16.5   1.3  17.8
##  2      0         Clone_2      52  1425.6   10.2   1.4  15.9   1.4  16.6
##  3      0         Clone_3      52  1425.6   10.7   1.6  15.0   1.3  16.1
##  4      0     E_benthamii      52  1425.6    9.0   2.7   9.8   2.3  13.0
##  5      0    E_botryoides      52  1425.6    9.1   4.3  10.8   3.4  15.3
##  6      0 E_camaldulensis      52  1425.6    8.3   2.9   8.3   2.3  11.8
##  7      0    E_citriodora      52  1425.6    8.0   3.5   8.3   2.8  12.0
##  8      0     E_cloeziana      52   928.8    7.5   2.5   7.0   2.0   9.6
##  9      0        E_deanei      52  1425.6   10.6   2.9  11.3   1.8  13.4
## 10      0        E_dunnii      52  1425.6    6.7   3.7   6.1   2.4  10.3
## # ... with 128 more rows, and 7 more variables: N_fuste &amp;lt;int&amp;gt;, Sobr &amp;lt;dbl&amp;gt;,
## #   G &amp;lt;dbl&amp;gt;, V &amp;lt;int&amp;gt;, IMA &amp;lt;dbl&amp;gt;, B &amp;lt;int&amp;gt;, Idade &amp;lt;dbl&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Se fizermos a seguinte pergunta: qual gráfico podemos utilizar para mostrar o crescimento da altura dominantes dos materiais? Penso que a resposta rápida seria, um gráfico de linhas! Ok, vamos tentar, veja a Figura &lt;a href=&#34;#fig:6-linhas&#34;&gt;1&lt;/a&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggplot(dados, aes(Idade, Hdom, color = Esp)) +
  geom_line(size=1.5) +
  labs(x = &amp;quot;Idade (anos)&amp;quot;, y = &amp;quot;Altura dominante (m)&amp;quot;) +
  theme_few() +
  scale_color_viridis(
    name = &amp;quot;Materiais genéticos&amp;quot;,
    direction = -1, discrete = T
  ) +
  guides(col = guide_legend(ncol = 1, reverse = TRUE))&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;figure&#34;&gt;&lt;span id=&#34;fig:6-linhas&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;/post/2016-07-09-os-graficos-que-explicam-nossos-dados-heatmap_files/figure-html/6-linhas-1.png&#34; alt=&#34;Aumento da altura dominante utilizando gráficos de linhas.&#34; width=&#34;4000&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figura  1: Aumento da altura dominante utilizando gráficos de linhas.
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Muito bem, o gráfico consegue mostar a tendência e o padrão de crescimento. Mas se alguém perguntar sobre o &lt;em&gt;Eucaluptus dunnii&lt;/em&gt;, capaz de demorarmos um tempo para encontrar a linha correspondente. Capaz ainda de não conseguirmos distinguir entre uma cor e outra. Essa é uma limitação do gráfico de linhas, quanto temos muitos fatores na legenda fica difícil a distinção entre eles. E quando se tem uma restrição de cor e o gráfico precisa estar em escala de cinza? Esquece! Há quem tente utilizar símbolos ou tipos de traços para distinguir os fatores, mas mesmo assim, não é uma tarefa fácil.&lt;/p&gt;
&lt;p&gt;É neste momento que podemos nos aproveitar do heatmap. Agora a intencidade de cor indica a variável resposta (Figura &lt;a href=&#34;#fig:6-heatmap-cont&#34;&gt;2&lt;/a&gt;). Veja que fica mais fácil acompanhar o crescimento de uma espécies em especial.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggplot(dados, aes(factor(Idade), Esp, fill = Hdom)) +
  geom_tile() +
  labs(x = &amp;quot;Idade (anos)&amp;quot;, y = &amp;quot;Materiais genéticos&amp;quot;) +
  theme_few() +
  scale_fill_viridis(name = &amp;quot;Altura dominante (m)&amp;quot;, direction = -1) +
  guides(col = guide_legend(reverse = TRUE))&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;figure&#34;&gt;&lt;span id=&#34;fig:6-heatmap-cont&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;/post/2016-07-09-os-graficos-que-explicam-nossos-dados-heatmap_files/figure-html/6-heatmap-cont-1.png&#34; alt=&#34;Aumento da altura dominante utilizando heatmap com escala de cor contínua.&#34; width=&#34;4000&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figura  2: Aumento da altura dominante utilizando heatmap com escala de cor contínua.
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Se for do interesse controlar a escala de cor em intervalos e classes, a alteração é simples (Figura &lt;a href=&#34;#fig:6-heatmap-discr&#34;&gt;3&lt;/a&gt;). Se reduzirmos as classes de cor, perdemos resolução na escala da variável resposta. Dependendo do objetivo do gráfico isso pode ser bom ou ruim. Neste caso, escolhi intervalos de 2 metros, pois achei mais adequado.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggplot(dados, aes(factor(Idade),
       Esp, fill = cut(Hdom, breaks = seq(0, 40, 2)))) +
 geom_tile() +
 labs(x = &amp;quot;Idade (anos)&amp;quot;, y = &amp;quot;Materiais genéticos&amp;quot;) +
 theme_few() +
 scale_fill_viridis(
   name = &amp;quot;Altura dominante (m)&amp;quot;,
   discrete = T, direction = -1
 ) +
 guides(col = guide_legend(reverse = TRUE))&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;figure&#34;&gt;&lt;span id=&#34;fig:6-heatmap-discr&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;/post/2016-07-09-os-graficos-que-explicam-nossos-dados-heatmap_files/figure-html/6-heatmap-discr-1.png&#34; alt=&#34;Aumento da altura dominante utilizando heatmap com escala de cor discreta.&#34; width=&#34;4000&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figura  3: Aumento da altura dominante utilizando heatmap com escala de cor discreta.
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Se quisermos deixar explícito o valor da variável resposta podemos indicá-la no gráfico, como na Figura &lt;a href=&#34;#fig:6-heatmap-discr-label&#34;&gt;4&lt;/a&gt;. Eu particularmente acho que fica muito poluído, mas em alguns casos pode ser interessante.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggplot(dados, aes(factor(Idade),
       Esp, fill = cut(Hdom, breaks = seq(0, 40, 2)))) +
 geom_tile() +
 geom_text(aes(label = Hdom), color = &amp;quot;white&amp;quot;) +
 labs(x = &amp;quot;Idade (anos)&amp;quot;, y = &amp;quot;Materiais genéticos&amp;quot;) +
 theme_few() +
 scale_fill_viridis(
   name = &amp;quot;Altura dominante (m)&amp;quot;,
   discrete = T, direction = -1
 ) +
 guides(col = guide_legend(reverse = TRUE))&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;figure&#34;&gt;&lt;span id=&#34;fig:6-heatmap-discr-label&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;/post/2016-07-09-os-graficos-que-explicam-nossos-dados-heatmap_files/figure-html/6-heatmap-discr-label-1.png&#34; alt=&#34;Aumento da altura dominante utilizando heatmap com escala de cor discreta e informação do valor no grid.&#34; width=&#34;4000&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figura  4: Aumento da altura dominante utilizando heatmap com escala de cor discreta e informação do valor no grid.
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Note que o eixo x é uma variável temporal, entretanto o gráfico não dá a escala entre os anos. Um observador desatento pode achar que as medições ocorreram em intervalos regulares, mas isso não é verdade. Essa é uma desvantagem do heatmap. Quando as variáveis dos eixos são numéricas e representam uma escala comparativa, este atributo fica comprometido.&lt;/p&gt;
&lt;p&gt;Caso tenha alguma dúvida ou sugestão sobre o post, fique à vontade para fazer um comentário ou me contactar por Email.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;devtools::session_info()&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  setting  value                       
##  version  R version 3.4.0 (2017-04-21)
##  system   x86_64, mingw32             
##  ui       RTerm                       
##  language (EN)                        
##  collate  Portuguese_Brazil.1252      
##  tz       America/Sao_Paulo           
##  date     2017-09-16                  
## 
##  package     * version    date       source                            
##  assertthat    0.2.0      2017-04-11 CRAN (R 3.4.0)                    
##  backports     1.1.0      2017-05-22 CRAN (R 3.4.0)                    
##  base        * 3.4.0      2017-04-21 local                             
##  bindr         0.1        2016-11-13 CRAN (R 3.4.0)                    
##  bindrcpp    * 0.2        2017-06-17 CRAN (R 3.4.0)                    
##  blogdown      0.1        2017-08-22 CRAN (R 3.4.1)                    
##  bookdown      0.5        2017-08-20 CRAN (R 3.4.1)                    
##  colorspace    1.3-2      2016-12-14 CRAN (R 3.4.0)                    
##  compiler      3.4.0      2017-04-21 local                             
##  curl          2.8.1      2017-07-21 CRAN (R 3.4.1)                    
##  datasets    * 3.4.0      2017-04-21 local                             
##  devtools      1.13.3     2017-08-02 CRAN (R 3.4.1)                    
##  digest        0.6.12     2017-01-27 CRAN (R 3.4.0)                    
##  dplyr       * 0.7.3      2017-09-09 CRAN (R 3.4.1)                    
##  evaluate      0.10.1     2017-06-24 CRAN (R 3.4.0)                    
##  ggplot2     * 2.2.1.9000 2017-08-08 Github (tidyverse/ggplot2@53a22cd)
##  ggthemes    * 3.4.0      2017-02-19 CRAN (R 3.4.0)                    
##  glue          1.1.1      2017-06-21 CRAN (R 3.4.0)                    
##  graphics    * 3.4.0      2017-04-21 local                             
##  grDevices   * 3.4.0      2017-04-21 local                             
##  grid          3.4.0      2017-04-21 local                             
##  gridExtra     2.3        2017-09-09 CRAN (R 3.4.1)                    
##  gtable        0.2.0      2016-02-26 CRAN (R 3.4.0)                    
##  highr         0.6        2016-05-09 CRAN (R 3.4.0)                    
##  hms           0.3        2016-11-22 CRAN (R 3.4.0)                    
##  htmltools     0.3.6      2017-04-28 CRAN (R 3.4.0)                    
##  knitr         1.17       2017-08-10 CRAN (R 3.4.1)                    
##  labeling      0.3        2014-08-23 CRAN (R 3.4.0)                    
##  lazyeval      0.2.0      2016-06-12 CRAN (R 3.4.0)                    
##  magrittr      1.5        2014-11-22 CRAN (R 3.4.0)                    
##  memoise       1.1.0      2017-04-21 CRAN (R 3.4.0)                    
##  methods     * 3.4.0      2017-04-21 local                             
##  munsell       0.4.3      2016-02-13 CRAN (R 3.4.0)                    
##  pacman      * 0.4.6      2017-05-14 CRAN (R 3.4.0)                    
##  pkgconfig     2.0.1      2017-03-21 CRAN (R 3.4.0)                    
##  plyr          1.8.4      2016-06-08 CRAN (R 3.4.0)                    
##  R6            2.2.2      2017-06-17 CRAN (R 3.4.0)                    
##  Rcpp          0.12.12    2017-07-15 CRAN (R 3.4.1)                    
##  readr       * 1.1.1      2017-05-16 CRAN (R 3.4.0)                    
##  rlang         0.1.2      2017-08-09 CRAN (R 3.4.1)                    
##  rmarkdown     1.6        2017-06-15 CRAN (R 3.4.0)                    
##  rprojroot     1.2        2017-01-16 CRAN (R 3.4.0)                    
##  scales        0.5.0      2017-08-24 CRAN (R 3.4.1)                    
##  stats       * 3.4.0      2017-04-21 local                             
##  stringi       1.1.5      2017-04-07 CRAN (R 3.4.0)                    
##  stringr       1.2.0      2017-02-18 CRAN (R 3.4.0)                    
##  tibble        1.3.4      2017-08-22 CRAN (R 3.4.1)                    
##  tools         3.4.0      2017-04-21 local                             
##  utils       * 3.4.0      2017-04-21 local                             
##  viridis     * 0.4.0      2017-03-27 CRAN (R 3.4.0)                    
##  viridisLite * 0.2.0      2017-03-24 CRAN (R 3.4.0)                    
##  withr         2.0.0      2017-08-08 Github (jimhester/withr@190d293)  
##  yaml          2.1.14     2016-11-12 CRAN (R 3.4.0)&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Os gráficos que explicam nossos dados (barras)</title>
      <link>/os-graficos-que-explicam-nossos-dados-barras/</link>
      <pubDate>Sat, 14 May 2016 00:00:00 +0000</pubDate>
      
      <guid>/os-graficos-que-explicam-nossos-dados-barras/</guid>
      <description>&lt;p&gt;Este é o segundo post de uma série que estou fazendo sobre tipos de gráficos. Falamos um pouco sobre o &lt;a href=&#34;https://italocegatta.github.io/os-graficos-que-explicam-nossos-dados-boxplot&#34;&gt;boxplot&lt;/a&gt; e agora vamos ao gráfico de barras.&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;Gráficos de barras são muito úteis para podermos comparar fatores. Quando estão um ao lado do outro a comparação é feita rapidamente, já que as barras dão a noção de escala. Normalmente as barras informam um resumo (i. e. média, soma ou contagem), mas podemos ainda adicionar uma barra de erro ou desvio e deixar o gráfico mais detalhado.&lt;/p&gt;
&lt;p&gt;Continuaremos com o banco de dados apresentado no post sobre &lt;a href=&#34;https://italocegatta.github.io/o-conceito-tidy-data.html&#34;&gt;tidy data&lt;/a&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;if (!require(&amp;quot;pacman&amp;quot;)) install.packages(&amp;quot;pacman&amp;quot;)
pacman::p_load(readr, dplyr, ggplot2, ggthemes)&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;dados &amp;lt;- read_csv2(
  &amp;quot;https://github.com/italocegatta/italocegatta.github.io_source/raw/master/content/dados/base_vespa.csv&amp;quot;
)

dados&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 2,100 x 5
##    Tratamento Individuo Coleta   Local Galhas
##         &amp;lt;chr&amp;gt;     &amp;lt;int&amp;gt;  &amp;lt;int&amp;gt;   &amp;lt;chr&amp;gt;  &amp;lt;int&amp;gt;
##  1  Actara d1         1      1 Peciolo      1
##  2  Actara d1         2      1 Peciolo     NA
##  3  Actara d1         3      1 Peciolo     NA
##  4  Actara d1         4      1 Peciolo     NA
##  5  Actara d1         5      1 Peciolo     NA
##  6  Actara d1         6      1 Peciolo     NA
##  7  Actara d1         7      1 Peciolo     NA
##  8  Actara d1         8      1 Peciolo     NA
##  9  Actara d1         9      1 Peciolo     NA
## 10  Actara d1        10      1 Peciolo     NA
## # ... with 2,090 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;div id=&#34;basico&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Básico&lt;/h2&gt;
&lt;p&gt;A primeira sequência de gráficos está relacionada ao total de galhas encontradas nas mudas de cada tratamento. Nessa comparação, temos de considerar tratamentos como fatores e os locais onde a galha foi encontrada como níveis do fator local. Essa distinção vai nos ajuda a escolher a melhor forma de construir um gráfico de acordo com o que queremos mostrar.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# seleciona apenas as Coletas de numero 5, em seguida monta um fator de 
# agrupamento em função de Tratamento. Aplica a soma de todas as
# observações (Galhas) de acordo com o fator de agrupamento.

total_trat &amp;lt;- dados %&amp;gt;%
  filter(Coleta == 5) %&amp;gt;%
  group_by(Tratamento) %&amp;gt;%
  summarise(Galhas = sum(Galhas, na.rm=T))

total_trat&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 7 x 2
##    Tratamento Galhas
##         &amp;lt;chr&amp;gt;  &amp;lt;int&amp;gt;
## 1   Actara d1     73
## 2   Actara d2     57
## 3   Actara d3     30
## 4 Evidence d1     27
## 5 Evidence d2     21
## 6 Evidence d3     12
## 7  Testemunha     77&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Agora já podemos fazer o primeiro gráfico simples e básico (Figura &lt;a href=&#34;#fig:5-bar-basico&#34;&gt;1&lt;/a&gt;).&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggplot(total_trat, aes(Tratamento, Galhas)) +
  geom_bar(stat = &amp;quot;identity&amp;quot;) +
  theme_few()&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;figure&#34;&gt;&lt;span id=&#34;fig:5-bar-basico&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;/post/2016-05-14-os-graficos-que-explicam-nossos-dados-barras_files/figure-html/5-bar-basico-1.png&#34; alt=&#34;Número total de galhas de cada tratamento.&#34; width=&#34;4000&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figura  1: Número total de galhas de cada tratamento.
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Mas ainda temos a variável &lt;code&gt;Local&lt;/code&gt;, certo? Podemos apresentá-la sem muito esforço.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;total_trat_local &amp;lt;- dados %&amp;gt;%
  filter(Coleta == 5) %&amp;gt;%
  group_by(Tratamento, Local) %&amp;gt;%
  summarise(Galhas = sum(Galhas, na.rm=T))

total_trat_local&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 21 x 3
## # Groups:   Tratamento [?]
##     Tratamento   Local Galhas
##          &amp;lt;chr&amp;gt;   &amp;lt;chr&amp;gt;  &amp;lt;int&amp;gt;
##  1   Actara d1   Caule     13
##  2   Actara d1 Nervura     19
##  3   Actara d1 Peciolo     41
##  4   Actara d2   Caule     10
##  5   Actara d2 Nervura      9
##  6   Actara d2 Peciolo     38
##  7   Actara d3   Caule      7
##  8   Actara d3 Nervura      6
##  9   Actara d3 Peciolo     17
## 10 Evidence d1   Caule      6
## # ... with 11 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggplot(total_trat_local, aes(Tratamento, Galhas, fill = Local)) +
  geom_bar(stat = &amp;quot;identity&amp;quot;) +
  theme_few() +
  scale_fill_brewer(palette = &amp;quot;Spectral&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;figure&#34;&gt;&lt;span id=&#34;fig:5-bar-local&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;/post/2016-05-14-os-graficos-que-explicam-nossos-dados-barras_files/figure-html/5-bar-local-1.png&#34; alt=&#34;Número total de galhas de cada tratamento em diferentes locais - níveis agrupados.&#34; width=&#34;4000&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figura  2: Número total de galhas de cada tratamento em diferentes locais - níveis agrupados.
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;No caso da Figura &lt;a href=&#34;#fig:5-bar-local&#34;&gt;2&lt;/a&gt;, à primeira vista comparamos as barras (fatores) e depois as cores (níveis). Podemos dar mais evidência aos níveis, transformando-os em barras como na Figura &lt;a href=&#34;#fig:5-bar-local-dodge&#34;&gt;3&lt;/a&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggplot(total_trat_local, aes(Tratamento, Galhas, fill = Local)) +
  geom_bar(stat = &amp;quot;identity&amp;quot;, position = &amp;quot;dodge&amp;quot;) +
  theme_few() +
  scale_fill_brewer(palette = &amp;quot;Spectral&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;figure&#34;&gt;&lt;span id=&#34;fig:5-bar-local-dodge&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;/post/2016-05-14-os-graficos-que-explicam-nossos-dados-barras_files/figure-html/5-bar-local-dodge-1.png&#34; alt=&#34;Número total de galhas de cada tratamento em diferentes locais - níveis lado a lados.&#34; width=&#34;4000&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figura  3: Número total de galhas de cada tratamento em diferentes locais - níveis lado a lados.
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Como alternativa, podemos subdividir os níveis em painéis e deixar o gráfico mais balanceado, ou seja, sem concentrar a informação em fatores ou níveis (Figura &lt;a href=&#34;#fig:5-bar-local-facet&#34;&gt;4&lt;/a&gt;).&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggplot(total_trat_local, aes(Tratamento, Galhas )) +
  geom_bar(stat = &amp;quot;identity&amp;quot;, position = &amp;quot;dodge&amp;quot;) +
  facet_wrap(~Local) +
  theme_few() +
  theme(axis.text.x = element_text(angle = 30, hjust = 0.5, vjust = 0.5))&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;figure&#34;&gt;&lt;span id=&#34;fig:5-bar-local-facet&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;/post/2016-05-14-os-graficos-que-explicam-nossos-dados-barras_files/figure-html/5-bar-local-facet-1.png&#34; alt=&#34;Número total de galhas de cada tratamento em diferentes locais - níveis em painel.&#34; width=&#34;4000&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figura  4: Número total de galhas de cada tratamento em diferentes locais - níveis em painel.
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Note que nos 3 gráficos anteriores o banco de dados para formação do gráfico é o mesmo, mas cada um dá ênfase em um aspecto diferente. A parte boa é que podemos modificá-los de acordo com o nosso interesse de uma forma rápida e bem simples.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;adicionando-valores-as-barras&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Adicionando valores às barras&lt;/h2&gt;
&lt;p&gt;Se quisermos adicionar o valor de cada nível ou fator na barra, temos de alterar o banco de dados para que ele coincida com o que queremos mostrar.&lt;/p&gt;
&lt;p&gt;Para a Figura &lt;a href=&#34;#fig:5-bar-basico-annot&#34;&gt;5&lt;/a&gt;, modificamos apenas o código do gráfico.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggplot(total_trat, aes(Tratamento, Galhas)) +
  geom_bar(stat = &amp;quot;identity&amp;quot;) +
  geom_text(aes(label = Galhas), size = 6, vjust = -0.2) +
  theme_few()&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;figure&#34;&gt;&lt;span id=&#34;fig:5-bar-basico-annot&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;/post/2016-05-14-os-graficos-que-explicam-nossos-dados-barras_files/figure-html/5-bar-basico-annot-1.png&#34; alt=&#34;Número total de galhas de cada tratamento com o valor na respectiva barra.&#34; width=&#34;4000&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figura  5: Número total de galhas de cada tratamento com o valor na respectiva barra.
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Também é fácil indicar o número de galhas por local nas barras. A função &lt;code&gt;position_stack()&lt;/code&gt; é responsável por colocar o texto no topo de cada compartimento colorido. Para ficar mais atraente, podemos adicionar um parâmetro para que o texto fique 20% a baixo do topo do compartimento. Como resultado temos a Figura &lt;a href=&#34;#fig:5-bar-local-annot&#34;&gt;6&lt;/a&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# Cria uma nova coluna que contem a posição no eixo y que corresponde ao centro
# da barra. Esta posição correnponde ao local onde o label de cada barra
# será mostrado

ggplot(total_trat_local, aes(Tratamento, Galhas, fill = Local)) +
    geom_col() +
    geom_text(
      aes(label = Galhas),
      position =  position_stack(vjust = 0.8), vjust = 1
    ) +
    theme_few() +
  scale_fill_brewer(palette = &amp;quot;Spectral&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;figure&#34;&gt;&lt;span id=&#34;fig:5-bar-local-annot&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;/post/2016-05-14-os-graficos-que-explicam-nossos-dados-barras_files/figure-html/5-bar-local-annot-1.png&#34; alt=&#34;Número total de galhas de cada tratamento em diferentes locais com o valor da respectiva barra - níveis agrupados.&#34; width=&#34;4000&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figura  6: Número total de galhas de cada tratamento em diferentes locais com o valor da respectiva barra - níveis agrupados.
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;As Figuras &lt;a href=&#34;#fig:5-bar-local-dodge-annot&#34;&gt;7&lt;/a&gt; e &lt;a href=&#34;#fig:5-bar-local-facet-annot&#34;&gt;8&lt;/a&gt; foram criadas apenas alterando o código do gráfico.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggplot(total_trat_local, aes(Tratamento, Galhas, fill = Local)) +
  geom_bar(stat = &amp;quot;identity&amp;quot;, position = &amp;quot;dodge&amp;quot;) +
  geom_text(aes(label = Galhas),
    position = position_dodge(width=0.9), vjust = -0.2) +
  theme_few() +
  scale_fill_brewer(palette = &amp;quot;Spectral&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;figure&#34;&gt;&lt;span id=&#34;fig:5-bar-local-dodge-annot&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;/post/2016-05-14-os-graficos-que-explicam-nossos-dados-barras_files/figure-html/5-bar-local-dodge-annot-1.png&#34; alt=&#34;Número total de galhas de cada tratamento em diferentes locais com o valor da respectiva barra - níveis lado a lados.&#34; width=&#34;4000&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figura  7: Número total de galhas de cada tratamento em diferentes locais com o valor da respectiva barra - níveis lado a lados.
&lt;/p&gt;
&lt;/div&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggplot(total_trat_local, aes(Tratamento, Galhas )) +
  geom_bar(stat = &amp;quot;identity&amp;quot;, position = &amp;quot;dodge&amp;quot;) +
    geom_text(aes(label = Galhas), vjust = -0.2) +
  facet_wrap(~Local) +
  theme_few() +
  theme(axis.text.x = element_text(angle = 30, hjust = 0.5, vjust = 0.5))&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;figure&#34;&gt;&lt;span id=&#34;fig:5-bar-local-facet-annot&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;/post/2016-05-14-os-graficos-que-explicam-nossos-dados-barras_files/figure-html/5-bar-local-facet-annot-1.png&#34; alt=&#34;Número total de galhas de cada tratamento em diferentes locais com o valor da respectiva barra - níveis em painel.&#34; width=&#34;4000&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figura  8: Número total de galhas de cada tratamento em diferentes locais com o valor da respectiva barra - níveis em painel.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;barra-de-desvio&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Barra de desvio&lt;/h2&gt;
&lt;p&gt;Uma outra informação interessante para o gráfico de barras é a barra de erro ou desvio. Com ela, além de informarmos o valor que queremos, também informamos uma medida de dispersão associada a esse valor. Nos gráficos anteriores apresentei o total de galhas por tratamento e local. Não faz sentido, nesse caso, colocar uma barra de desvio, pois a soma não é uma medida de posição. Portanto, vamos resumir novamente os dados em função da média e acrescentar o erro padrão da média.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# Seleciona apenas as Coletas de numero 5, em seguida calcula a média e o
# desvio padrão de cada Tratamento.

media_trat_desv &amp;lt;- dados %&amp;gt;%
  filter(Coleta == 5) %&amp;gt;%
  group_by(Tratamento) %&amp;gt;%
  summarise(desv = sd(Galhas, na.rm=T)/sqrt(n()),
    Galhas = mean(Galhas, na.rm=T))

media_trat_desv&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 7 x 3
##    Tratamento      desv   Galhas
##         &amp;lt;chr&amp;gt;     &amp;lt;dbl&amp;gt;    &amp;lt;dbl&amp;gt;
## 1   Actara d1 0.4799351 4.055556
## 2   Actara d2 0.4893473 3.352941
## 3   Actara d3 0.1331730 2.307692
## 4 Evidence d1 0.5889188 3.857143
## 5 Evidence d2 0.2667039 2.625000
## 6 Evidence d3 0.1632993 2.000000
## 7  Testemunha 0.3601529 3.347826&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Após criar o &lt;em&gt;data frame&lt;/em&gt; com o desvio, a Figura &lt;a href=&#34;#fig:5-bar-basico-desv&#34;&gt;9&lt;/a&gt; é facilmente criada com o código abaixo.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggplot(media_trat_desv, aes(Tratamento, Galhas)) +
  geom_bar(stat = &amp;quot;identity&amp;quot;) +
  geom_errorbar(aes(ymin = Galhas - desv,
     ymax = Galhas + desv), width = 0.4) +
  theme_few()&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;figure&#34;&gt;&lt;span id=&#34;fig:5-bar-basico-desv&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;/post/2016-05-14-os-graficos-que-explicam-nossos-dados-barras_files/figure-html/5-bar-basico-desv-1.png&#34; alt=&#34;Número total de galhas de cada tratamento com barra de desvio.&#34; width=&#34;4000&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figura  9: Número total de galhas de cada tratamento com barra de desvio.
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;No caso das Figuras &lt;a href=&#34;#fig:5-bar-local-dodge-desv&#34;&gt;10&lt;/a&gt; e &lt;a href=&#34;#fig:5-bar-local-facet-desv&#34;&gt;11&lt;/a&gt;, precisamos dados dados agrupados por &lt;code&gt;Tratamento&lt;/code&gt; e &lt;code&gt;Local&lt;/code&gt;. O código para o gráfico é muito semelhante aos anteriores. Em alguns tratamentos há somente um indivíduo indivídio com contagem de galhas. Nesta situação não há barra de desvio.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# Seleciona apenas as Coletas de numero 5, em seguida calcula a mediana e o
# desvio padrão em função de cada Trtatamento e Local.

mediana_trat_local_desv &amp;lt;- dados %&amp;gt;%
  filter(Coleta == 5) %&amp;gt;%
  group_by(Tratamento, Local) %&amp;gt;%
  summarise(desv = sd(Galhas, na.rm=T)/sqrt(n()),
    Galhas = median(Galhas, na.rm=T))

mediana_trat_local_desv&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 21 x 4
## # Groups:   Tratamento [?]
##     Tratamento   Local      desv Galhas
##          &amp;lt;chr&amp;gt;   &amp;lt;chr&amp;gt;     &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt;
##  1   Actara d1   Caule 0.3291403      2
##  2   Actara d1 Nervura 0.8276473      3
##  3   Actara d1 Peciolo 1.0200373      4
##  4   Actara d2   Caule 0.2708013      1
##  5   Actara d2 Nervura 0.2813657      2
##  6   Actara d2 Peciolo 1.1751393      4
##  7   Actara d3   Caule 0.1118034      2
##  8   Actara d3 Nervura 0.0000000      2
##  9   Actara d3 Peciolo 0.2972092      3
## 10 Evidence d1   Caule 0.2236068      2
## # ... with 11 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggplot(mediana_trat_local_desv, aes(Tratamento, Galhas, fill = Local)) +
  geom_bar(stat = &amp;quot;identity&amp;quot;, position = &amp;quot;dodge&amp;quot;) +
  geom_errorbar(aes(ymin = Galhas - desv, ymax = Galhas + desv),
    position = position_dodge(width=0.9), width = 0.4) +
  theme_few() +
  scale_fill_brewer(palette = &amp;quot;Spectral&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;figure&#34;&gt;&lt;span id=&#34;fig:5-bar-local-dodge-desv&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;/post/2016-05-14-os-graficos-que-explicam-nossos-dados-barras_files/figure-html/5-bar-local-dodge-desv-1.png&#34; alt=&#34;Número total de galhas de cada tratamento em diferentes locais com barra de desvio - níveis lado a lados.&#34; width=&#34;4000&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figura  10: Número total de galhas de cada tratamento em diferentes locais com barra de desvio - níveis lado a lados.
&lt;/p&gt;
&lt;/div&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggplot(mediana_trat_local_desv, aes(Tratamento, Galhas )) +
  geom_bar(stat = &amp;quot;identity&amp;quot;, position = &amp;quot;dodge&amp;quot;) +
  geom_errorbar(aes(ymin = Galhas - desv,
    ymax = Galhas + desv), width = 0.4) +
  facet_wrap(~Local) +
  theme_few() +
  theme(axis.text.x = element_text(angle = 30, hjust = 0.5, vjust = 0.5))&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;figure&#34;&gt;&lt;span id=&#34;fig:5-bar-local-facet-desv&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;/post/2016-05-14-os-graficos-que-explicam-nossos-dados-barras_files/figure-html/5-bar-local-facet-desv-1.png&#34; alt=&#34;Número total de galhas de cada tratamento em diferentes locais com barra de desvio - níveis em painel.&#34; width=&#34;4000&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figura  11: Número total de galhas de cada tratamento em diferentes locais com barra de desvio - níveis em painel.
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Caso tenha alguma dúvida ou sugestão sobre o post, fique à vontade para fazer um comentário ou me contactar por Email.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;devtools::session_info()&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  setting  value                       
##  version  R version 3.4.0 (2017-04-21)
##  system   x86_64, mingw32             
##  ui       RTerm                       
##  language (EN)                        
##  collate  Portuguese_Brazil.1252      
##  tz       America/Sao_Paulo           
##  date     2017-09-16                  
## 
##  package      * version    date       source                            
##  assertthat     0.2.0      2017-04-11 CRAN (R 3.4.0)                    
##  backports      1.1.0      2017-05-22 CRAN (R 3.4.0)                    
##  base         * 3.4.0      2017-04-21 local                             
##  bindr          0.1        2016-11-13 CRAN (R 3.4.0)                    
##  bindrcpp     * 0.2        2017-06-17 CRAN (R 3.4.0)                    
##  blogdown       0.1        2017-08-22 CRAN (R 3.4.1)                    
##  bookdown       0.5        2017-08-20 CRAN (R 3.4.1)                    
##  colorspace     1.3-2      2016-12-14 CRAN (R 3.4.0)                    
##  compiler       3.4.0      2017-04-21 local                             
##  curl           2.8.1      2017-07-21 CRAN (R 3.4.1)                    
##  datasets     * 3.4.0      2017-04-21 local                             
##  devtools       1.13.3     2017-08-02 CRAN (R 3.4.1)                    
##  digest         0.6.12     2017-01-27 CRAN (R 3.4.0)                    
##  dplyr        * 0.7.3      2017-09-09 CRAN (R 3.4.1)                    
##  evaluate       0.10.1     2017-06-24 CRAN (R 3.4.0)                    
##  ggplot2      * 2.2.1.9000 2017-08-08 Github (tidyverse/ggplot2@53a22cd)
##  ggthemes     * 3.4.0      2017-02-19 CRAN (R 3.4.0)                    
##  glue           1.1.1      2017-06-21 CRAN (R 3.4.0)                    
##  graphics     * 3.4.0      2017-04-21 local                             
##  grDevices    * 3.4.0      2017-04-21 local                             
##  grid           3.4.0      2017-04-21 local                             
##  gtable         0.2.0      2016-02-26 CRAN (R 3.4.0)                    
##  highr          0.6        2016-05-09 CRAN (R 3.4.0)                    
##  hms            0.3        2016-11-22 CRAN (R 3.4.0)                    
##  htmltools      0.3.6      2017-04-28 CRAN (R 3.4.0)                    
##  knitr          1.17       2017-08-10 CRAN (R 3.4.1)                    
##  labeling       0.3        2014-08-23 CRAN (R 3.4.0)                    
##  lazyeval       0.2.0      2016-06-12 CRAN (R 3.4.0)                    
##  magrittr       1.5        2014-11-22 CRAN (R 3.4.0)                    
##  memoise        1.1.0      2017-04-21 CRAN (R 3.4.0)                    
##  methods      * 3.4.0      2017-04-21 local                             
##  munsell        0.4.3      2016-02-13 CRAN (R 3.4.0)                    
##  pacman       * 0.4.6      2017-05-14 CRAN (R 3.4.0)                    
##  pkgconfig      2.0.1      2017-03-21 CRAN (R 3.4.0)                    
##  plyr           1.8.4      2016-06-08 CRAN (R 3.4.0)                    
##  R6             2.2.2      2017-06-17 CRAN (R 3.4.0)                    
##  RColorBrewer   1.1-2      2014-12-07 CRAN (R 3.4.0)                    
##  Rcpp           0.12.12    2017-07-15 CRAN (R 3.4.1)                    
##  readr        * 1.1.1      2017-05-16 CRAN (R 3.4.0)                    
##  rlang          0.1.2      2017-08-09 CRAN (R 3.4.1)                    
##  rmarkdown      1.6        2017-06-15 CRAN (R 3.4.0)                    
##  rprojroot      1.2        2017-01-16 CRAN (R 3.4.0)                    
##  scales         0.5.0      2017-08-24 CRAN (R 3.4.1)                    
##  stats        * 3.4.0      2017-04-21 local                             
##  stringi        1.1.5      2017-04-07 CRAN (R 3.4.0)                    
##  stringr        1.2.0      2017-02-18 CRAN (R 3.4.0)                    
##  tibble         1.3.4      2017-08-22 CRAN (R 3.4.1)                    
##  tools          3.4.0      2017-04-21 local                             
##  utils        * 3.4.0      2017-04-21 local                             
##  withr          2.0.0      2017-08-08 Github (jimhester/withr@190d293)  
##  yaml           2.1.14     2016-11-12 CRAN (R 3.4.0)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Os gráficos que explicam nossos dados (boxplot)</title>
      <link>/os-graficos-que-explicam-nossos-dados-boxplot/</link>
      <pubDate>Fri, 06 May 2016 00:00:00 +0000</pubDate>
      
      <guid>/os-graficos-que-explicam-nossos-dados-boxplot/</guid>
      <description>&lt;p&gt;Nossos dados merecem ser apresentados de forma clara, atraente e inspiradora. Não há nada mais frustrante que dar duro no campo para coletar os dados e depois apresentá-los numa simples tabela de resumos. Podemos e devemos fazer mais, certo?&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;Vou começar agora uma série de posts sobre tipos de gráficos. Como disse no primeiro post desse &lt;a href=&#34;https://italocegatta.github.io/sobre-esse-blog.html&#34;&gt;blog&lt;/a&gt;, minha intenção é documentar os scripts que escrevi durante a graduação, portanto os gráficos que vou apresentar se resumem aos que tive de fazer por conta de alguma demanda específica.&lt;/p&gt;
&lt;p&gt;Para iniciar, escolhi o gráfico boxplot. É um gráfico muito útil para entender a variabilidade das nossas observações. No boxplot temos 5 informações básicas: valor mínimo, primeiro quartil, mediana, terceiro quartil e valor máximo. Há ainda a notificação de &lt;em&gt;outliers&lt;/em&gt;, quando a observação é maior ou menor que 1,5 vezes a distância interquartílica.&lt;/p&gt;
&lt;p&gt;Vamos trabalhar com os dados que apresentei no post anterior sobre &lt;a href=&#34;https://italocegatta.github.io/o-conceito-tidy-data.html&#34;&gt;tidy data&lt;/a&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(pacman)
p_load(readr, dplyr, tidyr, ggplot2, ggthemes)&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;dados &amp;lt;- read_csv2(
  &amp;quot;https://raw.githubusercontent.com/italocegatta/italocegatta.github.io_source/master/content/dados/base_vespa.csv&amp;quot;
)

dados&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 2,100 × 5
##    Tratamento Individuo Coleta   Local Galhas
##         &amp;lt;chr&amp;gt;     &amp;lt;int&amp;gt;  &amp;lt;int&amp;gt;   &amp;lt;chr&amp;gt;  &amp;lt;int&amp;gt;
## 1   Actara d1         1      1 Peciolo      1
## 2   Actara d1         2      1 Peciolo     NA
## 3   Actara d1         3      1 Peciolo     NA
## 4   Actara d1         4      1 Peciolo     NA
## 5   Actara d1         5      1 Peciolo     NA
## 6   Actara d1         6      1 Peciolo     NA
## 7   Actara d1         7      1 Peciolo     NA
## 8   Actara d1         8      1 Peciolo     NA
## 9   Actara d1         9      1 Peciolo     NA
## 10  Actara d1        10      1 Peciolo     NA
## # ... with 2,090 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Primeiro vamos processar os dados da última medição (Coleta 5) para verificar o nº total de galhas de cada tratamento, desconsiderando o local da galha. Nesse caso estou considerando apenas as mudas que foram atacadas e tiveram o desenvolvimento de galhas.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# seleciona apenas as Coletas de numero 5, em seguida monta um fator de 
# agrupamento em função de Tratamento e Individuo. Aplica a soma de todas as
# observações (Galhas) de acordo com o fator de agrupamento. Troca os valores
# 0 (quando não há galhas) por NA.

total &amp;lt;- dados %&amp;gt;%
  filter(Coleta == 5) %&amp;gt;%
  group_by(Tratamento, Individuo) %&amp;gt;%
  summarise(Galhas = sum(Galhas, na.rm=T)) %&amp;gt;%
  mutate(Galhas = replace(Galhas, Galhas == 0, NA))

total&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Source: local data frame [140 x 3]
## Groups: Tratamento [7]
## 
##    Tratamento Individuo Galhas
##         &amp;lt;chr&amp;gt;     &amp;lt;int&amp;gt;  &amp;lt;int&amp;gt;
## 1   Actara d1         1     11
## 2   Actara d1         2     NA
## 3   Actara d1         3      4
## 4   Actara d1         4     NA
## 5   Actara d1         5     NA
## 6   Actara d1         6     NA
## 7   Actara d1         7     30
## 8   Actara d1         8     NA
## 9   Actara d1         9     NA
## 10  Actara d1        10     NA
## # ... with 130 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;O boxplot é um gráfico unidimensional, ou seja, precisamos de apenas uma variável para construí-lo. Entretanto, podemos usar variáveis categóricas para servir de agrupamento e replicar o gráfico para todos os níveis da variável. Por exemplo, no nosso banco de dados temos &lt;code&gt;Galhas&lt;/code&gt; como variável quantitativa e &lt;code&gt;Tratamento&lt;/code&gt;, &lt;code&gt;Coleta&lt;/code&gt; e &lt;code&gt;Local&lt;/code&gt; como variável qualitativa.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggplot(total, aes(&amp;quot;Total&amp;quot;, Galhas)) +
  geom_boxplot() +
  theme_few()&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;figure&#34;&gt;&lt;span id=&#34;fig:4-boxplot-total&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;/post/2016-05-06-os-graficos-que-explicam-nossos-dados-boxplot_files/figure-html/4-boxplot-total-1.png&#34; alt=&#34;Boxplot que mostra o nº de galhas de todos os tratamentos.&#34; width=&#34;4000&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figura  1: Boxplot que mostra o nº de galhas de todos os tratamentos.
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;A Figura &lt;a href=&#34;#fig:4-boxplot-total&#34;&gt;1&lt;/a&gt; dá uma visão geral de todas as observações em um único boxplot, mas não nos explica muita coisa. No caso da Figura &lt;a href=&#34;#fig:4-boxplot-trat&#34;&gt;2&lt;/a&gt;, &lt;code&gt;Tratamento&lt;/code&gt; tratamento é uma variável categórica e nos permite subdividir os boxplots para todos os níveis e assim podemos compará-los.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggplot(total, aes(Tratamento, Galhas)) +
  geom_boxplot() +
  theme_few()&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;figure&#34;&gt;&lt;span id=&#34;fig:4-boxplot-trat&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;/post/2016-05-06-os-graficos-que-explicam-nossos-dados-boxplot_files/figure-html/4-boxplot-trat-1.png&#34; alt=&#34;Boxplot que mostra o nº de galhas em função de cada tratamento.&#34; width=&#34;4000&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figura  2: Boxplot que mostra o nº de galhas em função de cada tratamento.
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Note que no tratamento &lt;em&gt;Actara d1&lt;/em&gt;, há um indivíduo discrepante (&lt;em&gt;outlier&lt;/em&gt;) que se destaca com 30 galhas. Note também a grande variabilidade entre os tratamentos, muito comum em experimentos envolvendo insetos. Normalmente o coeficiente de variação é extremamente alto e dificilmente há homogeneidade de variância. Um comentário interessante sobre o boxplot é que a caixa, valores entre o 1º e 3º quartil, corresponde a 50% das observações.&lt;/p&gt;
&lt;p&gt;Podemos também avaliar a variabilidade do nº de galhas por local. Para isso vamos incluir a variável &lt;code&gt;Local&lt;/code&gt; no agrupamento (Figura &lt;a href=&#34;#fig:4-boxplot-local&#34;&gt;3&lt;/a&gt;).&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# Adiciona mais um fator de agrupamento para o resumo. Nesse caso cada
# indivíduo terá o nº de galhas explicito em cada local.

local &amp;lt;- dados %&amp;gt;%
  filter(Coleta == 5) %&amp;gt;%
  group_by(Tratamento, Individuo, Local) %&amp;gt;%
  summarise(Galhas = sum(Galhas, na.rm=T)) %&amp;gt;%
  mutate(Galhas = replace(Galhas, Galhas == 0, NA))

local&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Source: local data frame [420 x 4]
## Groups: Tratamento, Individuo [140]
## 
##    Tratamento Individuo   Local Galhas
##         &amp;lt;chr&amp;gt;     &amp;lt;int&amp;gt;   &amp;lt;chr&amp;gt;  &amp;lt;int&amp;gt;
## 1   Actara d1         1   Caule      2
## 2   Actara d1         1 Nervura      3
## 3   Actara d1         1 Peciolo      6
## 4   Actara d1         2   Caule     NA
## 5   Actara d1         2 Nervura     NA
## 6   Actara d1         2 Peciolo     NA
## 7   Actara d1         3   Caule      1
## 8   Actara d1         3 Nervura      1
## 9   Actara d1         3 Peciolo      2
## 10  Actara d1         4   Caule     NA
## # ... with 410 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggplot(local, aes(Tratamento, Galhas, fill = Local)) +
  geom_boxplot() +
  theme_few() +
  scale_fill_brewer(palette = &amp;quot;Spectral&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;figure&#34;&gt;&lt;span id=&#34;fig:4-boxplot-local&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;/post/2016-05-06-os-graficos-que-explicam-nossos-dados-boxplot_files/figure-html/4-boxplot-local-1.png&#34; alt=&#34;Boxplot que mostra o nº de galhas por local e tratamento.&#34; width=&#34;4000&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figura  3: Boxplot que mostra o nº de galhas por local e tratamento.
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Uma outra perspectiva é avaliar a evolução do total de galhas por coleta. Para isto basta incluir a variável &lt;code&gt;Coleta&lt;/code&gt; no agrupamento (Figura &lt;a href=&#34;#fig:4-boxplot-coleta&#34;&gt;4&lt;/a&gt;). Para facilitar a visualização, vou excluir a primeira coleta. Podemos ainda adicionar os pontos que representam as observações para poder identificar quantas observações tem cada tratamento.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;total_coleta &amp;lt;- dados %&amp;gt;%
  filter(Coleta != 1 ) %&amp;gt;%
  group_by(Tratamento, Coleta, Individuo) %&amp;gt;%
  summarise(Galhas = sum(Galhas, na.rm=T)) %&amp;gt;%
  mutate(Galhas = replace(Galhas, Galhas == 0, NA))

total_coleta&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Source: local data frame [560 x 4]
## Groups: Tratamento, Coleta [28]
## 
##    Tratamento Coleta Individuo Galhas
##         &amp;lt;chr&amp;gt;  &amp;lt;int&amp;gt;     &amp;lt;int&amp;gt;  &amp;lt;int&amp;gt;
## 1   Actara d1      2         1      3
## 2   Actara d1      2         2     NA
## 3   Actara d1      2         3     NA
## 4   Actara d1      2         4     NA
## 5   Actara d1      2         5     NA
## 6   Actara d1      2         6     NA
## 7   Actara d1      2         7      2
## 8   Actara d1      2         8     NA
## 9   Actara d1      2         9     NA
## 10  Actara d1      2        10     NA
## # ... with 550 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggplot(total_coleta, aes(Tratamento, Galhas)) +
  geom_boxplot() +
  geom_jitter(alpha = 0.4) +
  facet_wrap(~ Coleta, labeller = label_both) +
  theme_few() +
  theme(axis.text.x = element_text(angle = 30, hjust = 0.5, vjust = 0.5))&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;figure&#34;&gt;&lt;span id=&#34;fig:4-boxplot-coleta&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;/post/2016-05-06-os-graficos-que-explicam-nossos-dados-boxplot_files/figure-html/4-boxplot-coleta-1.png&#34; alt=&#34;Boxplot que mostra a dispersão do total de galhas por tratamento  e coletas.&#34; width=&#34;4000&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figura  4: Boxplot que mostra a dispersão do total de galhas por tratamento e coletas.
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;É importante destacar que o gráfico da Figura &lt;a href=&#34;#fig:4-boxplot-coleta&#34;&gt;4&lt;/a&gt; não é adequado para esse tipo de informação. Nesse caso seria mais interessante um gráfico de linhas em que cada linha representa um tratamento (veremos esse gráfico em um futuro post).&lt;/p&gt;
&lt;p&gt;Caso tenha alguma dúvida ou sugestão sobre o post, fique à vontade para fazer um comentário ou me contactar por Email.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;devtools::session_info()&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  setting  value                       
##  version  R version 3.3.3 (2017-03-06)
##  system   x86_64, mingw32             
##  ui       RTerm                       
##  language (EN)                        
##  collate  Portuguese_Brazil.1252      
##  tz       America/Sao_Paulo           
##  date     2017-04-30                  
## 
##  package      * version date       source                           
##  assertthat     0.2.0   2017-04-11 CRAN (R 3.3.3)                   
##  backports      1.0.5   2017-01-18 CRAN (R 3.3.2)                   
##  blogdown       0.0.25  2017-03-23 Github (rstudio/blogdown@1c10d16)
##  bookdown       0.3.14  2017-03-23 Github (rstudio/bookdown@f427fdf)
##  colorspace     1.3-2   2016-12-14 CRAN (R 3.3.2)                   
##  curl           2.6     2017-04-27 CRAN (R 3.3.3)                   
##  DBI            0.6-1   2017-04-01 CRAN (R 3.3.3)                   
##  devtools       1.12.0  2016-06-24 CRAN (R 3.3.3)                   
##  digest         0.6.12  2017-01-27 CRAN (R 3.3.2)                   
##  dplyr        * 0.5.0   2016-06-24 CRAN (R 3.3.2)                   
##  evaluate       0.10    2016-10-11 CRAN (R 3.3.3)                   
##  ggplot2      * 2.2.1   2016-12-30 CRAN (R 3.3.2)                   
##  ggthemes     * 3.4.0   2017-02-19 CRAN (R 3.3.3)                   
##  gtable         0.2.0   2016-02-26 CRAN (R 3.3.2)                   
##  highr          0.6     2016-05-09 CRAN (R 3.3.3)                   
##  hms            0.3     2016-11-22 CRAN (R 3.3.2)                   
##  htmltools      0.3.6   2017-04-28 CRAN (R 3.3.3)                   
##  knitr          1.15.1  2016-11-22 CRAN (R 3.3.3)                   
##  labeling       0.3     2014-08-23 CRAN (R 3.3.2)                   
##  lazyeval       0.2.0   2016-06-12 CRAN (R 3.3.2)                   
##  magrittr       1.5     2014-11-22 CRAN (R 3.3.2)                   
##  memoise        1.1.0   2017-04-21 CRAN (R 3.3.3)                   
##  munsell        0.4.3   2016-02-13 CRAN (R 3.3.2)                   
##  pacman       * 0.4.1   2016-03-30 CRAN (R 3.3.3)                   
##  plyr           1.8.4   2016-06-08 CRAN (R 3.3.2)                   
##  R6             2.2.0   2016-10-05 CRAN (R 3.3.2)                   
##  RColorBrewer   1.1-2   2014-12-07 CRAN (R 3.3.2)                   
##  Rcpp           0.12.10 2017-03-19 CRAN (R 3.3.3)                   
##  readr        * 1.1.0   2017-03-22 CRAN (R 3.3.3)                   
##  rmarkdown      1.5     2017-04-26 CRAN (R 3.3.3)                   
##  rprojroot      1.2     2017-01-16 CRAN (R 3.3.3)                   
##  scales         0.4.1   2016-11-09 CRAN (R 3.3.2)                   
##  stringi        1.1.5   2017-04-07 CRAN (R 3.3.3)                   
##  stringr        1.2.0   2017-02-18 CRAN (R 3.3.2)                   
##  tibble         1.3.0   2017-04-01 CRAN (R 3.3.3)                   
##  tidyr        * 0.6.1   2017-01-10 CRAN (R 3.3.2)                   
##  withr          1.0.2   2016-06-20 CRAN (R 3.3.3)                   
##  yaml           2.1.14  2016-11-12 CRAN (R 3.3.3)&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>O conceito tidy data</title>
      <link>/o-conceito-tidy-data/</link>
      <pubDate>Sat, 30 Apr 2016 00:00:00 +0000</pubDate>
      
      <guid>/o-conceito-tidy-data/</guid>
      <description>&lt;p&gt;A ideia central desse post é bem simples: dados bem organizados valem a pena e economizam seu tempo!&lt;/p&gt;
&lt;p&gt;Em minha primeira iniciação científica (quando comecei a trabalhar com o R), propus um experimento para avaliar a eficiência de 2 inseticidas para o controle de uma praga que ataca mudas de eucalipto &lt;span class=&#34;citation&#34;&gt;(Cegatta and Villegas &lt;a href=&#34;#ref-cegatta_eficiencia_2013&#34;&gt;2013&lt;/a&gt;)&lt;/span&gt;. Eu estava no primeiro ano da faculdade, sabia muito pouco de Excel e nada de R.&lt;/p&gt;
&lt;p&gt;Neste post vou retomar os dados brutos desse experimento e organizá-los de uma forma eficiente, pois na época não o fiz.&lt;/p&gt;
&lt;p&gt;No experimento tivemos 5 coletas sucessivas de dados para acompanhar a evolução do número de galhas em mudas de eucalipto com diferentes tratamentos de inseticidas. Galha é uma reação da planta que tem diversas causas, nesse caso específico, é devido à postura de uma vespa em busca de abrigo para seus ovos.&lt;/p&gt;
&lt;br&gt;
&lt;div class=&#34;figure&#34;&gt;&lt;span id=&#34;fig:fig-base&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;http://i.imgur.com/JsYqVH7.png&#34; alt=&#34;Dados brutos. Como não organizar seu banco de dados.&#34;  /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figura  1: Dados brutos. Como não organizar seu banco de dados.
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;A estrutura do banco de dados que obtive no fim do experimento está apresentada na Figura &lt;a href=&#34;#fig:fig-base&#34;&gt;1&lt;/a&gt;. Para a época, foi o melhor que consegui fazer e pela inexperiência cometi os seguintes erros:&lt;/p&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;Uso de caracteres especiais.&lt;/li&gt;
&lt;li&gt;Uso de espaço entre as palavras.&lt;/li&gt;
&lt;li&gt;Células mescladas.&lt;/li&gt;
&lt;li&gt;Observações (Nº de galhas no pecíolo, nervura e caule) organizadas em colunas.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;O uso de caracteres especiais não é recomentado em muitas ocasiões, essa dica vale para quase tudo que envolve computação. O mesmo se aplica para os espaços entre as palavras, mas podemos ser mais flexíveis neste caso. Mesclar uma célula será o seu maior problema em uma planilha eletrônica, cuidado com isso! Recomendo mesclar células em raríssimas exceções, como formatação de tabelas em Word ou PowerPoint. O meu último erro foi o maior deles, confundi observações com variáveis. Em minha defesa, o inexperiente Ítalo tentou organizar os dados em um layout de fácil visualização. Veja que é fácil acompanhar a evolução das galhas ao longo do tempo. Para a percepção humana, organização de dados no formato longitudinal é muito prática e rápida. Mas temos que pensar em como o computador trabalha e como ele faz todos os cálculos que precisamos. No fim, eu consegui fazer tudo que eu queria com os dados nesse formato, mas acredite, foi sofrível e muito ineficiente.&lt;/p&gt;
&lt;p&gt;O conceito tidy data está muito bem descrito por &lt;span class=&#34;citation&#34;&gt;Wickham (&lt;a href=&#34;#ref-wickham_tidy_2014&#34;&gt;2014&lt;/a&gt;)&lt;/span&gt;, onde ele apresenta o pacote &lt;a href=&#34;https://cran.r-project.org/web/packages/tidyr/index.html&#34;&gt;tidyr&lt;/a&gt; que contém uma gama de funções muito úteis para esse fim. Wickham também dedicou um capítulo específico sobre esse conceito em seu &lt;a href=&#34;http://r4ds.had.co.nz/&#34;&gt;livro&lt;/a&gt; &lt;span class=&#34;citation&#34;&gt;(Grolemund and Wickham &lt;a href=&#34;#ref-grolemund_r_2016&#34;&gt;2016&lt;/a&gt;)&lt;/span&gt;. Por tidy data, entendemos que:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Variáveis estão dispostas em colunas.&lt;/li&gt;
&lt;li&gt;Observações estão dispostas em linhas.&lt;/li&gt;
&lt;li&gt;Os valores atribuídos às variáveis em cada observação formam a tabela.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Agora vamos aplicar esse conceito ao meu banco de dados. Podemos fazer isso de várias formas, vai depender de como iremos entrar com os dados no R. Vou mostrar 2 métodos que penso ser os mais práticos e genéricos.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# Pacotes utilizados neste post
if (!require(&amp;quot;pacman&amp;quot;)) install.packages(&amp;quot;pacman&amp;quot;)
pacman::p_load(readxl, dplyr, tidyr, httr)&lt;/code&gt;&lt;/pre&gt;
&lt;div id=&#34;metodo-1&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Método 1&lt;/h1&gt;
&lt;p&gt;Partindo da base de dados original, fiz uma pequena alteração separando em cada aba as coletas que foram realizadas (Figura &lt;a href=&#34;#fig:fig-entrada1&#34;&gt;2&lt;/a&gt;).&lt;/p&gt;
&lt;br&gt;
&lt;div class=&#34;figure&#34;&gt;&lt;span id=&#34;fig:fig-entrada1&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;http://i.imgur.com/3AsFpmQ.png&#34; alt=&#34;Modificação do banco de dados original para ser importado no R. Divisão das coletas em abas.&#34;  /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figura  2: Modificação do banco de dados original para ser importado no R. Divisão das coletas em abas.
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Como são apenas 4 abas, podemos importá-las usando um comando por linha.&lt;/p&gt;
&lt;p&gt;Mas e se tivéssemos 50 coletas? Deu preguiça. Vamos melhorar a importação e deixar o computador trabalhar por nós.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# Faz o mesmo que os comandos anteriores, mas utiliza um ´for´ para repetir 
# o precesso em todas as abas. 
dados1 &amp;lt;- list()

for(i in 1:5) {
 dados1[[paste0(&amp;quot;c&amp;quot;,i)]] &amp;lt;- read_excel(base_vespa1, paste0(&amp;quot;Coleta&amp;quot;, i))
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Agora precisamos de um fator (nº da coleta) para diferenciarmos cada medição e colocar tudo em um único data frame.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# Cria um fator para diferenciar as medições medições 
for(i in names(dados1)) {
  dados1[[i]][ , &amp;quot;Coleta&amp;quot;] = i  
}

dados1 &amp;lt;- bind_rows(dados1)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Como minhas análises vão considerar o local da galha como o variável, devo organizar &lt;em&gt;Peciolo&lt;/em&gt;, &lt;em&gt;Nervura&lt;/em&gt; e &lt;em&gt;Caule&lt;/em&gt; em uma só coluna denominada &lt;em&gt;Local&lt;/em&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# Transforma as columas ´Peciolo´, ´Nervura´ e ´Caule´ em uma só coluna
# denominada ´Local´.
dados1 &amp;lt;- gather(
  dados1, &amp;quot;Local&amp;quot;,
  &amp;quot;Galhas&amp;quot;, c(Peciolo, Nervura, Caule)
)

dados1&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 2,100 x 5
##    Tratamento Individuo Coleta   Local Galhas
##         &amp;lt;chr&amp;gt;     &amp;lt;dbl&amp;gt;  &amp;lt;chr&amp;gt;   &amp;lt;chr&amp;gt;  &amp;lt;dbl&amp;gt;
##  1  Actara d1         1     c1 Peciolo      1
##  2  Actara d1         2     c1 Peciolo     NA
##  3  Actara d1         3     c1 Peciolo     NA
##  4  Actara d1         4     c1 Peciolo     NA
##  5  Actara d1         5     c1 Peciolo     NA
##  6  Actara d1         6     c1 Peciolo     NA
##  7  Actara d1         7     c1 Peciolo     NA
##  8  Actara d1         8     c1 Peciolo     NA
##  9  Actara d1         9     c1 Peciolo     NA
## 10  Actara d1        10     c1 Peciolo     NA
## # ... with 2,090 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;metodo-2&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Método 2&lt;/h1&gt;
&lt;p&gt;Nesse método, não fiz nenhuma grande alteração na base de dados. Apenas corrigi o nome das colunas com um fator que indica o número da coleta e em seguida o local (Figura &lt;a href=&#34;#fig:fig-entrada2&#34;&gt;3&lt;/a&gt;).&lt;/p&gt;
&lt;br&gt;
&lt;div class=&#34;figure&#34;&gt;&lt;span id=&#34;fig:fig-entrada2&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;http://i.imgur.com/YGY8pvV.png&#34; alt=&#34;Modificação do banco de dados original para ser importado no R. Alteração dos nomes das colunas.&#34;  /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figura  3: Modificação do banco de dados original para ser importado no R. Alteração dos nomes das colunas.
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Vamos agora importar e organizar os dados no mesmo formato que no método 1, mas com um código bem mais simples.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# Lê os dados, transforma as variáveis que estão em várias colunas em uma só e
# Separa as informações que estão na coluna ´Local´ em duas colunas (variáveis)
# ´Coleta´ e ´Local´.
dados2 &amp;lt;- read_excel(base_vespa2) %&amp;gt;%
  gather(&amp;quot;Local&amp;quot;, &amp;quot;Galhas&amp;quot;, 3:dim(.)[2]) %&amp;gt;%
  separate(Local, c(&amp;quot;Coleta&amp;quot;, &amp;quot;Local&amp;quot;))

dados2&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 2,100 x 5
##    Tratamento Individuo Coleta   Local Galhas
##  *      &amp;lt;chr&amp;gt;     &amp;lt;dbl&amp;gt;  &amp;lt;chr&amp;gt;   &amp;lt;chr&amp;gt;  &amp;lt;dbl&amp;gt;
##  1  Actara d1         1      1 Peciolo      1
##  2  Actara d1         2      1 Peciolo     NA
##  3  Actara d1         3      1 Peciolo     NA
##  4  Actara d1         4      1 Peciolo     NA
##  5  Actara d1         5      1 Peciolo     NA
##  6  Actara d1         6      1 Peciolo     NA
##  7  Actara d1         7      1 Peciolo     NA
##  8  Actara d1         8      1 Peciolo     NA
##  9  Actara d1         9      1 Peciolo     NA
## 10  Actara d1        10      1 Peciolo     NA
## # ... with 2,090 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Com os dados nesse formato fica incrivelmente fácil fazer gráficos, resumos e testes. Vou abordar esses pontos no futuro em outros posts.&lt;/p&gt;
&lt;p&gt;Caso tenha alguma dúvida ou sugestão sobre o post, fique à vontade para fazer um comentário ou me contactar por Email.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;devtools::session_info()&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  setting  value                       
##  version  R version 3.4.0 (2017-04-21)
##  system   x86_64, mingw32             
##  ui       RTerm                       
##  language (EN)                        
##  collate  Portuguese_Brazil.1252      
##  tz       America/Sao_Paulo           
##  date     2017-09-16                  
## 
##  package    * version date       source                          
##  assertthat   0.2.0   2017-04-11 CRAN (R 3.4.0)                  
##  backports    1.1.0   2017-05-22 CRAN (R 3.4.0)                  
##  base       * 3.4.0   2017-04-21 local                           
##  bindr        0.1     2016-11-13 CRAN (R 3.4.0)                  
##  bindrcpp     0.2     2017-06-17 CRAN (R 3.4.0)                  
##  blogdown     0.1     2017-08-22 CRAN (R 3.4.1)                  
##  bookdown     0.5     2017-08-20 CRAN (R 3.4.1)                  
##  cellranger   1.1.0   2016-07-27 CRAN (R 3.4.0)                  
##  compiler     3.4.0   2017-04-21 local                           
##  curl         2.8.1   2017-07-21 CRAN (R 3.4.1)                  
##  datasets   * 3.4.0   2017-04-21 local                           
##  devtools     1.13.3  2017-08-02 CRAN (R 3.4.1)                  
##  digest       0.6.12  2017-01-27 CRAN (R 3.4.0)                  
##  dplyr      * 0.7.3   2017-09-09 CRAN (R 3.4.1)                  
##  evaluate     0.10.1  2017-06-24 CRAN (R 3.4.0)                  
##  glue         1.1.1   2017-06-21 CRAN (R 3.4.0)                  
##  graphics   * 3.4.0   2017-04-21 local                           
##  grDevices  * 3.4.0   2017-04-21 local                           
##  highr        0.6     2016-05-09 CRAN (R 3.4.0)                  
##  htmltools    0.3.6   2017-04-28 CRAN (R 3.4.0)                  
##  httr       * 1.3.1   2017-08-20 CRAN (R 3.4.1)                  
##  knitr        1.17    2017-08-10 CRAN (R 3.4.1)                  
##  magrittr     1.5     2014-11-22 CRAN (R 3.4.0)                  
##  memoise      1.1.0   2017-04-21 CRAN (R 3.4.0)                  
##  methods    * 3.4.0   2017-04-21 local                           
##  pacman     * 0.4.6   2017-05-14 CRAN (R 3.4.0)                  
##  pkgconfig    2.0.1   2017-03-21 CRAN (R 3.4.0)                  
##  purrr        0.2.3   2017-08-02 CRAN (R 3.4.1)                  
##  R6           2.2.2   2017-06-17 CRAN (R 3.4.0)                  
##  Rcpp         0.12.12 2017-07-15 CRAN (R 3.4.1)                  
##  readxl     * 1.0.0   2017-04-18 CRAN (R 3.4.0)                  
##  rlang        0.1.2   2017-08-09 CRAN (R 3.4.1)                  
##  rmarkdown    1.6     2017-06-15 CRAN (R 3.4.0)                  
##  rprojroot    1.2     2017-01-16 CRAN (R 3.4.0)                  
##  stats      * 3.4.0   2017-04-21 local                           
##  stringi      1.1.5   2017-04-07 CRAN (R 3.4.0)                  
##  stringr      1.2.0   2017-02-18 CRAN (R 3.4.0)                  
##  tibble       1.3.4   2017-08-22 CRAN (R 3.4.1)                  
##  tidyr      * 0.7.1   2017-09-01 CRAN (R 3.4.1)                  
##  tidyselect   0.2.0   2017-08-30 CRAN (R 3.4.1)                  
##  tools        3.4.0   2017-04-21 local                           
##  utils      * 3.4.0   2017-04-21 local                           
##  withr        2.0.0   2017-08-08 Github (jimhester/withr@190d293)
##  yaml         2.1.14  2016-11-12 CRAN (R 3.4.0)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;referencias&#34; class=&#34;section level1 unnumbered&#34;&gt;
&lt;h1&gt;Referências&lt;/h1&gt;
&lt;div id=&#34;refs&#34; class=&#34;references&#34;&gt;
&lt;div id=&#34;ref-cegatta_eficiencia_2013&#34;&gt;
&lt;p&gt;Cegatta, Italo Ramos, and Cristian Villegas. 2013. “Eficiência de dois inseticidas sistêmicos no controle de Leptocybe invasa em mudas de Eucalyptus camaldulensis.” &lt;em&gt;Revista Instituto Florestal&lt;/em&gt; 25 (2). &lt;a href=&#34;iflorestal.sp.gov.br/files/2014/05/RIF25-2{\_}215-221.pdf&#34; class=&#34;uri&#34;&gt;iflorestal.sp.gov.br/files/2014/05/RIF25-2{\_}215-221.pdf&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;ref-grolemund_r_2016&#34;&gt;
&lt;p&gt;Grolemund, Garrett, and Hadley Wickham. 2016. &lt;em&gt;R for Data Science&lt;/em&gt;. O’Reilly Media. &lt;a href=&#34;http://r4ds.had.co.nz/&#34; class=&#34;uri&#34;&gt;http://r4ds.had.co.nz/&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;ref-wickham_tidy_2014&#34;&gt;
&lt;p&gt;Wickham, Hadley. 2014. “Tidy data.” &lt;em&gt;The Journal of Statistical Software&lt;/em&gt; 59 (10). &lt;a href=&#34;http://www.jstatsoft.org/v59/i10/&#34; class=&#34;uri&#34;&gt;http://www.jstatsoft.org/v59/i10/&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>O R é para você</title>
      <link>/o-r-e-para-voce/</link>
      <pubDate>Tue, 26 Apr 2016 00:00:00 +0000</pubDate>
      
      <guid>/o-r-e-para-voce/</guid>
      <description>&lt;p&gt;Se dedicar para aprender uma nova linguagem de programação não é uma tarefa fácil. Principalmente para quem não tem um background de lógica de programação. Não me lembro de me perguntar se valeria a pena ou não estudar o R. Eu estava tão entusiasmado com toda aquela situação de gráficos, tabelas e estatísticas que, quando vi, já tinha passado algumas madrugadas programando.&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;Vou tentar focar esse texto em duas perguntas muito importantes para quem está chegando agora na comunidade R: será que vale a pena aprender a programar em R? Se sim, por onde posso começar?&lt;/p&gt;
&lt;div id=&#34;sobre-o-r&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Sobre o R&lt;/h2&gt;
&lt;p&gt;O R é um software open-source mantido por um grupo de voluntários de vários países, o R-core team. No site oficial do &lt;a href=&#34;https://www.r-project.org/&#34;&gt;projeto&lt;/a&gt; &lt;span class=&#34;citation&#34;&gt;(R Core Team &lt;a href=&#34;#ref-r_development_core_team_r:_2016&#34;&gt;2016&lt;/a&gt;)&lt;/span&gt; a primeira descrição sobre ele é a seguinte:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;O R é uma linguagem e ambiente para computação estatística e gráficos.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Esse grupo mantem o sistema base que possibilita a interação com a linguagem R para computação numérica, manipulação de dados, gráficos e uma variedade de outras tarefas. No R, tudo o que acontece é o resultado de uma função. Eu, você e tantos outros usuários podemos desenvolver funções para facilitar a nossa vida, posteriormente organizá-las em pacotes (ou &lt;em&gt;packages&lt;/em&gt;) e depois disponibilizar para todo o mundo &lt;span class=&#34;citation&#34;&gt;(Chambers &lt;a href=&#34;#ref-chambers_software_2008&#34;&gt;2008&lt;/a&gt;)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;O projeto do R teve início com Ross Ihaka e Robert Gentleman nos anos 90 a partir de uma implementação da linguagem S, que foi desenvolvida anos antes por um grupo de pesquisadores liderados por John Chambers no Bell Laboratories &lt;span class=&#34;citation&#34;&gt;(Chambers &lt;a href=&#34;#ref-chambers_software_2008&#34;&gt;2008&lt;/a&gt;)&lt;/span&gt;. Desde então, o R tem crescido em um ritmo absurdo e pode ser considerado o principal software livre para programação estatística e um dos mais usados no mundo &lt;span class=&#34;citation&#34;&gt;(Revolution Analitics &lt;a href=&#34;#ref-revolution_analitics_rs_2016&#34;&gt;2016&lt;/a&gt;; Docsity &lt;a href=&#34;#ref-docsity_statistical_2014&#34;&gt;2014&lt;/a&gt;)&lt;/span&gt;. Não vou listar todas potencialidades do R aqui neste post, em primeiro lugar por que eu não domino todas elas e segundo por que com certeza o post ficaria muito grande. Com o tempo vou apresentar nos posts algumas aplicações pontuais do R com relação aos problemas que precisei resolver. Mas já adianto, é comum dizermos que a pergunta certa sobre uma tarefa no R não é &lt;em&gt;se podemos fazer&lt;/em&gt;, mas sim &lt;em&gt;como&lt;/em&gt; podemos fazer.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;o-r-e-para-mim&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;O R é para mim?&lt;/h2&gt;
&lt;p&gt;O R tem uma curva de aprendizado um tanto íngreme, no começo é realmente muito frustrante. Uma vez, me lembro de passar horas para conseguir deixar a legenda com as cores que eu queria. Dá vontade de largar tudo e fazer o gráfico no Excel. Mas se você é um pouco persistente no começo e encara como um desafio, as coisas melhoram e essa etapa logo passa.&lt;/p&gt;
&lt;p&gt;Minha formação é em Eng. Florestal, na grade curricular do meu curso não há nada relacionado à lógica e conceitos de programação, ou seja, tive que me motivar muito para aprender a programar, por que para mim abstrair a lógica de um código ou rotina em R não foi (e nem é) fácil. De fato, não é todo mundo que sabe programar e nem por isso se torna um mal profissional, pois há vários softwares que possuem uma interface gráfica totalmente adaptada para o usuário em forma de botões e cliques. Mas com muita certeza, os profissionais que podem programar tem um horizonte de possibilidades devido a flexibilidade de poder escrever seu próprio programa de processamento.&lt;/p&gt;
&lt;p&gt;Costumo dizer para os meus amigos que o grande trunfo de um programador é a preguiça. Eu particularmente sou bem preguiçoso quando tenho de fazer atividades repetitivas. A Figura &lt;a href=&#34;#fig:geek-task&#34;&gt;1&lt;/a&gt; ilustra bem uma situação que já ocorreu comigo muitas vezes, onde meus amigos (e até minha namorada!) faziam processos repetitivos usando o Excel, enquanto eu só conseguia pensar em como fazer aquilo de uma forma rápida e eficiente no R.&lt;/p&gt;
&lt;div class=&#34;figure&#34;&gt;&lt;span id=&#34;fig:geek-task&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;http://i.imgur.com/e8otnTl.png&#34; alt=&#34;Programadores versus não-programadores quando fazem tarefas repetitivas [@iwaya_geeks_2012].&#34;  /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figura  1: Programadores versus não-programadores quando fazem tarefas repetitivas &lt;span class=&#34;citation&#34;&gt;(Iwaya &lt;a href=&#34;#ref-iwaya_geeks_2012&#34;&gt;2012&lt;/a&gt;)&lt;/span&gt;.
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Se você está na dúvida e é daqueles que preferem respostas rápidas, meu professor de biometria pode te ajudar nesse sentido &lt;span class=&#34;citation&#34;&gt;(Batista &lt;a href=&#34;#ref-batista_curso_2015&#34;&gt;2015&lt;/a&gt;)&lt;/span&gt;, com estas afirmações:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Você não quer aprender uma linguagem e realizar análises utilizando comandos.&lt;/li&gt;
&lt;li&gt;Você acredita que análise estatística é um simples protocolo para obter alguns resultados numéricos.&lt;/li&gt;
&lt;li&gt;Você acredita que para cada situação ou conjunto de dados existe &lt;em&gt;a análise&lt;/em&gt; estatística correta.&lt;/li&gt;
&lt;li&gt;Você não sabe o que é análise estatística baseada em modelos e não está nenhum pouco interessado em saber.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Se você concorda com essas afirmações, pense bem antes de dedicar seu tempo nesse caminho. Continue no Excel eu em outro programa amigável e seja feliz. Mas se você já programa em alguma linguagem, ou tem uma certa facilidade para isso, a situação é outra. Veja quais benefícios o R tem em relação ao seu atual software e avalie se essa empreitada vale a pena.&lt;/p&gt;
&lt;p&gt;No meu caso, o SAS resolve a maioria dos problemas relacionados ao processamento de dados e análise estatística de um florestal. Então, a decisão nesse sentido tem que ser bem pontual e depende essencialmente das tarefas que você realiza. Para mim, o R sai na frente por ser uma linguagem livre e com um grupo de desenvolvedores muito grande, o que possibilita a criação de diversas funcionalidades de vanguarda. Outro trunfo do R é a integração com outros softwares e linguagens, que nos possibilita criar aplicações web e em servidores.&lt;/p&gt;
&lt;p&gt;Para fechar o tópico, se as suas tarefas estão relacionadas à análise e processamento de dados e você sente que perde um tempo em atividades repetitivas, talvez seja preciso rever o método. Programando você fará as coisas de forma rapida, considere isso como um investimento a longo prazo.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;por-onde-eu-comeco&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Por onde eu começo?&lt;/h2&gt;
&lt;p&gt;A parte boa de um software livre é que a comunidade que trabalha com ele normalmente disponibiliza seus produtos e projetos gratuitamente. Se você chegou nesse post por que está interessado no R mas não sabe nada ou muito pouco, vou listar algumas dicas que me ajudaram e ainda me ajudam quando preciso fazer algo no R.&lt;/p&gt;
&lt;div id=&#34;comece-vendo-e-ouvindo&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;1. Comece vendo e ouvindo&lt;/h3&gt;
&lt;p&gt;Para quem está começando, é melhor ver e ouvir como as coisas funcionam. Eu particularmente só entendi o jeitão do R quando meu orientador de iniciação científica me explicou. Então segue algumas dicas:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.udemy.com/computacao_r/&#34;&gt;Computação em R - Udemy.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.datacamp.com/courses/free-introduction-to-r&#34;&gt;Introduction to R - DataCamp.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://pt.coursera.org/learn/r-programming/&#34;&gt;R Programming - Coursera.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=cX532N_XLIs&amp;amp;list=PLqzoL9-eJTNBDdKgJgJzaQcY6OXmsXAHU&#34;&gt;Vídeo aulas no Youtube.&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div id=&#34;sites-interessantes&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;2. Sites interessantes&lt;/h3&gt;
&lt;p&gt;Existe uma infinidade de sites e blogs dedicados a te ensinar a programar em R. Mas a maioria espera que você já tenha uma mínima noção de como a linguagem funciona. Com certeza você vai precisar acessar um desses links para resolver algo com o R. Esses são alguns dos links que eu tenho salvo na minha pasta de favoritos no navegador.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.rstudio.com/online-learning/&#34;&gt;RStudio.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.r-tutor.com/%22%20target=%22_blank&#34;&gt;R tutor.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.statmethods.net/&#34;&gt;Quik R.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://rstatistics.net/&#34;&gt;R Statistics.net.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.r-bloggers.com/&#34;&gt;R-bloggers.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://stackoverflow.com/tags/r&#34;&gt;Stackoverflow.&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div id=&#34;livros-e-apostilas&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;3. Livros e apostilas&lt;/h3&gt;
&lt;p&gt;No começo, eu acabei juntando uma pasta com muitos livros e apostilas do R. Uns foram úteis outros não. Meu conselho é que você escolha 3 livros para estudar de verdade. Depois disso os livros vão servir apenas para consultas de questões muito específicas. Segue algumas sugestões de livros e apostilas disponíveis gratuitamente na web.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.cookbook-r.com/&#34;&gt;Cookbook for R.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://r4ds.had.co.nz/&#34;&gt;R for Data Science.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.leg.ufpr.br/~paulojus/&#34;&gt;Apostilas do Prof. Paulo Justiniano, foco em estatística.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://cmq.esalq.usp.br/wiki/doku.php?id=publico:tutoriais:start&#34;&gt;Apostila do Prof. João Batista, foco em inventário florestal.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://cran.r-project.org/doc/contrib/Beasley-BioestatisticaUsandoR.pd&#34;&gt;Apostila do Prof. Colin Beasley, foco em biologia.&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div id=&#34;ambiente-de-desenvolvimento&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;4. Ambiente de desenvolvimento&lt;/h3&gt;
&lt;p&gt;A interface gráfica do R é bem simples. Acostume-se, isso não mudar. Mas felizmente muitas empresas desenvolveram ambientes de desenvolvimento integrado para facilitar a vida do usuário. Nesse sentido, eu recomendo fortemente utilizar o &lt;a href=&#34;https://www.rstudio.com/&#34;&gt;RStudio&lt;/a&gt; como ambiente de programação. O RStudio tem uma das equipes mais atuantes da comunidade R e a cada dia que passa estão tornando a programação mais eficiente e prazerosa.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;referencias&#34; class=&#34;section level2 unnumbered&#34;&gt;
&lt;h2&gt;Referências&lt;/h2&gt;
&lt;div id=&#34;refs&#34; class=&#34;references&#34;&gt;
&lt;div id=&#34;ref-batista_curso_2015&#34;&gt;
&lt;p&gt;Batista, João. 2015. “Curso Relâmpago de R.” &lt;a href=&#34;http://cmq.esalq.usp.br/wiki/doku.php?id=publico:tutoriais:r-relampago:start&#34; class=&#34;uri&#34;&gt;http://cmq.esalq.usp.br/wiki/doku.php?id=publico:tutoriais:r-relampago:start&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;ref-chambers_software_2008&#34;&gt;
&lt;p&gt;Chambers, John. 2008. &lt;em&gt;Software for Data Analysis&lt;/em&gt;. Statistics and Computing. New York, NY: Springer New York. &lt;a href=&#34;http://link.springer.com/10.1007/978-0-387-75936-4&#34; class=&#34;uri&#34;&gt;http://link.springer.com/10.1007/978-0-387-75936-4&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;ref-docsity_statistical_2014&#34;&gt;
&lt;p&gt;Docsity. 2014. “Statistical Language Wars: Comparison among SAS, R and SPSS.” &lt;a href=&#34;http://www.docsity.com/en/news/programming-2/statistical-language-wars-comparison-sas-spss/&#34; class=&#34;uri&#34;&gt;http://www.docsity.com/en/news/programming-2/statistical-language-wars-comparison-sas-spss/&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;ref-iwaya_geeks_2012&#34;&gt;
&lt;p&gt;Iwaya, Akemi. 2012. “Geeks versus Non-Geeks when Doing Repetitive Tasks [Funny Chart].” &lt;a href=&#34;http://www.howtogeek.com/102420/geeks-versus-non-geeks-when-doing-repetitive-tasks-funny-chart/&#34; class=&#34;uri&#34;&gt;http://www.howtogeek.com/102420/geeks-versus-non-geeks-when-doing-repetitive-tasks-funny-chart/&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;ref-r_development_core_team_r:_2016&#34;&gt;
&lt;p&gt;R Core Team. 2016. “R: A Language and Environment for Statistical Computing.” &lt;em&gt;R Foundation for Statistical Computing&lt;/em&gt; 3.3.0. Vienna: R Foundation for Statistical Computing. &lt;a href=&#34;http://www.r-project.org&#34; class=&#34;uri&#34;&gt;http://www.r-project.org&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;ref-revolution_analitics_rs_2016&#34;&gt;
&lt;p&gt;Revolution Analitics. 2016. “R’s popularity.” &lt;a href=&#34;http://blog.revolutionanalytics.com/popularity&#34; class=&#34;uri&#34;&gt;http://blog.revolutionanalytics.com/popularity&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
    </item>
    
  </channel>
</rss>